All Listing and Assembly Files

./output/001.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program    stage0no001;   {here is a comment}
    2|     const yes=true;no=false;
    3|           small=0;smalleryet=-1;
    4|           big = 1;  biggeryet = 2;  large = biggeryet;
    5|		   maybe = not true;
    6|     var   some,many:integer;
    7|           right, wrong : boolean;
    8|     begin
    9|     end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/002.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage0no002;
    2|      {illustrate erroneous use of Pascallite features:}
    3|	    {odd vs. even length in comment okay          }
    4|        {should find z+ as illegal name              }
    5|
    6|   var x: integer;     
    7|       z+:
Error: Line 7: ":" expected

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/003.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage0no003;
    2|      {illustrate erroneous use of Pascallite features.}
    3|      {tests spelling of integer}
    4|
    5|
    6|   var ram: integer;
    7|       asis: integr;
Error: Line 7: illegal type follows ":"

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/004.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage0no004;
    2|      {x may not be redefined}
    3|
    4|   var x: integer; {x may not be redefined}
    5|       x: integer; 
Error: Line 5: symbol x is multiply defined

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/005.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage0no005;
    2|      {illustrate erroneous use of Pascallite features.}
    3|      {const must come before var}
    4|
    5|		 var y:integer;
    6|    const 
Error: Line 6: non-keyword identifier or "begin" expected

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/006.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage0no006;
    2|      {illustrate erroneous use of Pascallite features.}
    3|      {no lists of constants allowed}
    4| 
    5|    const help = 32;
    6|
    7|       s,t
Error: Line 7: "=" expected

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/007.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage0no007;
    2|      {illustrate erroneous use of Pascallite features.}
    3|      {program should end with a period, not a semicolon}
    4|
    5|    const help = 32;
    6|          ram = 3;
    7|    begin end; 
Error: Line 7: period expected

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/008.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage0no008;
    2|	{reserved keyword var misused as nonkey_id}
    3|
    4|	const var 
Error: Line 4: non-keyword identifier must follow "const"

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/009.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage0no009;
    2|    { { need a literal and '=' for a constant
    3|  also test two opens and one close}
    4|
    5|   const car = 2;
    6|         silly:b
Error: Line 6: "=" expected

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/010.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage0no010;
    2|    {only one occurrence of 'const' allowed}
    3|
    4|   const car = 2;
    5|   const 
Error: Line 5: non - keyword identifier, "begin", or "var" expected

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/011.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage0no011;
    2|   {no real numbers in our Pascallite}
    3|
    4|   const car = 2;
    5|         wrong = 3.5
Error: Line 5: semicolon expected

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/012.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage0no012;
    2|  {no embedded blanks in a token}
    3|
    4|   const car = 2;
    5|         po or 
Error: Line 5: "=" expected

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/013.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage0no013;
    2|    {referencing an undefined constant}
    3|
    4|   const car = 2;
    5|         s = b; 
Error: Line 5: variable b is undefined

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/014.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage0no014;
    2|   {   no embedded begin-end statement allowed}
    3|
    4|   const car = 2;
    5|   begin begin 
Error: Line 5: ";", "begin", "read","write", "end" expected

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/015.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage0no015;
    2|{ only whitespace and comments are legal following "end." }
    3|    const yes = true; no = false;
    4|          small = 0; smalleryet = -1;
    5|          big = 1; biggeryet = 2;
    6|          same = big;
    7|	 var   some : integer;
    8|          right: boolean;
    9|    begin
   10|    end.    const

Error: Line 10: no text may follow "end"

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/016.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage0no016;
    2|      { { tests embedded comments should be illegal } }
Error: Line 2: '}' cannot begin token

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/017.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage0no017;
    2|		  {demonstrate erroneous features of Pascallite}
    3|		  {test reserved word split between two lines
    4|	 should be error}
    5|  con

Error: Line 5: keyword "begin" expected

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/018.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage0no018;
    2|         {test a lot of long non_key_ids, should be okay}
    3|  const  zero = 0;  five{5} = 5;
    4|  var
    5|aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:  integer;
    6|bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb:  integer;
    7|ccccccccccccccccccccccccccccccc:  integer;
    8|ddddddddddddddddddddddddddddddd:  integer;
    9|eeeeeeeeeeeeeeeeeeeeeeeeeeeeeee:  integer;
   10|fffffffffffffffffffffffffffffff:  integer;
   11|ggggggggggggggggggggggggggggggg:  integer;
   12|hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh:  integer;
   13|iiiiiiiiiiiiiiiiiiiiiiiiiiiiiii:  integer;
   14|jjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj:  integer;
   15|kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk:  integer;
   16|lllllllllllllllllllllllllllllll:  integer;
   17|mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm:  integer;
   18|nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn:  integer;
   19|ooooooooooooooooooooooooooooooo:  integer;
   20|ppppppppppppppppppppppppppppppp:  integer;
   21|qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq:  integer;
   22|rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr:  integer;
   23|sssssssssssssssssssssssssssssss:  integer;
   24|ttttttttttttttttttttttttttttttt:  integer;
   25|uuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu:  integer;
   26|vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv:  integer;
   27|wwwwwwwwwwwwwwwwwwwwwwwwwwwwwww:  integer;
   28|xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx:  integer;
   29|yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy:  integer;
   30|zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz: integer;       d: 
   31| boolean;
   32|  begin
   33|end  .

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/019.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage0no019;
    2|		 { identifiers should not start with an underscore }
    3|    const yes = true; no = false;
    4|          small = 0; smalleryet = -1;
    5|          big = 1; bigger_yet = 2;
    6|          _
Error: Line 6: illegal symbol

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/020.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage0no020;
    2|		 { identifiers should not end with an underscore }
    3|    const yes = true; no = false;
    4|          small = 0; smalleryet ={} -1;
    5|          big = 1; bigger_yet = 2;
    6|        var   some_ 
Error: Line 6: illegal character '_'

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/021.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage0no021;
    2|		 { No caps for us at all}
    3|    const Y
Error: Line 3: illegal symbol

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/022.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage0no022;
    2|		 { remember, all vars and consts max of 15 chars
    3|		   so trancate at 15, and get multiply defined symbols
    4|		   }
    5|    const yes = true; no = false;
    6|          small = 0; smalleryet = -1;
    7|   	 var   some : integer;
    8|          right: boolean;
    9|          aaaaaaaaaaaaaaaaaaaa1,
   10|          aaaaaaaaaaaaaaaaaaaa2:integer;

Error: Line 10: symbol aaaaaaaaaaaaaaa is multiply defined

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/023.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage0no023;
    2|		 { No caps for us at all, not even for reserved words}
    3|    C
Error: Line 3: illegal symbol

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/024.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program ;

Error: Line 1: program name expected

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/025.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage0no025;
    2|		 {missing ending bracket
    3|    const yes = true; no = false;
    4|         	 var   some : integer;
    5|         
    6|    begin end.    

Error: Line 6: unexpected end of file

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/026.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage0no026;
    2|         {fill the symbol table with 256 entries; should be ok}
    3|  var
    4|var000,var001,var002,var003,var004,var005,var006,var007,var008,var009,
    5|var010,var011,var012,var013,var014,var015,var016,var017,var018,var019,
    6|var020,var021,var022,var023,var024,var025,var026,var027,var028,var029,
    7|var030,var031,var032,var033,var034,var035,var036,var037,var038,var039,
    8|var040,var041,var042,var043,var044,var045,var046,var047,var048,var049,
    9|var050,var051,var052,var053,var054,var055,var056,var057,var058,var059,
   10|var060,var061,var062,var063,var064,var065,var066,var067,var068,var069,
   11|var070,var071,var072,var073,var074,var075,var076,var077,var078,var079,
   12|var080,var081,var082,var083,var084,var085,var086,var087,var088,var089,
   13|var090,var091,var092,var093,var094,var095,var096,var097,var098,var099,
   14|var100,var101,var102,var103,var104,var105,var106,var107,var108,var109,
   15|var110,var111,var112,var113,var114,var115,var116,var117,var118,var119,
   16|var120,var121,var122,var123,var124,var125,var126,var127,var128,var129,
   17|var130,var131,var132,var133,var134,var135,var136,var137,var138,var139,
   18|var140,var141,var142,var143,var144,var145,var146,var147,var148,var149,
   19|var150,var151,var152,var153,var154,var155,var156,var157,var158,var159,
   20|var160,var161,var162,var163,var164,var165,var166,var167,var168,var169,
   21|var170,var171,var172,var173,var174,var175,var176,var177,var178,var179,
   22|var180,var181,var182,var183,var184,var185,var186,var187,var188,var189,
   23|var190,var191,var192,var193,var194,var195,var196,var197,var198,var199,
   24|var200,var201,var202,var203,var204,var205,var206,var207,var208,var209,
   25|var210,var211,var212,var213,var214,var215,var216,var217,var218,var219,
   26|var220,var221,var222,var223,var224,var225,var226,var227,var228,var229,
   27|var230,var231,var232,var233,var234,var235,var236,var237,var238,var239,
   28|var240,var241,var242,var243,var244,var245,var246,var247,var248,var249,
   29|var250,var251,var252,var253,var254
   30|: integer;
   31|  begin
   32|end  .

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/027.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage0no027;
    2|         {fill the symbol table with 257 entries;
    3|          should be symbol table overflow}
    4|  var
    5|var000,var001,var002,var003,var004,var005,var006,var007,var008,var009,
    6|var010,var011,var012,var013,var014,var015,var016,var017,var018,var019,
    7|var020,var021,var022,var023,var024,var025,var026,var027,var028,var029,
    8|var030,var031,var032,var033,var034,var035,var036,var037,var038,var039,
    9|var040,var041,var042,var043,var044,var045,var046,var047,var048,var049,
   10|var050,var051,var052,var053,var054,var055,var056,var057,var058,var059,
   11|var060,var061,var062,var063,var064,var065,var066,var067,var068,var069,
   12|var070,var071,var072,var073,var074,var075,var076,var077,var078,var079,
   13|var080,var081,var082,var083,var084,var085,var086,var087,var088,var089,
   14|var090,var091,var092,var093,var094,var095,var096,var097,var098,var099,
   15|var100,var101,var102,var103,var104,var105,var106,var107,var108,var109,
   16|var110,var111,var112,var113,var114,var115,var116,var117,var118,var119,
   17|var120,var121,var122,var123,var124,var125,var126,var127,var128,var129,
   18|var130,var131,var132,var133,var134,var135,var136,var137,var138,var139,
   19|var140,var141,var142,var143,var144,var145,var146,var147,var148,var149,
   20|var150,var151,var152,var153,var154,var155,var156,var157,var158,var159,
   21|var160,var161,var162,var163,var164,var165,var166,var167,var168,var169,
   22|var170,var171,var172,var173,var174,var175,var176,var177,var178,var179,
   23|var180,var181,var182,var183,var184,var185,var186,var187,var188,var189,
   24|var190,var191,var192,var193,var194,var195,var196,var197,var198,var199,
   25|var200,var201,var202,var203,var204,var205,var206,var207,var208,var209,
   26|var210,var211,var212,var213,var214,var215,var216,var217,var218,var219,
   27|var220,var221,var222,var223,var224,var225,var226,var227,var228,var229,
   28|var230,var231,var232,var233,var234,var235,var236,var237,var238,var239,
   29|var240,var241,var242,var243,var244,var245,var246,var247,var248,var249,
   30|var250,var251,var252,var253,var254,var255
   31|: integer;

Error: Line 31: symbol table overflow

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/028.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage0no028;
    2|         {fill the symbol table with 256 entries; should be ok}
    3|  var
    4|var000 : integer;
    5|var001 : integer;
    6|var002 : integer;
    7|var003 : integer;
    8|var004 : integer;
    9|var005 : integer;
   10|var006 : integer;
   11|var007 : integer;
   12|var008 : integer;
   13|var009 : integer;
   14|
   15|var010 : integer;
   16|var011 : integer;
   17|var012 : integer;
   18|var013 : integer;
   19|var014 : integer;
   20|var015 : integer;
   21|var016 : integer;
   22|var017 : integer;
   23|var018 : integer;
   24|var019 : integer;
   25|
   26|var020 : integer;
   27|var021 : integer;
   28|var022 : integer;
   29|var023 : integer;
   30|var024 : integer;
   31|var025 : integer;
   32|var026 : integer;
   33|var027 : integer;
   34|var028 : integer;
   35|var029 : integer;
   36|
   37|var030 : integer;
   38|var031 : integer;
   39|var032 : integer;
   40|var033 : integer;
   41|var034 : integer;
   42|var035 : integer;
   43|var036 : integer;
   44|var037 : integer;
   45|var038 : integer;
   46|var039 : integer;
   47|
   48|var040 : integer;
   49|var041 : integer;
   50|var042 : integer;
   51|var043 : integer;
   52|var044 : integer;
   53|var045 : integer;
   54|var046 : integer;
   55|var047 : integer;
   56|var048 : integer;
   57|var049 : integer;
   58|
   59|var050 : integer;
   60|var051 : integer;
   61|var052 : integer;
   62|var053 : integer;
   63|var054 : integer;
   64|var055 : integer;
   65|var056 : integer;
   66|var057 : integer;
   67|var058 : integer;
   68|var059 : integer;
   69|
   70|var060 : integer;
   71|var061 : integer;
   72|var062 : integer;
   73|var063 : integer;
   74|var064 : integer;
   75|var065 : integer;
   76|var066 : integer;
   77|var067 : integer;
   78|var068 : integer;
   79|var069 : integer;
   80|
   81|var070 : integer;
   82|var071 : integer;
   83|var072 : integer;
   84|var073 : integer;
   85|var074 : integer;
   86|var075 : integer;
   87|var076 : integer;
   88|var077 : integer;
   89|var078 : integer;
   90|var079 : integer;
   91|
   92|var080 : integer;
   93|var081 : integer;
   94|var082 : integer;
   95|var083 : integer;
   96|var084 : integer;
   97|var085 : integer;
   98|var086 : integer;
   99|var087 : integer;
  100|var088 : integer;
  101|var089 : integer;
  102|
  103|var090 : integer;
  104|var091 : integer;
  105|var092 : integer;
  106|var093 : integer;
  107|var094 : integer;
  108|var095 : integer;
  109|var096 : integer;
  110|var097 : integer;
  111|var098 : integer;
  112|var099 : integer;
  113|
  114|var100 : integer;
  115|var101 : integer;
  116|var102 : integer;
  117|var103 : integer;
  118|var104 : integer;
  119|var105 : integer;
  120|var106 : integer;
  121|var107 : integer;
  122|var108 : integer;
  123|var109 : integer;
  124|
  125|var110 : integer;
  126|var111 : integer;
  127|var112 : integer;
  128|var113 : integer;
  129|var114 : integer;
  130|var115 : integer;
  131|var116 : integer;
  132|var117 : integer;
  133|var118 : integer;
  134|var119 : integer;
  135|
  136|var120 : integer;
  137|var121 : integer;
  138|var122 : integer;
  139|var123 : integer;
  140|var124 : integer;
  141|var125 : integer;
  142|var126 : integer;
  143|var127 : integer;
  144|var128 : integer;
  145|var129 : integer;
  146|
  147|var130 : integer;
  148|var131 : integer;
  149|var132 : integer;
  150|var133 : integer;
  151|var134 : integer;
  152|var135 : integer;
  153|var136 : integer;
  154|var137 : integer;
  155|var138 : integer;
  156|var139 : integer;
  157|
  158|var140 : integer;
  159|var141 : integer;
  160|var142 : integer;
  161|var143 : integer;
  162|var144 : integer;
  163|var145 : integer;
  164|var146 : integer;
  165|var147 : integer;
  166|var148 : integer;
  167|var149 : integer;
  168|
  169|var150 : integer;
  170|var151 : integer;
  171|var152 : integer;
  172|var153 : integer;
  173|var154 : integer;
  174|var155 : integer;
  175|var156 : integer;
  176|var157 : integer;
  177|var158 : integer;
  178|var159 : integer;
  179|
  180|var160 : integer;
  181|var161 : integer;
  182|var162 : integer;
  183|var163 : integer;
  184|var164 : integer;
  185|var165 : integer;
  186|var166 : integer;
  187|var167 : integer;
  188|var168 : integer;
  189|var169 : integer;
  190|
  191|var170 : integer;
  192|var171 : integer;
  193|var172 : integer;
  194|var173 : integer;
  195|var174 : integer;
  196|var175 : integer;
  197|var176 : integer;
  198|var177 : integer;
  199|var178 : integer;
  200|var179 : integer;
  201|
  202|var180 : integer;
  203|var181 : integer;
  204|var182 : integer;
  205|var183 : integer;
  206|var184 : integer;
  207|var185 : integer;
  208|var186 : integer;
  209|var187 : integer;
  210|var188 : integer;
  211|var189 : integer;
  212|
  213|var190 : integer;
  214|var191 : integer;
  215|var192 : integer;
  216|var193 : integer;
  217|var194 : integer;
  218|var195 : integer;
  219|var196 : integer;
  220|var197 : integer;
  221|var198 : integer;
  222|var199 : integer;
  223|
  224|var200 : integer;
  225|var201 : integer;
  226|var202 : integer;
  227|var203 : integer;
  228|var204 : integer;
  229|var205 : integer;
  230|var206 : integer;
  231|var207 : integer;
  232|var208 : integer;
  233|var209 : integer;
  234|
  235|var210 : integer;
  236|var211 : integer;
  237|var212 : integer;
  238|var213 : integer;
  239|var214 : integer;
  240|var215 : integer;
  241|var216 : integer;
  242|var217 : integer;
  243|var218 : integer;
  244|var219 : integer;
  245|
  246|var220 : integer;
  247|var221 : integer;
  248|var222 : integer;
  249|var223 : integer;
  250|var224 : integer;
  251|var225 : integer;
  252|var226 : integer;
  253|var227 : integer;
  254|var228 : integer;
  255|var229 : integer;
  256|
  257|var230 : integer;
  258|var231 : integer;
  259|var232 : integer;
  260|var233 : integer;
  261|var234 : integer;
  262|var235 : integer;
  263|var236 : integer;
  264|var237 : integer;
  265|var238 : integer;
  266|var239 : integer;
  267|
  268|var240 : integer;
  269|var241 : integer;
  270|var242 : integer;
  271|var243 : integer;
  272|var244 : integer;
  273|var245 : integer;
  274|var246 : integer;
  275|var247 : integer;
  276|var248 : integer;
  277|var249 : integer;
  278|
  279|var250 : integer;
  280|var251 : integer;
  281|var252 : integer;
  282|var253 : integer;
  283|var254 : integer;
  284|  begin
  285|end  .

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/029.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage0no029;
    2|		 { comments after "end." are OK }
    3|    const yes = true; no = false;
    4|          small = 0; smalleryet ={} -1;
    5|          big = 1; bigger_yet = 2;
    6|        var   some : integer;
    7|    begin   end.    { this is a comment after "end." }

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/030.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage0no030;
    2|		 { extra whitespace after "end." is OK }
    3|    const yes = true; no = false;
    4|          small = 0; smalleryet ={} -1;
    5|          big = 1; bigger_yet = 2;
    6|        var   some : integer;
    7|    begin   end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/031.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage0no031;
    2|  { smallest syntactically correct program }
    3|    begin
    4|    end.    

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/032.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage0no032; {this is 001.dat with much whitespace eliminated}
    2|const yes=true;no=false;small=0;smalleryet=-1;big=1;biggeryet=2;
    3|      large=biggeryet;maybe=not true;
    4|var   some,many:integer;right,wrong:boolean;
    5|begin
    6|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/033.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program
    2|stage0no033;
    3|{
    4|this
    5|is
    6|001.dat
    7|with
    8|each
    9|token
   10|on
   11|a
   12|separate
   13|line
   14|}
   15|const
   16|yes
   17|=
   18|true
   19|;
   20|no
   21|=
   22|false
   23|;
   24|small
   25|=
   26|0
   27|;
   28|smalleryet
   29|=
   30|-
   31|1
   32|;
   33|big
   34|=
   35|1
   36|;
   37|biggeryet
   38|=
   39|2
   40|;
   41|large
   42|=
   43|biggeryet
   44|;
   45|maybe
   46|=
   47|not
   48|true
   49|;
   50|var
   51|some
   52|,
   53|many
   54|:
   55|integer
   56|;
   57|right
   58|,
   59|wrong
   60|:
   61|boolean
   62|;
   63|begin
   64|end
   65|.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/034.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|
    2|program stage0no034;
    3|  { whitespace can precede the program statement }
    4|  { whitespace can follow end.}
    5|    begin
    6|    end.    

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/035.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|{ comments are OK before the program statement }
    2|program stage0no035;
    3|    begin
    4|    end.    {comments are OK after end.}

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/036.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage0no036_this_name_is_really_long;
    2|    begin
    3|    end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/037.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage0no037_this_name_is_really_long;
    2|    const
    3|      stage0no037_this_name_is_really_long = true;

Error: Line 3: symbol stage0no037_thi is multiply defined

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/038.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT


Error: Line 0: keyword "program" expected

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/039.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program    stage0no039;   {here is a comment}
    2|     const yes=true;no=false;
    3|           small=0;smalleryet=-1;
    4|           big = 1;  biggeryet = 2;  large = biggeryet;
    5|		   maybe = not true;
    6|     var   some,many:integer;
    7|           right, wrong : boolean;
    8|     begin
    9|     end

Error: Line 9: period expected

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/040.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage0no040
    2|      {semicolon expected after program name}
    3|
    4|   var 
Error: Line 4: semicolon expected

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/041.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage0no041;
    2|	var const 
Error: Line 2: non-keyword identifier must follow "var"

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/042.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage0no042;
    2|
    3|	const big = 17; small = -big;
Error: Line 3: integer expected after sign

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/043.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage0no043;
    2|
    3|	const big = -1; small = not big;
Error: Line 3: boolean expected after "not"

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/044.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage0no044;
    2|  var
    3|    a, b, c : integer, 
Error: Line 3: semicolon expected

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/045.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage0no045;
    2|  var
    3|    b, var,
Error: Line 3: non-keyword identifier expected

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/046.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program    stage0no046;   {here is a comment}
    2|     const yes=true;no=false;
    3|           small=0;smalleryet=-1;
    4|           big = 1;  biggeryet = 2;  large = bigger
Error: Line 4: unexpected end of file

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/047.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program    stage0no047;   {here is a comment}
    2|     const yes=true;no=false;
    3|           small=0;smalleryet=-1;
    4|           big = 1;  biggeryet = 2
Error: Line 4: unexpected end of file

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/048.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program    stage0no048;   {here is a comment}
    2|     const yes=true;no=false;
    3|           small=0;smalleryet=-1234;
    4|           big = 1;  biggeryet = +2336;  large = biggeryet;
    5|           maybe = not true;
    6|           compiler = ;

Error: Line 6: token to right of "=" illegal

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/049.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|{Contributed by James Dixon, 19-Oct-2018}
    2|program    stage0no049;   {here is a comment with a double__underscore included}{here is a comment}
    3|     const yes=true;no=false;
    4|           small=0;smaller_yet=-1;
    5|           big = 1;  bigger__yet 
Error: Line 5: illegal character '_'

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/050.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|{contributed by Zachary Deere & Ryan Dennis, 29-Oct-2018}
    2|program    stage0no050;
    3|     const
    4|            a = 1;
    5|            b = a;
    6|            c = stage0no050; 
Error: Line 6: data type of token on the right - hand side must be INTEGER or BOOLEAN

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/051.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program    stage0no051;   {here is a comment}
    2|     const yes=true;no=false;
    3|           small=0;smalleryet=-1234;
    4|           big = 1;  biggeryet = +2336;  large = biggeryet;
    5|           zero = small;
    6|           minus = smalleryet;
    7|           maybe = not true;
    8|           possible = not false;
    9|           on = yes;
   10|           off = no;
   11|           fal_se = maybe;
   12|           tru_e = possible;
   13|     var   some,many:integer;
   14|           right, wrong : boolean;
   15|     begin
   16|     end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/052.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|{contributed by Joel King, 2021-Nov-28}
    2|program    stage0no052; {tests: const non_key_id = not non_key_id;}
    3|  const yes=true;no=false;
    4|    should_be_true = not no;
Error: Line 4: boolean expected after "not"

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/101.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no101;
    2|{demonstrate correct usage of Pascallite features.}
    3|const zero = 0; five = 5;
    4|var a,b : integer;
    5|    c   : integer;
    6|begin   
    7|   read(a);
    8|   read(b,c);
    9|   write(a);
   10|   write(b);
   11|   a := five * (3 + 34);
   12|   b := a +a;
   13|   write(five);
   14|   write(a, b, c, five, zero);
   15|end .

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/102.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no102;
    2|        {demonstrate correct usage of Pascallite features.}
    3|  const  zero = 0; five = 5;
    4|  var    a,b,c: integer; w,z: integer;
    5|  begin
    6|   read( a );
    7|   read( b );
    8|   z := b + -5 mod a;
    9|   write( z );
   10|   c := (b + z) * (a - b);
   11|   write( c );
   12| end .

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/103.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no103;
    2|     {demonstrate correct usage of Pascallite features.}
    3|  const zero = 0; five = 5;
    4|  var a,b,c,z: integer;          d: boolean;
    5|  begin
    6|   read(z);
    7|   d := z > zero;
    8|   write(z);
    9|  end .

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/104.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no104;
    2|        {demonstrate correct usage of Pascallite features.}
    3|  const  five = 5;
    4|  var    a,b,c: integer;
    5|  begin
    6|  read(a);
    7|  a := (2 + a) + five;
    8|  b := a - a ;
    9|  c := b div a;
   10|  write(a,b,c);
   11| end .

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/105.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no105;
    2|        {demonstrate correct usage of Pascallite features.}
    3|  const  zero = 0; five = 5;
    4|  var    a,b,c: integer; w,z: integer;
    5|  begin
    6|  read(a);
    7|  read(b);
    8|  read(c);
    9|  read(z);
   10|  z := b mod a;
   11|  w := c * z;
   12|  a := -z;
   13|  b := +c;
   14|  write(z);
   15|  write(w);
   16|  write(a);
   17|  write(b);
   18| end .

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/106.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program   stage1no106;
    2|          {demonstrates correct usage of Pascallite features}
    3|  var   a,b,c,
    4|        d :integer;
    5|  begin
    6|    read(b);
    7|    read(c);
    8|    a := 3;
    9|    d := a+b * c;
   10|    b := a*b+c ;
   11|    write(d);
   12|    write(b);
   13|  end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/107.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program   stage1no107;
    2|          {demonstrates correct usage of Pascallite features}
    3|  const zero = 0; five = 5; right=false; t0=45;wrong={x}true;
    4|  var   a,b,c,
    5|        d :integer;
    6|  begin
    7|    read(a);
    8|    read(b);
    9|    read(c);
   10|    a := a+b+c;
   11|    d := a*b*c; d := a+b;
   12|    write(a);
   13|    write(d);
   14|  end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/108.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no108;
    2|  const w=3;x=true;
    3|  var   a,b,c,d,e:integer;
    4|  begin
    5|    read(a);
    6|    d := a+x; 
Error: Line 6: binary '+' requires integer operands

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/109.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no109;
    2|  var  a,b:integer;
    3|       g:boolean;
    4|  begin
    5|    a:= true; 
Error: Line 5: incompatible types for operator ':='

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/110.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no110;
    2|        {demonstrate incorrect usage of Pascal assignment statements.}
    3|  const  zero = 0;  five = 5;
    4|  var    a,b,c:  integer;        w,z: integer;
    5|  begin
    6|    a := five * m; 
Error: Line 6: reference to undefined symbol m

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/111.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no111;
    2|        {demonstrate incorrect usage of Pascal assignment statements.}
    3|  const  zero = 0; five = 5;
    4|  var    a,b,c:  integer;
    5|         w,z: integer;
    6|         d,e: boolean;
    7|  begin
    8|    zero := five * a; 
Error: Line 8: symbol on left-hand side of assignment must have a storage mode of VARIABLE

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/112.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no112;
    2|        {demonstrate incorrect usage of Pascal assignment statements.}
    3|  const  zero = 0;  five = 5;
    4|  var    a,b,c: integer;
    5|         w,z: integer;
    6|         d,e: boolean;
    7|  begin
    8|    d := five * a; 
Error: Line 8: incompatible types for operator ':='

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/113.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no113;
    2|        {demonstrate incorrect usage of Pascal assignment statements.}
    3|  const  zero = 0;
    4|         five = 5;
    5|  var    a,b,c: integer;
    6|         w,z: integer;
    7|         d,e: boolean;
    8|  begin
    9|    c := five * a
   10|    b:
Error: Line 10: invalid expression

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/114.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no114;
    2|        {demonstrate incorrect usage of Pascal assignment statements.}
    3|  const  zero = 0;
    4|         five = 5;
    5|  var    a,b,c,z,  d,e: integer;
    6|  begin
    7|    d := five * a ;
    8|    z:=b + + +5
Error: Line 8: expected '(', integer, or non-keyword id; found +

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/115.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no115;
    2|        {demonstrate correct usage of Pascal assignment statements.}
    3|  const  yes = true;
    4|         no = false;
    5|  var    a,b,c: boolean;
    6|         w,z: boolean;
    7|         d,e: boolean;
    8|  begin
    9|    d := yes and no;
   10|    a := (((yes)));
   11|    b := yes or no;
   12|    c := not b;
   13|    write(d);
   14|    write(a);
   15|    write(b);
   16|    write(c);
   17|  end .

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/116.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no116;
    2|        {demonstrate correct usage of Pascal assignment statements.}
    3|  const  yes = true;
    4|         no = false;
    5|  var    a,b,c: boolean;
    6|         w,z: boolean;
    7|         d,e: boolean;
    8|  begin
    9|    b:= true;
   10|    d:= (yes and true) and (no or false);
   11|    w:= yes and not b;
   12|    write(d);
   13|    write(w);
   14|  end .

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/117.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no117;
    2|        {demonstrate correct usage of Pascal assignment statements.}
    3|  const  a = true;
    4|         b = false;
    5|  var    c,d,e: boolean;
    6|         w,z,y,x: integer;
    7|  begin
    8|    e:= (w<z) and (a or b);
    9|    d := (z >=3) or (w < 4);
   10|  end .

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/118.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no118;
    2|        {demonstrate incorrect usage of Pascal assignment statements.}
    3|  const  a = true;
    4|         b = false;
    5|  var    c,d,e: boolean;
    6|         w,z,y,x: integer;
    7|  begin
    8|    c := (w=z) and (a <>b);
    9|    e := w > z and y > 
Error: Line 9: binary 'and' requires boolean operands

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/119.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no119;
    2|        {correct}
    3|  const  a = true;
    4|         b = a;
    5|  var    c,d,e: boolean;
    6|         f,g,h: integer;
    7|
    8|  begin
    9|    read(f);
   10|    read(g);
   11|    read(h);
   12|    c := f <= g;
   13|    d := a = b;
   14|    e := f = h;
   15|    write(c);
   16|    write(d);
   17|    write(e);
   18|  end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/120.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no120;
    2|  const  a = true;
    3|         b = false;
    4|  var    c,d,e: boolean;
    5|
    6|  begin
    7|    read(d,e);
Error: Line 7: can't read variables of this type

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/121.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:20 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no121;
    2|  { requires 0 temporaries }
    3|var    sum,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z : integer;
    4|begin
    5|  read(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z);
    6|  sum := a+b+c+d+e+f+g+h+i+j+k+l+m+n+o+p+q+r+s+t+u+v+w+x+y+z;
    7|  write(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,sum);
    8|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/122.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no122;
    2|  { requires 12 temporaries }
    3|var    sum,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z : integer;
    4|begin
    5|  read(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z);
    6|  sum := (a+b)+
    7|         ((c+d)+
    8|          ((e+f)+
    9|           ((g+h)+
   10|            ((i+j)+
   11|             ((k+l)+
   12|              ((m+n)+
   13|               ((o+p)+
   14|                ((q+r)+
   15|                 ((s+t)+
   16|                  ((u+v)+
   17|                   ((w+x)+
   18|                    (y+z)
   19|                   )
   20|                  )
   21|                 )
   22|                )
   23|               )
   24|              )
   25|             )
   26|            )
   27|           )
   28|          )
   29|         );
   30|  write(sum);
   31|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/123.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no123;
    2|  { requires 13 temporaries }
    3|var    sum,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z : integer;
    4|begin
    5|  read(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z);
    6|  sum := (a-b)-
    7|         ((c-d)-
    8|          ((e-f)-
    9|           ((g-h)-
   10|            ((i-j)-
   11|             ((k-l)-
   12|              ((m-n)-
   13|               ((o-p)-
   14|                ((q-r)-
   15|                 ((s-t)-
   16|                  ((u-v)-
   17|                   ((w-x)-
   18|                    (y-z)
   19|                   )
   20|                  )
   21|                 )
   22|                )
   23|               )
   24|              )
   25|             )
   26|            )
   27|           )
   28|          )
   29|         );
   30|  write(sum);
   31|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/124.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no124;
    2|  { requires 1 temporary }
    3|var    sum,a,b,c,d,e,f,g,h,i,j,k,l,m,n : integer;
    4|begin
    5|  read(a,b,c,d,e,f,g,h,i,j,k,l,m,n);
    6|  sum := (a-(b-(c-(d-(e-(f-(g-(h-(i-(j-(k-(l-(m-n)))))))))))));
    7|  write(sum);
    8|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/125.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no125;
    2|begin
    3|  read(a);
Error: Line 3: reference to undefined symbol a

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/126.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no126;
    2|begin
    3|  write(a);
Error: Line 3: reference to undefined symbol a

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/127.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no127;
    2|  const a = 5;
    3|begin
    4|  read(a);
Error: Line 4: attempting to read to a read-only location

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/128.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no128;
    2|begin
    3|  read(5)
Error: Line 3: non-keyword identifier expected

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/129.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no129;
    2|begin
    3|  write(5)
Error: Line 3: non-keyword identifier expected

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/130.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no130;
    2|const
    3|  one = 1;
    4|  two = 2;
    5|begin
    6|  write(one + 
Error: Line 6: ',' or ')' expected after non-keyword identifier

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/131.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no131;
    2|const
    3|  a = true;
    4|  b = a;
    5|  c = not a;
Error: Line 5: boolean expected after "not"

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/132.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no132;
    2|var
    3|  a, b : integer;
    4|  c    : boolean;
    5|begin
    6|  read(a,b);
    7|  c := a <> b;
    8|  write(a, b, c);
    9|  c := a = b;
   10|  write(a, b, c);
   11|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/133.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no133;
    2|var
    3|  a, b, r : integer;
    4|begin
    5|  read(a, b);
    6|  r := -(b div (2 * a));
    7|  write(a, b, r);
    8|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/134.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no134;
    2|var
    3|  a, b, r : integer;
    4|begin
    5|  read(a, b);
    6|  r := +(a + b);
    7|  write(a, b, r);
    8|  r := +a + +b;
    9|  write(a, b, r);
   10|  r := +(+a + +5);
   11|  write(a, b, r);
   12|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/135.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no135;
    2|var
    3|  a, b : boolean;
    4|begin
    5|  a := true;
    6|  b := not a;
    7|  write(a, b);
    8|  b := not true;
    9|  write(b);
   10|  b := not false;
   11|  write(b);
   12|  b := not (a = b);
   13|  write(a,b);
   14|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/136.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no136;
    2|var
    3|  a, b : integer;
    4|begin
    5|  read(a, b);
    6|  write(a, b);
    7|  a := a + b;
    8|  b := a - b;
    9|  a := a - b;
   10|  write(a, b);
   11|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/137.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no137;
    2|var
    3|  a, b, c, d : integer;
    4|begin
    5|  read(a, b, c);
    6|  write(a, b, c);
    7|  d := a + (b - c);
    8|  write(d);
    9|  d := b * b - 4 * a * c;
   10|  write(d);
   11|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/138.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no138;
    2|var
    3|  a, b, c, d : integer;
    4|  e          : boolean;
    5|begin
    6|  read(a, b);
    7|  c := a - a div b * b;
    8|  d := a mod b;
    9|  e := c = d;
   10|  write(a, b, c, d, e);
   11|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/139.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no139;
    2|var
    3|  a, b, c, d, e, f, g : integer;
    4|begin
    5|  read(a, b, c, d, e, f);
    6|  g := a mod b * c div d - e + f;
    7|  write(a, b, c, d, e, f, g);
    8|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/140.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no140;
    2|var
    3|  a, b, c, d, e, f, g : integer;
    4|begin
    5|  read(a, b, c, d, e, f);
    6|  g := a mod (b * (c div (d - (e + f))));
    7|  write(a, b, c, d, e, f, g);
    8|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/141.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no141;
    2|var
    3|  aaaaaaaaaaaaaaab : integer;
    4|begin
    5|  read(aaaaaaaaaaaaaaa);
    6|  read(aaaaaaaaaaaaaaab);
    7|  read(aaaaaaaaaaaaaaac);
    8|  aaaaaaaaaaaaaaa := aaaaaaaaaaaaaaab + aaaaaaaaaaaaaaac;
    9|  write(aaaaaaaaaaaaaaa);
   10|  write(aaaaaaaaaaaaaaab);
   11|  write(aaaaaaaaaaaaaaac);
   12|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/142.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no142;
    2|var
    3|  a, b, c, d, e, f, g : integer;
    4|begin
    5|  read(a, b, c, d, e, f);
    6|  g := a mod (b * (c div (d - (e + f)));

Error: Line 6: ) expected; found ;

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/143.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no143;
    2|var
    3|  a, b, c, d, e, f, g : integer;
    4|begin
    5|  read(a, b, c, d, e, f);
    6|  g := ) 
Error: Line 6: one of "*", "and", "div", "mod", ")", "+", "-", ";", "<", "<=", "<>", "=", ">", ">=", or "or" expected

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/144.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|{contributed by David Wolfe}
    2|program dwwtest1 {stage1no144;};
    3|var
    4|  a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z : integer;
    5|  sum1, sum2, sum3, sum4, sum5 : integer;
    6|  aa, bb, cc, dd : boolean;
    7|begin
    8|  sum1 := (a+b+((c+d)+((e+f)+((g+h)+((i+j)+((k+l)+((m+n)+((o+p)+((q+r)+((s+t)+((u+v)+((w+x)+(y+z)))))))))))));
    9|  sum2 := a+b*c+d*e+f*g+h*i+j*k+l*m+n*o+p*q+r*s+t*u+v*w+x*y+z;
   10|  sum3 := a+b+c+d+e+f+g+h+i+j+k+l+m+n+o+p+q+r+s+t+u+v+w+x+y+z;
   11|  sum4 := -(-a++b)*+(+c+-d)*-(+e-+f)*+(-g--h);
   12|  sum5 := -(-(-(-(-(-a)))));
   13|  aa   := (a=b) or (c<d) or (e<=f) or (g>h) or (i>=j) or (k<>l);
   14|  bb   := (aa=bb) and (cc<>dd);
   15|  cc   := not (not aa = not bb) and not (c<d);
   16|  dd   := not (not (not (not aa)));
   17|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/145.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no145;
    2|         {fill the symbol table with 256 entries; should be ok}
    3|  var
    4|var000,var001,var002,var003,var004,var005,var006,var007,var008,var009,
    5|var010,var011,var012,var013,var014,var015,var016,var017,var018,var019,
    6|var020,var021,var022,var023,var024,var025,var026,var027,var028,var029,
    7|var030,var031,var032,var033,var034,var035,var036,var037,var038,var039,
    8|var040,var041,var042,var043,var044,var045,var046,var047,var048,var049,
    9|var050,var051,var052,var053,var054,var055,var056,var057,var058,var059,
   10|var060,var061,var062,var063,var064,var065,var066,var067,var068,var069,
   11|var070,var071,var072,var073,var074,var075,var076,var077,var078,var079,
   12|var080,var081,var082,var083,var084,var085,var086,var087,var088,var089,
   13|var090,var091,var092,var093,var094,var095,var096,var097,var098,var099,
   14|var100,var101,var102,var103,var104,var105,var106,var107,var108,var109,
   15|var110,var111,var112,var113,var114,var115,var116,var117,var118,var119,
   16|var120,var121,var122,var123,var124,var125,var126,var127,var128,var129,
   17|var130,var131,var132,var133,var134,var135,var136,var137,var138,var139,
   18|var140,var141,var142,var143,var144,var145,var146,var147,var148,var149,
   19|var150,var151,var152,var153,var154,var155,var156,var157,var158,var159,
   20|var160,var161,var162,var163,var164,var165,var166,var167,var168,var169,
   21|var170,var171,var172,var173,var174,var175,var176,var177,var178,var179,
   22|var180,var181,var182,var183,var184,var185,var186,var187,var188,var189,
   23|var190,var191,var192,var193,var194,var195,var196,var197,var198,var199,
   24|var200,var201,var202,var203,var204,var205,var206,var207,var208,var209,
   25|var210,var211,var212,var213,var214,var215,var216,var217,var218,var219,
   26|var220,var221,var222,var223,var224,var225,var226,var227,var228,var229,
   27|var230,var231,var232,var233,var234,var235,var236,var237,var238,var239,
   28|var240,var241,var242,var243,var244,var245,var246,var247,var248,var249,
   29|var250,var251,var252,var253,var254
   30|: integer;
   31|  begin
   32|end  .

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/146.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no146;
    2|const
    3|  five = 5;
    4|var
    5|  a, b, c : integer;
    6|begin
    7|  a := five * (3 + 34);
    8|  b := a + -5 mod a;
    9|  c := (a + b) * (b - a);
   10|  write(a, b, c);
   11|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/147.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no147;
    2|const
    3|  five = 5;
    4|var
    5|  a, b, c : integer;
    6|begin
    7|  a := five * (3 + 34);
    8|  b := a + -5 mod a;
    9|  c := (a + b) - (b - a);
   10|  write(a, b, c);
   11|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/148.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no148;
    2|const
    3|  zero = 0;
    4|var
    5|  a, b, c : integer;
    6|  d, e, f : boolean;
    7|begin
    8|  read(a, b, c);
    9|  d := a = zero;
   10|  e := b < c;
   11|  f := a > b;
   12|  write(a, b, c, d, e, f);
   13|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/149.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no149;
    2|var
    3|  a, b, c, d, e, f : integer;
    4|begin
    5|  read(a, b, c, d, e, f);
    6|  a := (a + b) + ((c + d) + (e + f));
    7|  write(a);
    8|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/150.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no150;
    2|const
    3|  a = true;
    4|  b = false;
    5|  c = not false;
    6|  d = not true;
    7|  e = 5;
    8|  f = +5;
    9|  g = -5;
   10|  h = g;
   11|var
   12|  i : integer;
   13|begin
   14|  var 
Error: Line 14: keyword "end" expected

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/151.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no151;
    2|  var
    3|    a, b, c: boolean;
    4|    d : boolean;
    5|    e : integer;
    6|begin
    7|  b := true;
    8|  c := false;
    9|  a := true;
   10|
   11|  d := b = c = a;
   12|  e := +(-(+5));
   13|  write(e);
   14|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/152.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no152;
    2|  { requires 102 temporaries with 101 allocated }
    3|  var    sum,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v : integer;
    4| begin
    5|  read(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v);
    6|  sum := (a+b)+
    7|         ((c+d)+((e+f)+((g+h)+((i+j)+((k+l)+((m+n)+((o+p)+((q+r)+((s+t)+((u+v)+
    8|         ((c+d)+((e+f)+((g+h)+((i+j)+((k+l)+((m+n)+((o+p)+((q+r)+((s+t)+((u+v)+
    9|         ((c+d)+((e+f)+((g+h)+((i+j)+((k+l)+((m+n)+((o+p)+((q+r)+((s+t)+((u+v)+
   10|         ((c+d)+((e+f)+((g+h)+((i+j)+((k+l)+((m+n)+((o+p)+((q+r)+((s+t)+((u+v)+
   11|         ((c+d)+((e+f)+((g+h)+((i+j)+((k+l)+((m+n)+((o+p)+((q+r)+((s+t)+((u+v)+
   12|         ((c+d)+((e+f)+((g+h)+((i+j)+((k+l)+((m+n)+((o+p)+((q+r)+((s+t)+((u+v)+
   13|         ((c+d)+((e+f)+((g+h)+((i+j)+((k+l)+((m+n)+((o+p)+((q+r)+((s+t)+((u+v)+
   14|         ((c+d)+((e+f)+((g+h)+((i+j)+((k+l)+((m+n)+((o+p)+((q+r)+((s+t)+((u+v)+
   15|         ((c+d)+((e+f)+((g+h)+((i+j)+((k+l)+((m+n)+((o+p)+((q+r)+((s+t)+((u+v)+
   16|         ((c+d)+((e+f)+((g+h)+((i+j)+((k+l)+((m+n)+((o+p)+((q+r)+((s+t)+((u+v)+
   17|         (a+b)
   18|         ))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
   19|         ))))))))))))))))))))))))))))));
   20|
   21|  write(sum);
   22|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/153.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no153;
    2|const
    3|  a = true;
    4|  b = false;
    5|  c = not false;
    6|  d = not true;
    7|  e = 5;
    8|  f = +5;
    9|  g = -5;
   10|  h = g;
   11|var
   12|  i, j: boolean;
   13|begin
   14|  write(a,b,c,d);
   15|  read(i);
Error: Line 15: can't read variables of this type

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/154.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no154;
    2|const
    3|  a = true;
    4|  b = false;
    5|  c = not false;
    6|  d = not true;
    7|  e = 5;
    8|  f = +5;
    9|  g = -5;
   10|  h = g;
   11|var
   12|  i : integer;
   13|begin
   14|  i = 
Error: Line 14: ':=' expected; found =

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/155.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no155;
    2|const
    3|  a = true;
    4|  b = false;
    5|  c = not false;
    6|  d = not true;
    7|  e = 5;
    8|  f = +5;
    9|  g = -5;
   10|  h = g;
   11|var
   12|  i : integer;
   13|begin
   14|  read i;
Error: Line 14: "(" expected

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/156.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no156;
    2|const
    3|  a = true;
    4|  b = false;
    5|  c = not false;
    6|  d = not true;
    7|  e = 5;
    8|  f = +5;
    9|  g = -5;
   10|  h = g;
   11|var
   12|  i : integer;
   13|begin
   14|  read(i; 
Error: Line 14: ',' or ')' expected after non-keyword identifier

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/157.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no157;
    2|const
    3|  a = true;
    4|  b = false;
    5|  c = not false;
    6|  d = not true;
    7|  e = 5;
    8|  f = +5;
    9|  g = -5;
   10|  h = g;
   11|var
   12|  i, j : integer;
   13|begin
   14|  read(i) 
   15|  ; read(j) {';' expected}
   16|end.
Error: Line 16: ';' expected

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/158.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no158;
    2|const
    3|  a = true;
    4|  b = false;
    5|  c = not false;
    6|  d = not true;
    7|  e = 5;
    8|  f = +5;
    9|  g = -5;
   10|  h = g;
   11|var
   12|  i, j : integer;
   13|begin
   14|  read(i) 
   15|  ; read(j);
   16|  write i,
Error: Line 16: "(" expected

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/159.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no159;
    2|const
    3|  a = true;
    4|  b = false;
    5|  c = not false;
    6|  d = not true;
    7|  e = 5;
    8|  f = +5;
    9|  g = -5;
   10|  h = g;
   11|var
   12|  i, j : integer;
   13|begin
   14|  read(i) 
   15|  ; read(j);
   16|  write(i, j) {';' expected}
   17|end.
Error: Line 17: ';' expected

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/160.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no160;
    2|const
    3|  a = true;
    4|  b = false;
    5|  c = not false;
    6|  d = not true;
    7|  e = 5;
    8|  f = +5;
    9|  g = -5;
   10|  h = g;
   11|var
   12|  i, j : integer;
   13|  k : boolean;
   14|begin
   15|  read(i) 
   16|  ; read(j);
   17|  write(i, j);
   18|  k := not (a = c; 
Error: Line 18: ) expected; found ;

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/161.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no161;
    2|const
    3|  a = true;
    4|  b = false;
    5|  c = not false;
    6|  d = not true;
    7|  e = 5;
    8|  f = +5;
    9|  g = -5;
   10|  h = g;
   11|var
   12|  i, j : integer;
   13|  k : boolean;
   14|begin
   15|  read(i) 
   16|  ; read(j);
   17|  write(i, j);
   18|  k := not (a = c); {legal}
   19|  k := not true; {legal}
   20|  k := not c; {legal}
   21|  k := not and; 
Error: Line 21: "not", "true", "false", "(", "+", "-", integer, or non - keyword identifier expected

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/162.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no162;
    2|const
    3|  a = true;
    4|  b = false;
    5|  c = not false;
    6|  d = not true;
    7|  e = 5;
    8|  f = +5;
    9|  g = -5;
   10|  h = g;
   11|var
   12|  i, j : integer;
   13|  k : boolean;
   14|begin
   15|  read(i) 
   16|  ; read(j);
   17|  write(i, j);
   18|  k := not (a = c); {legal}
   19|  k := not true; {legal}
   20|  k := not c; {legal}
   21|  i := +(e + f; 
Error: Line 21: expected ')'; found ;

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/163.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no163;
    2|const
    3|  a = true;
    4|  b = false;
    5|  c = not false;
    6|  d = not true;
    7|  e = 5;
    8|  f = +5;
    9|  g = -5;
   10|  h = g;
   11|var
   12|  i, j : integer;
   13|  k : boolean;
   14|begin
   15|  read(i) 
   16|  ; read(j);
   17|  write(i, j);
   18|  k := not (a = c); {legal}
   19|  k := not true; {legal}
   20|  k := not c; {legal}
   21|  i := +(e + f); {legal}
   22|  i := +4301; {legal}
   23|  i := +g; {legal}
   24|  i := +const;
Error: Line 24: expected '(', integer, or non-keyword id; found const

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/164.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no164;
    2|const
    3|  a = true;
    4|  b = false;
    5|  c = not false;
    6|  d = not true;
    7|  e = 5;
    8|  f = +5;
    9|  g = -5;
   10|  h = g;
   11|var
   12|  i, j : integer;
   13|  k : boolean;
   14|begin
   15|  read(i) 
   16|  ; read(j);
   17|  write(i, j);
   18|  k := not (a = c); {legal}
   19|  k := not true; {legal}
   20|  k := not c; {legal}
   21|  i := +(e + f); {legal}
   22|  i := +4301; {legal}
   23|  i := +g; {legal}
   24|  i := e + + (+f); {legal}
   25|  i := -(f - g; 
Error: Line 25: expected ')'; found ;

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/165.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no165;
    2|const
    3|  a = true;
    4|  b = false;
    5|  c = not false;
    6|  d = not true;
    7|  e = 5;
    8|  f = +5;
    9|  g = -5;
   10|  h = g;
   11|var
   12|  i, j : integer;
   13|  k : boolean;
   14|begin
   15|  read(i) 
   16|  ; read(j);
   17|  write(i, j);
   18|  k := not (a = c); {legal}
   19|  k := not true; {legal}
   20|  k := not c; {legal}
   21|  i := +(e + f); {legal}
   22|  i := +4301; {legal}
   23|  i := +g; {legal}
   24|  i := -(f - g); {legal}
   25|  i := -4301; {legal}
   26|  i := -g; {legal}
   27|  i := -program;
Error: Line 27: invalid expression

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/166.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no166;
    2|const w=3;x=true;
    3|var   a,b,c,d,e:integer;
    4|begin
    5|  read(a);
    6|  d := a-x; 
Error: Line 6: binary '-' requires integer operands

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/167.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no167;
    2|const w=3;x=true;
    3|var   a,b,c,d,e:integer;
    4|begin
    5|  read(a);
    6|  d := a*x; 
Error: Line 6: binary '*' requires integer operands

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/168.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no168;
    2|const w=3;x=true;
    3|var   a,b,c,d,e:integer;
    4|begin
    5|  read(a);
    6|  d := a div x; 
Error: Line 6: binary 'div' requires integer operands

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/169.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no169;
    2|const w=3;x=true;
    3|var   a,b,c,d,e:integer;
    4|begin
    5|  read(a);
    6|  d := a mod x; 
Error: Line 6: binary 'mod' requires integer operands

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/170.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no170;
    2|const w=3;x=true;
    3|var   a,b,c,d,e:integer;
    4|begin
    5|  read(a);
    6|  d := -5;
    7|  d := -d;
    8|  d := -(-(-d));
    9|  d := -x;
Error: Line 9: binary '-' requires integer operands

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/171.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no171;
    2|const w=3;x=true;
    3|var   a,b,c:integer;
    4|      d,e:boolean;
    5|begin
    6|  d := not x;
    7|  d := not true;
    8|  d := not false;
    9|  d := not (not (not x));
   10|  d := not a;
Error: Line 10: binary 'not' requires boolean operands

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/172.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no172;
    2|const w=3;x=true;
    3|var   d:boolean;
    4|begin
    5|  d := x or x;
    6|  d := x or not false;
    7|  d := not true or x;
    8|  d := false or false;
    9|  d := false or true;
   10|  d := true or false;
   11|  d := true or true;
   12|  d := not false or not false;
   13|  d := not false or not true;
   14|  d := not true or not false;
   15|  d := not true or not true;
   16|  d := not w;
Error: Line 16: binary 'not' requires boolean operands

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/173.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no173;
    2|const w=3;x=true;
    3|var   d:boolean;
    4|      a,b:integer;
    5|begin
    6|  d := x = x;
    7|  d := x = not x;
    8|  d := not x = x;
    9|  d := not x = not x;
   10|
   11|  d := x = not false;
   12|  d := not true = x;
   13|  d := false = false;
   14|  d := false = true;
   15|  d := true = false;
   16|  d := true = true;
   17|  d := not false = not false;
   18|  d := not false = not true;
   19|  d := not true = not false;
   20|  d := not true = not true;
   21|
   22|  read(a,b);
   23|
   24|  d := -a = -b;
   25|  d := -a = b;
   26|  d := -a = +b;
   27|  d := a = -b;
   28|  d := a = b;
   29|  d := a = +b;
   30|  d := +a = -b;
   31|  d := +a = b;
   32|  d := +a = +b;
   33|
   34|  d := -4301 = -4301;
   35|  d := -4301 = 4301;
   36|  d := -4301 = +4301;
   37|  d := 4301 = -4301;
   38|  d := 4301 = 4301;
   39|  d := 4301 = +4301;
   40|  d := +4301 = -4301;
   41|  d := +4301 = 4301;
   42|  d := +4301 = +4301;
   43|
   44|  d := w = x; 
Error: Line 44: incompatible types for operator '='

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/174.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no174;
    2|const w=3;x=true;
    3|var   d:boolean;
    4|      a,b:integer;
    5|begin
    6|  d := x <> x;
    7|  d := x <> not x;
    8|  d := not x <> x;
    9|  d := not x <> not x;
   10|
   11|  d := x <> not false;
   12|  d := not true <> x;
   13|  d := false <> false;
   14|  d := false <> true;
   15|  d := true <> false;
   16|  d := true <> true;
   17|  d := not false <> not false;
   18|  d := not false <> not true;
   19|  d := not true <> not false;
   20|  d := not true <> not true;
   21|
   22|  read(a,b);
   23|
   24|  d := -a <> -b;
   25|  d := -a <> b;
   26|  d := -a <> +b;
   27|  d := a <> -b;
   28|  d := a <> b;
   29|  d := a <> +b;
   30|  d := +a <> -b;
   31|  d := +a <> b;
   32|  d := +a <> +b;
   33|
   34|  d := -4301 <> -4301;
   35|  d := -4301 <> 4301;
   36|  d := -4301 <> +4301;
   37|  d := 4301 <> -4301;
   38|  d := 4301 <> 4301;
   39|  d := 4301 <> +4301;
   40|  d := +4301 <> -4301;
   41|  d := +4301 <> 4301;
   42|  d := +4301 <> +4301;
   43|
   44|  d := w <> x; 
Error: Line 44: incompatible types for operator '<>'

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/175.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no175;
    2|const w=3;x=true;
    3|var   d:boolean;
    4|      a,b:integer;
    5|begin
    6|  read(a,b);
    7|
    8|  d := -a < -b;
    9|  d := -a < b;
   10|  d := -a < +b;
   11|  d := a < -b;
   12|  d := a < b;
   13|  d := a < +b;
   14|  d := +a < -b;
   15|  d := +a < b;
   16|  d := +a < +b;
   17|
   18|  d := -4301 < -4301;
   19|  d := -4301 < 4301;
   20|  d := -4301 < +4301;
   21|  d := 4301 < -4301;
   22|  d := 4301 < 4301;
   23|  d := 4301 < +4301;
   24|  d := +4301 < -4301;
   25|  d := +4301 < 4301;
   26|  d := +4301 < +4301;
   27|
   28|  d := true < w; 
Error: Line 28: incompatible types for operator '<'

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/176.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no176;
    2|const w=3;x=true;
    3|var   d:boolean;
    4|      a,b:integer;
    5|begin
    6|  read(a,b);
    7|
    8|  d := -a <= -b;
    9|  d := -a <= b;
   10|  d := -a <= +b;
   11|  d := a <= -b;
   12|  d := a <= b;
   13|  d := a <= +b;
   14|  d := +a <= -b;
   15|  d := +a <= b;
   16|  d := +a <= +b;
   17|
   18|  d := -4301 <= -4301;
   19|  d := -4301 <= 4301;
   20|  d := -4301 <= +4301;
   21|  d := 4301 <= -4301;
   22|  d := 4301 <= 4301;
   23|  d := 4301 <= +4301;
   24|  d := +4301 <= -4301;
   25|  d := +4301 <= 4301;
   26|  d := +4301 <= +4301;
   27|
   28|  d := true <= w; 
Error: Line 28: incompatible types for operator '<='

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/177.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no177;
    2|const w=3;x=true;
    3|var   d:boolean;
    4|      a,b:integer;
    5|begin
    6|  read(a,b);
    7|
    8|  d := -a > -b;
    9|  d := -a > b;
   10|  d := -a > +b;
   11|  d := a > -b;
   12|  d := a > b;
   13|  d := a > +b;
   14|  d := +a > -b;
   15|  d := +a > b;
   16|  d := +a > +b;
   17|
   18|  d := -4301 > -4301;
   19|  d := -4301 > 4301;
   20|  d := -4301 > +4301;
   21|  d := 4301 > -4301;
   22|  d := 4301 > 4301;
   23|  d := 4301 > +4301;
   24|  d := +4301 > -4301;
   25|  d := +4301 > 4301;
   26|  d := +4301 > +4301;
   27|
   28|  d := true > w; 
Error: Line 28: incompatible types for operator '>'

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/178.my.lst
------------------------------
STAGE1:  Jeff Caldwell, Kangmin Kim       Sun Nov 27 09:52:21 2022

LINE NO.               SOURCE STATEMENT

    1|program stage1no178;
    2|const w=3;x=true;
    3|var   d:boolean;
    4|      a,b:integer;
    5|begin
    6|  read(a,b);
    7|
    8|  d := -a >= -b;
    9|  d := -a >= b;
   10|  d := -a >= +b;
   11|  d := a >= -b;
   12|  d := a >= b;
   13|  d := a >= +b;
   14|  d := +a >= -b;
   15|  d := +a >= b;
   16|  d := +a >= +b;
   17|
   18|  d := -4301 >= -4301;
   19|  d := -4301 >= 4301;
   20|  d := -4301 >= +4301;
   21|  d := 4301 >= -4301;
   22|  d := 4301 >= 4301;
   23|  d := 4301 >= +4301;
   24|  d := +4301 >= -4301;
   25|  d := +4301 >= 4301;
   26|  d := +4301 >= +4301;
   27|
   28|  d := true >= w; 
Error: Line 28: incompatible types for operator '>='

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/001.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no001

_start:                                         
        Exit    {0}
                            
SECTION .data                                   
I2      dd      1                       ; big   
I3      dd      2                       ; biggeryet
I4      dd      2                       ; large 
B2      dd      0                       ; maybe 
B1      dd      0                       ; no    
I0      dd      0                       ; small 
I1      dd      -1                      ; smalleryet
B0      dd      -1                      ; yes   

SECTION .bss                                    
I6      resd    1                       ; many  
B3      resd    1                       ; right 
I5      resd    1                       ; some  
B4      resd    1                       ; wrong 

./output/002.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no002

_start:                                         

./output/003.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no003

_start:                                         

./output/004.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no004

_start:                                         

./output/005.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no005

_start:                                         

./output/006.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no006

_start:                                         

./output/007.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no007

_start:                                         

./output/008.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no008

_start:                                         

./output/009.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no009

_start:                                         

./output/010.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no010

_start:                                         

./output/011.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no011

_start:                                         

./output/012.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no012

_start:                                         

./output/013.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no013

_start:                                         

./output/014.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no014

_start:                                         

./output/015.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no015

_start:                                         
        Exit    {0}
                            
SECTION .data                                   
I2      dd      1                       ; big   
I3      dd      2                       ; biggeryet
B1      dd      0                       ; no    
I4      dd      1                       ; same  
I0      dd      0                       ; small 
I1      dd      -1                      ; smalleryet
B0      dd      -1                      ; yes   

SECTION .bss                                    
B2      resd    1                       ; right 
I5      resd    1                       ; some  

./output/016.my.asm
------------------------------

./output/017.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no017

_start:                                         

./output/018.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no018

_start:                                         
        Exit    {0}
                            
SECTION .data                                   
I1      dd      5                       ; five  
I0      dd      0                       ; zero  

SECTION .bss                                    
I2      resd    1                       ; aaaaaaaaaaaaaaa
I3      resd    1                       ; bbbbbbbbbbbbbbb
I4      resd    1                       ; ccccccccccccccc
B0      resd    1                       ; d     
I5      resd    1                       ; ddddddddddddddd
I6      resd    1                       ; eeeeeeeeeeeeeee
I7      resd    1                       ; fffffffffffffff
I8      resd    1                       ; ggggggggggggggg
I9      resd    1                       ; hhhhhhhhhhhhhhh
I10     resd    1                       ; iiiiiiiiiiiiiii
I11     resd    1                       ; jjjjjjjjjjjjjjj
I12     resd    1                       ; kkkkkkkkkkkkkkk
I13     resd    1                       ; lllllllllllllll
I14     resd    1                       ; mmmmmmmmmmmmmmm
I15     resd    1                       ; nnnnnnnnnnnnnnn
I16     resd    1                       ; ooooooooooooooo
I17     resd    1                       ; ppppppppppppppp
I18     resd    1                       ; qqqqqqqqqqqqqqq
I19     resd    1                       ; rrrrrrrrrrrrrrr
I20     resd    1                       ; sssssssssssssss
I21     resd    1                       ; ttttttttttttttt
I22     resd    1                       ; uuuuuuuuuuuuuuu
I23     resd    1                       ; vvvvvvvvvvvvvvv
I24     resd    1                       ; wwwwwwwwwwwwwww
I25     resd    1                       ; xxxxxxxxxxxxxxx
I26     resd    1                       ; yyyyyyyyyyyyyyy
I27     resd    1                       ; zzzzzzzzzzzzzzz

./output/019.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no019

_start:                                         

./output/020.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no020

_start:                                         

./output/021.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no021

_start:                                         

./output/022.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no022

_start:                                         

./output/023.my.asm
------------------------------

./output/024.my.asm
------------------------------

./output/025.my.asm
------------------------------

./output/026.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no026

_start:                                         
        Exit    {0}
                            
SECTION .data                                   

SECTION .bss                                    
I0      resd    1                       ; var000
I1      resd    1                       ; var001
I2      resd    1                       ; var002
I3      resd    1                       ; var003
I4      resd    1                       ; var004
I5      resd    1                       ; var005
I6      resd    1                       ; var006
I7      resd    1                       ; var007
I8      resd    1                       ; var008
I9      resd    1                       ; var009
I10     resd    1                       ; var010
I11     resd    1                       ; var011
I12     resd    1                       ; var012
I13     resd    1                       ; var013
I14     resd    1                       ; var014
I15     resd    1                       ; var015
I16     resd    1                       ; var016
I17     resd    1                       ; var017
I18     resd    1                       ; var018
I19     resd    1                       ; var019
I20     resd    1                       ; var020
I21     resd    1                       ; var021
I22     resd    1                       ; var022
I23     resd    1                       ; var023
I24     resd    1                       ; var024
I25     resd    1                       ; var025
I26     resd    1                       ; var026
I27     resd    1                       ; var027
I28     resd    1                       ; var028
I29     resd    1                       ; var029
I30     resd    1                       ; var030
I31     resd    1                       ; var031
I32     resd    1                       ; var032
I33     resd    1                       ; var033
I34     resd    1                       ; var034
I35     resd    1                       ; var035
I36     resd    1                       ; var036
I37     resd    1                       ; var037
I38     resd    1                       ; var038
I39     resd    1                       ; var039
I40     resd    1                       ; var040
I41     resd    1                       ; var041
I42     resd    1                       ; var042
I43     resd    1                       ; var043
I44     resd    1                       ; var044
I45     resd    1                       ; var045
I46     resd    1                       ; var046
I47     resd    1                       ; var047
I48     resd    1                       ; var048
I49     resd    1                       ; var049
I50     resd    1                       ; var050
I51     resd    1                       ; var051
I52     resd    1                       ; var052
I53     resd    1                       ; var053
I54     resd    1                       ; var054
I55     resd    1                       ; var055
I56     resd    1                       ; var056
I57     resd    1                       ; var057
I58     resd    1                       ; var058
I59     resd    1                       ; var059
I60     resd    1                       ; var060
I61     resd    1                       ; var061
I62     resd    1                       ; var062
I63     resd    1                       ; var063
I64     resd    1                       ; var064
I65     resd    1                       ; var065
I66     resd    1                       ; var066
I67     resd    1                       ; var067
I68     resd    1                       ; var068
I69     resd    1                       ; var069
I70     resd    1                       ; var070
I71     resd    1                       ; var071
I72     resd    1                       ; var072
I73     resd    1                       ; var073
I74     resd    1                       ; var074
I75     resd    1                       ; var075
I76     resd    1                       ; var076
I77     resd    1                       ; var077
I78     resd    1                       ; var078
I79     resd    1                       ; var079
I80     resd    1                       ; var080
I81     resd    1                       ; var081
I82     resd    1                       ; var082
I83     resd    1                       ; var083
I84     resd    1                       ; var084
I85     resd    1                       ; var085
I86     resd    1                       ; var086
I87     resd    1                       ; var087
I88     resd    1                       ; var088
I89     resd    1                       ; var089
I90     resd    1                       ; var090
I91     resd    1                       ; var091
I92     resd    1                       ; var092
I93     resd    1                       ; var093
I94     resd    1                       ; var094
I95     resd    1                       ; var095
I96     resd    1                       ; var096
I97     resd    1                       ; var097
I98     resd    1                       ; var098
I99     resd    1                       ; var099
I100    resd    1                       ; var100
I101    resd    1                       ; var101
I102    resd    1                       ; var102
I103    resd    1                       ; var103
I104    resd    1                       ; var104
I105    resd    1                       ; var105
I106    resd    1                       ; var106
I107    resd    1                       ; var107
I108    resd    1                       ; var108
I109    resd    1                       ; var109
I110    resd    1                       ; var110
I111    resd    1                       ; var111
I112    resd    1                       ; var112
I113    resd    1                       ; var113
I114    resd    1                       ; var114
I115    resd    1                       ; var115
I116    resd    1                       ; var116
I117    resd    1                       ; var117
I118    resd    1                       ; var118
I119    resd    1                       ; var119
I120    resd    1                       ; var120
I121    resd    1                       ; var121
I122    resd    1                       ; var122
I123    resd    1                       ; var123
I124    resd    1                       ; var124
I125    resd    1                       ; var125
I126    resd    1                       ; var126
I127    resd    1                       ; var127
I128    resd    1                       ; var128
I129    resd    1                       ; var129
I130    resd    1                       ; var130
I131    resd    1                       ; var131
I132    resd    1                       ; var132
I133    resd    1                       ; var133
I134    resd    1                       ; var134
I135    resd    1                       ; var135
I136    resd    1                       ; var136
I137    resd    1                       ; var137
I138    resd    1                       ; var138
I139    resd    1                       ; var139
I140    resd    1                       ; var140
I141    resd    1                       ; var141
I142    resd    1                       ; var142
I143    resd    1                       ; var143
I144    resd    1                       ; var144
I145    resd    1                       ; var145
I146    resd    1                       ; var146
I147    resd    1                       ; var147
I148    resd    1                       ; var148
I149    resd    1                       ; var149
I150    resd    1                       ; var150
I151    resd    1                       ; var151
I152    resd    1                       ; var152
I153    resd    1                       ; var153
I154    resd    1                       ; var154
I155    resd    1                       ; var155
I156    resd    1                       ; var156
I157    resd    1                       ; var157
I158    resd    1                       ; var158
I159    resd    1                       ; var159
I160    resd    1                       ; var160
I161    resd    1                       ; var161
I162    resd    1                       ; var162
I163    resd    1                       ; var163
I164    resd    1                       ; var164
I165    resd    1                       ; var165
I166    resd    1                       ; var166
I167    resd    1                       ; var167
I168    resd    1                       ; var168
I169    resd    1                       ; var169
I170    resd    1                       ; var170
I171    resd    1                       ; var171
I172    resd    1                       ; var172
I173    resd    1                       ; var173
I174    resd    1                       ; var174
I175    resd    1                       ; var175
I176    resd    1                       ; var176
I177    resd    1                       ; var177
I178    resd    1                       ; var178
I179    resd    1                       ; var179
I180    resd    1                       ; var180
I181    resd    1                       ; var181
I182    resd    1                       ; var182
I183    resd    1                       ; var183
I184    resd    1                       ; var184
I185    resd    1                       ; var185
I186    resd    1                       ; var186
I187    resd    1                       ; var187
I188    resd    1                       ; var188
I189    resd    1                       ; var189
I190    resd    1                       ; var190
I191    resd    1                       ; var191
I192    resd    1                       ; var192
I193    resd    1                       ; var193
I194    resd    1                       ; var194
I195    resd    1                       ; var195
I196    resd    1                       ; var196
I197    resd    1                       ; var197
I198    resd    1                       ; var198
I199    resd    1                       ; var199
I200    resd    1                       ; var200
I201    resd    1                       ; var201
I202    resd    1                       ; var202
I203    resd    1                       ; var203
I204    resd    1                       ; var204
I205    resd    1                       ; var205
I206    resd    1                       ; var206
I207    resd    1                       ; var207
I208    resd    1                       ; var208
I209    resd    1                       ; var209
I210    resd    1                       ; var210
I211    resd    1                       ; var211
I212    resd    1                       ; var212
I213    resd    1                       ; var213
I214    resd    1                       ; var214
I215    resd    1                       ; var215
I216    resd    1                       ; var216
I217    resd    1                       ; var217
I218    resd    1                       ; var218
I219    resd    1                       ; var219
I220    resd    1                       ; var220
I221    resd    1                       ; var221
I222    resd    1                       ; var222
I223    resd    1                       ; var223
I224    resd    1                       ; var224
I225    resd    1                       ; var225
I226    resd    1                       ; var226
I227    resd    1                       ; var227
I228    resd    1                       ; var228
I229    resd    1                       ; var229
I230    resd    1                       ; var230
I231    resd    1                       ; var231
I232    resd    1                       ; var232
I233    resd    1                       ; var233
I234    resd    1                       ; var234
I235    resd    1                       ; var235
I236    resd    1                       ; var236
I237    resd    1                       ; var237
I238    resd    1                       ; var238
I239    resd    1                       ; var239
I240    resd    1                       ; var240
I241    resd    1                       ; var241
I242    resd    1                       ; var242
I243    resd    1                       ; var243
I244    resd    1                       ; var244
I245    resd    1                       ; var245
I246    resd    1                       ; var246
I247    resd    1                       ; var247
I248    resd    1                       ; var248
I249    resd    1                       ; var249
I250    resd    1                       ; var250
I251    resd    1                       ; var251
I252    resd    1                       ; var252
I253    resd    1                       ; var253
I254    resd    1                       ; var254

./output/027.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no027

_start:                                         

./output/028.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no028

_start:                                         
        Exit    {0}
                            
SECTION .data                                   

SECTION .bss                                    
I0      resd    1                       ; var000
I1      resd    1                       ; var001
I2      resd    1                       ; var002
I3      resd    1                       ; var003
I4      resd    1                       ; var004
I5      resd    1                       ; var005
I6      resd    1                       ; var006
I7      resd    1                       ; var007
I8      resd    1                       ; var008
I9      resd    1                       ; var009
I10     resd    1                       ; var010
I11     resd    1                       ; var011
I12     resd    1                       ; var012
I13     resd    1                       ; var013
I14     resd    1                       ; var014
I15     resd    1                       ; var015
I16     resd    1                       ; var016
I17     resd    1                       ; var017
I18     resd    1                       ; var018
I19     resd    1                       ; var019
I20     resd    1                       ; var020
I21     resd    1                       ; var021
I22     resd    1                       ; var022
I23     resd    1                       ; var023
I24     resd    1                       ; var024
I25     resd    1                       ; var025
I26     resd    1                       ; var026
I27     resd    1                       ; var027
I28     resd    1                       ; var028
I29     resd    1                       ; var029
I30     resd    1                       ; var030
I31     resd    1                       ; var031
I32     resd    1                       ; var032
I33     resd    1                       ; var033
I34     resd    1                       ; var034
I35     resd    1                       ; var035
I36     resd    1                       ; var036
I37     resd    1                       ; var037
I38     resd    1                       ; var038
I39     resd    1                       ; var039
I40     resd    1                       ; var040
I41     resd    1                       ; var041
I42     resd    1                       ; var042
I43     resd    1                       ; var043
I44     resd    1                       ; var044
I45     resd    1                       ; var045
I46     resd    1                       ; var046
I47     resd    1                       ; var047
I48     resd    1                       ; var048
I49     resd    1                       ; var049
I50     resd    1                       ; var050
I51     resd    1                       ; var051
I52     resd    1                       ; var052
I53     resd    1                       ; var053
I54     resd    1                       ; var054
I55     resd    1                       ; var055
I56     resd    1                       ; var056
I57     resd    1                       ; var057
I58     resd    1                       ; var058
I59     resd    1                       ; var059
I60     resd    1                       ; var060
I61     resd    1                       ; var061
I62     resd    1                       ; var062
I63     resd    1                       ; var063
I64     resd    1                       ; var064
I65     resd    1                       ; var065
I66     resd    1                       ; var066
I67     resd    1                       ; var067
I68     resd    1                       ; var068
I69     resd    1                       ; var069
I70     resd    1                       ; var070
I71     resd    1                       ; var071
I72     resd    1                       ; var072
I73     resd    1                       ; var073
I74     resd    1                       ; var074
I75     resd    1                       ; var075
I76     resd    1                       ; var076
I77     resd    1                       ; var077
I78     resd    1                       ; var078
I79     resd    1                       ; var079
I80     resd    1                       ; var080
I81     resd    1                       ; var081
I82     resd    1                       ; var082
I83     resd    1                       ; var083
I84     resd    1                       ; var084
I85     resd    1                       ; var085
I86     resd    1                       ; var086
I87     resd    1                       ; var087
I88     resd    1                       ; var088
I89     resd    1                       ; var089
I90     resd    1                       ; var090
I91     resd    1                       ; var091
I92     resd    1                       ; var092
I93     resd    1                       ; var093
I94     resd    1                       ; var094
I95     resd    1                       ; var095
I96     resd    1                       ; var096
I97     resd    1                       ; var097
I98     resd    1                       ; var098
I99     resd    1                       ; var099
I100    resd    1                       ; var100
I101    resd    1                       ; var101
I102    resd    1                       ; var102
I103    resd    1                       ; var103
I104    resd    1                       ; var104
I105    resd    1                       ; var105
I106    resd    1                       ; var106
I107    resd    1                       ; var107
I108    resd    1                       ; var108
I109    resd    1                       ; var109
I110    resd    1                       ; var110
I111    resd    1                       ; var111
I112    resd    1                       ; var112
I113    resd    1                       ; var113
I114    resd    1                       ; var114
I115    resd    1                       ; var115
I116    resd    1                       ; var116
I117    resd    1                       ; var117
I118    resd    1                       ; var118
I119    resd    1                       ; var119
I120    resd    1                       ; var120
I121    resd    1                       ; var121
I122    resd    1                       ; var122
I123    resd    1                       ; var123
I124    resd    1                       ; var124
I125    resd    1                       ; var125
I126    resd    1                       ; var126
I127    resd    1                       ; var127
I128    resd    1                       ; var128
I129    resd    1                       ; var129
I130    resd    1                       ; var130
I131    resd    1                       ; var131
I132    resd    1                       ; var132
I133    resd    1                       ; var133
I134    resd    1                       ; var134
I135    resd    1                       ; var135
I136    resd    1                       ; var136
I137    resd    1                       ; var137
I138    resd    1                       ; var138
I139    resd    1                       ; var139
I140    resd    1                       ; var140
I141    resd    1                       ; var141
I142    resd    1                       ; var142
I143    resd    1                       ; var143
I144    resd    1                       ; var144
I145    resd    1                       ; var145
I146    resd    1                       ; var146
I147    resd    1                       ; var147
I148    resd    1                       ; var148
I149    resd    1                       ; var149
I150    resd    1                       ; var150
I151    resd    1                       ; var151
I152    resd    1                       ; var152
I153    resd    1                       ; var153
I154    resd    1                       ; var154
I155    resd    1                       ; var155
I156    resd    1                       ; var156
I157    resd    1                       ; var157
I158    resd    1                       ; var158
I159    resd    1                       ; var159
I160    resd    1                       ; var160
I161    resd    1                       ; var161
I162    resd    1                       ; var162
I163    resd    1                       ; var163
I164    resd    1                       ; var164
I165    resd    1                       ; var165
I166    resd    1                       ; var166
I167    resd    1                       ; var167
I168    resd    1                       ; var168
I169    resd    1                       ; var169
I170    resd    1                       ; var170
I171    resd    1                       ; var171
I172    resd    1                       ; var172
I173    resd    1                       ; var173
I174    resd    1                       ; var174
I175    resd    1                       ; var175
I176    resd    1                       ; var176
I177    resd    1                       ; var177
I178    resd    1                       ; var178
I179    resd    1                       ; var179
I180    resd    1                       ; var180
I181    resd    1                       ; var181
I182    resd    1                       ; var182
I183    resd    1                       ; var183
I184    resd    1                       ; var184
I185    resd    1                       ; var185
I186    resd    1                       ; var186
I187    resd    1                       ; var187
I188    resd    1                       ; var188
I189    resd    1                       ; var189
I190    resd    1                       ; var190
I191    resd    1                       ; var191
I192    resd    1                       ; var192
I193    resd    1                       ; var193
I194    resd    1                       ; var194
I195    resd    1                       ; var195
I196    resd    1                       ; var196
I197    resd    1                       ; var197
I198    resd    1                       ; var198
I199    resd    1                       ; var199
I200    resd    1                       ; var200
I201    resd    1                       ; var201
I202    resd    1                       ; var202
I203    resd    1                       ; var203
I204    resd    1                       ; var204
I205    resd    1                       ; var205
I206    resd    1                       ; var206
I207    resd    1                       ; var207
I208    resd    1                       ; var208
I209    resd    1                       ; var209
I210    resd    1                       ; var210
I211    resd    1                       ; var211
I212    resd    1                       ; var212
I213    resd    1                       ; var213
I214    resd    1                       ; var214
I215    resd    1                       ; var215
I216    resd    1                       ; var216
I217    resd    1                       ; var217
I218    resd    1                       ; var218
I219    resd    1                       ; var219
I220    resd    1                       ; var220
I221    resd    1                       ; var221
I222    resd    1                       ; var222
I223    resd    1                       ; var223
I224    resd    1                       ; var224
I225    resd    1                       ; var225
I226    resd    1                       ; var226
I227    resd    1                       ; var227
I228    resd    1                       ; var228
I229    resd    1                       ; var229
I230    resd    1                       ; var230
I231    resd    1                       ; var231
I232    resd    1                       ; var232
I233    resd    1                       ; var233
I234    resd    1                       ; var234
I235    resd    1                       ; var235
I236    resd    1                       ; var236
I237    resd    1                       ; var237
I238    resd    1                       ; var238
I239    resd    1                       ; var239
I240    resd    1                       ; var240
I241    resd    1                       ; var241
I242    resd    1                       ; var242
I243    resd    1                       ; var243
I244    resd    1                       ; var244
I245    resd    1                       ; var245
I246    resd    1                       ; var246
I247    resd    1                       ; var247
I248    resd    1                       ; var248
I249    resd    1                       ; var249
I250    resd    1                       ; var250
I251    resd    1                       ; var251
I252    resd    1                       ; var252
I253    resd    1                       ; var253
I254    resd    1                       ; var254

./output/029.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no029

_start:                                         
        Exit    {0}
                            
SECTION .data                                   
I2      dd      1                       ; big   
I3      dd      2                       ; bigger_yet
B1      dd      0                       ; no    
I0      dd      0                       ; small 
I1      dd      -1                      ; smalleryet
B0      dd      -1                      ; yes   

SECTION .bss                                    
I4      resd    1                       ; some  

./output/030.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no030

_start:                                         
        Exit    {0}
                            
SECTION .data                                   
I2      dd      1                       ; big   
I3      dd      2                       ; bigger_yet
B1      dd      0                       ; no    
I0      dd      0                       ; small 
I1      dd      -1                      ; smalleryet
B0      dd      -1                      ; yes   

SECTION .bss                                    
I4      resd    1                       ; some  

./output/031.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no031

_start:                                         
        Exit    {0}
                            
SECTION .data                                   

SECTION .bss                                    

./output/032.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no032

_start:                                         
        Exit    {0}
                            
SECTION .data                                   
I2      dd      1                       ; big   
I3      dd      2                       ; biggeryet
I4      dd      2                       ; large 
B2      dd      0                       ; maybe 
B1      dd      0                       ; no    
I0      dd      0                       ; small 
I1      dd      -1                      ; smalleryet
B0      dd      -1                      ; yes   

SECTION .bss                                    
I6      resd    1                       ; many  
B3      resd    1                       ; right 
I5      resd    1                       ; some  
B4      resd    1                       ; wrong 

./output/033.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no033

_start:                                         
        Exit    {0}
                            
SECTION .data                                   
I2      dd      1                       ; big   
I3      dd      2                       ; biggeryet
I4      dd      2                       ; large 
B2      dd      0                       ; maybe 
B1      dd      0                       ; no    
I0      dd      0                       ; small 
I1      dd      -1                      ; smalleryet
B0      dd      -1                      ; yes   

SECTION .bss                                    
I6      resd    1                       ; many  
B3      resd    1                       ; right 
I5      resd    1                       ; some  
B4      resd    1                       ; wrong 

./output/034.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no034

_start:                                         
        Exit    {0}
                            
SECTION .data                                   

SECTION .bss                                    

./output/035.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no035

_start:                                         
        Exit    {0}
                            
SECTION .data                                   

SECTION .bss                                    

./output/036.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no036_thi

_start:                                         
        Exit    {0}
                            
SECTION .data                                   

SECTION .bss                                    

./output/037.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no037_thi

_start:                                         

./output/038.my.asm
------------------------------

./output/039.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no039

_start:                                         

./output/040.my.asm
------------------------------

./output/041.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no041

_start:                                         

./output/042.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no042

_start:                                         

./output/043.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no043

_start:                                         

./output/044.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no044

_start:                                         

./output/045.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no045

_start:                                         

./output/046.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no046

_start:                                         

./output/047.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no047

_start:                                         

./output/048.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no048

_start:                                         

./output/049.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no049

_start:                                         

./output/050.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no050

_start:                                         

./output/051.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no051

_start:                                         
        Exit    {0}
                            
SECTION .data                                   
I2      dd      1                       ; big   
I3      dd      +2336                   ; biggeryet
B6      dd      0                       ; fal_se
I4      dd      +2336                   ; large 
B2      dd      0                       ; maybe 
I6      dd      -1234                   ; minus 
B1      dd      0                       ; no    
B5      dd      0                       ; off   
B4      dd      -1                      ; on    
B3      dd      -1                      ; possible
I0      dd      0                       ; small 
I1      dd      -1234                   ; smalleryet
B7      dd      -1                      ; tru_e 
B0      dd      -1                      ; yes   
I5      dd      0                       ; zero  

SECTION .bss                                    
I8      resd    1                       ; many  
B8      resd    1                       ; right 
I7      resd    1                       ; some  
B9      resd    1                       ; wrong 

./output/052.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage0no052

_start:                                         

./output/101.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no101

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I2],eax                ; store eax at a
        call    ReadInt                 ; read int; value placed in eax
        mov     [I3],eax                ; store eax at b
        call    ReadInt                 ; read int; value placed in eax
        mov     [I4],eax                ; store eax at c
        mov     eax,[I2]                ; load a in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I3]                ; load b in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I5]                ; AReg = 3
        add     eax,[I6]                ; AReg = 3 + 34
        imul    dword [I1]              ; AReg = T0 * five
        mov     [I2],eax                ; a = AReg
        add     eax,[I2]                ; AReg = a + a
        mov     [I3],eax                ; b = AReg
        mov     eax,[I1]                ; load five in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I2]                ; load a in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I3]                ; load b in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I4]                ; load c in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I1]                ; load five in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I0]                ; load zero in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                            
SECTION .data                                   
I5      dd      3                       ; 3     
I6      dd      34                      ; 34    
I1      dd      5                       ; five  
I0      dd      0                       ; zero  

SECTION .bss                                    
I2      resd    1                       ; a     
I3      resd    1                       ; b     
I4      resd    1                       ; c     

./output/102.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no102

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I2],eax                ; store eax at a
        call    ReadInt                 ; read int; value placed in eax
        mov     [I3],eax                ; store eax at b
        mov     eax,[I7]                ; AReg = -5
        cdq                             ; sign extend dividend from eax to edx:eax
        idiv    dword [I2]              ; AReg = -5 div a
        xchg    eax,edx                 ; exchange quotient and remainder
        add     eax,[I3]                ; AReg = T0 + b
        mov     [I6],eax                ; z = AReg
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        add     eax,[I3]                ; AReg = z + b
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I2]                ; AReg = a
        sub     eax,[I3]                ; AReg = a - b
        imul    dword [T0]              ; AReg = T1 * T0
        mov     [I4],eax                ; c = AReg
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                            
SECTION .data                                   
I7      dd      -5                      ; -5    
I1      dd      5                       ; five  
I0      dd      0                       ; zero  

SECTION .bss                                    
T0      resd    1                       ; T0    
I2      resd    1                       ; a     
I3      resd    1                       ; b     
I4      resd    1                       ; c     
I5      resd    1                       ; w     
I6      resd    1                       ; z     

./output/103.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no103

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I5],eax                ; store eax at z
        cmp     eax,[I0]                ; compare z and zero
        jg      .L0                     ; if z > zero then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                            
        mov     [B0],eax                ; d = AReg
        mov     eax,[I5]                ; load z in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                            
SECTION .data                                   
FALSE   dd      0                       ; false 
I1      dd      5                       ; five  
TRUE    dd      -1                      ; true  
I0      dd      0                       ; zero  

SECTION .bss                                    
I2      resd    1                       ; a     
I3      resd    1                       ; b     
I4      resd    1                       ; c     
B0      resd    1                       ; d     
I5      resd    1                       ; z     

./output/104.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no104

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at a
        add     eax,[I4]                ; AReg = a + 2
        add     eax,[I0]                ; AReg = T0 + five
        mov     [I1],eax                ; a = AReg
        sub     eax,[I1]                ; AReg = a - a
        mov     [I2],eax                ; b = AReg
        cdq                             ; sign extend dividend from eax to edx:eax
        idiv    dword [I1]              ; AReg = b div a
        mov     [I3],eax                ; c = AReg
        mov     eax,[I1]                ; load a in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I2]                ; load b in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I3]                ; load c in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                            
SECTION .data                                   
I4      dd      2                       ; 2     
I0      dd      5                       ; five  

SECTION .bss                                    
I1      resd    1                       ; a     
I2      resd    1                       ; b     
I3      resd    1                       ; c     

./output/105.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no105

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I2],eax                ; store eax at a
        call    ReadInt                 ; read int; value placed in eax
        mov     [I3],eax                ; store eax at b
        call    ReadInt                 ; read int; value placed in eax
        mov     [I4],eax                ; store eax at c
        call    ReadInt                 ; read int; value placed in eax
        mov     [I6],eax                ; store eax at z
        mov     eax,[I3]                ; AReg = b
        cdq                             ; sign extend dividend from eax to edx:eax
        idiv    dword [I2]              ; AReg = b div a
        xchg    eax,edx                 ; exchange quotient and remainder
        mov     [I6],eax                ; z = AReg
        imul    dword [I4]              ; AReg = z * c
        mov     [I5],eax                ; w = AReg
        mov     eax,[I6]                ; AReg = z
        neg     eax                     ; AReg = -AReg
        mov     [I2],eax                ; a = AReg
        mov     eax,[I4]                ; AReg = c
        mov     [I3],eax                ; b = AReg
        mov     eax,[I6]                ; load z in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I5]                ; load w in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I2]                ; load a in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I3]                ; load b in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                            
SECTION .data                                   
I1      dd      5                       ; five  
I0      dd      0                       ; zero  

SECTION .bss                                    
I2      resd    1                       ; a     
I3      resd    1                       ; b     
I4      resd    1                       ; c     
I5      resd    1                       ; w     
I6      resd    1                       ; z     

./output/106.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no106

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at b
        call    ReadInt                 ; read int; value placed in eax
        mov     [I2],eax                ; store eax at c
        mov     eax,[I4]                ; AReg = 3
        mov     [I0],eax                ; a = AReg
        mov     eax,[I1]                ; AReg = b
        imul    dword [I2]              ; AReg = b * c
        add     eax,[I0]                ; AReg = T0 + a
        mov     [I3],eax                ; d = AReg
        mov     eax,[I0]                ; AReg = a
        imul    dword [I1]              ; AReg = a * b
        add     eax,[I2]                ; AReg = T0 + c
        mov     [I1],eax                ; b = AReg
        mov     eax,[I3]                ; load d in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I1]                ; load b in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                            
SECTION .data                                   
I4      dd      3                       ; 3     

SECTION .bss                                    
I0      resd    1                       ; a     
I1      resd    1                       ; b     
I2      resd    1                       ; c     
I3      resd    1                       ; d     

./output/107.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no107

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I3],eax                ; store eax at a
        call    ReadInt                 ; read int; value placed in eax
        mov     [I4],eax                ; store eax at b
        call    ReadInt                 ; read int; value placed in eax
        mov     [I5],eax                ; store eax at c
        mov     eax,[I3]                ; AReg = a
        add     eax,[I4]                ; AReg = a + b
        add     eax,[I5]                ; AReg = T0 + c
        mov     [I3],eax                ; a = AReg
        imul    dword [I4]              ; AReg = a * b
        imul    dword [I5]              ; AReg = T0 * c
        mov     [I6],eax                ; d = AReg
        mov     eax,[I3]                ; AReg = a
        add     eax,[I4]                ; AReg = a + b
        mov     [I6],eax                ; d = AReg
        mov     eax,[I3]                ; load a in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I6]                ; load d in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                            
SECTION .data                                   
I1      dd      5                       ; five  
B0      dd      0                       ; right 
I2      dd      45                      ; t0    
B1      dd      -1                      ; wrong 
I0      dd      0                       ; zero  

SECTION .bss                                    
I3      resd    1                       ; a     
I4      resd    1                       ; b     
I5      resd    1                       ; c     
I6      resd    1                       ; d     

./output/108.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no108

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at a

./output/109.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no109

_start:                                         

./output/110.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no110

_start:                                         

./output/111.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no111

_start:                                         
        mov     eax,[I1]                ; AReg = five
        imul    dword [I2]              ; AReg = five * a

./output/112.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no112

_start:                                         
        mov     eax,[I1]                ; AReg = five
        imul    dword [I2]              ; AReg = five * a

./output/113.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no113

_start:                                         
        mov     eax,[I1]                ; AReg = five
        imul    dword [I2]              ; AReg = five * a

./output/114.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no114

_start:                                         
        mov     eax,[I1]                ; AReg = five
        imul    dword [I2]              ; AReg = five * a
        mov     [I6],eax                ; d = AReg

./output/115.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no115

_start:                                         
        mov     eax,[B0]                ; AReg = yes
        and     eax,[B1]                ; AReg = yes and no
        mov     [B7],eax                ; d = AReg
        mov     eax,[B0]                ; AReg = yes
        mov     [B2],eax                ; a = AReg
        mov     eax,[B0]                ; AReg = yes
        or      eax,[B1]                ; AReg = yes or no
        mov     [B3],eax                ; b = AReg
        not     eax                     ; AReg = !AReg
        mov     [B4],eax                ; c = AReg
        mov     eax,[B7]                ; load d in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[B2]                ; load a in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[B3]                ; load b in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[B4]                ; load c in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                            
SECTION .data                                   
B1      dd      0                       ; no    
B0      dd      -1                      ; yes   

SECTION .bss                                    
B2      resd    1                       ; a     
B3      resd    1                       ; b     
B4      resd    1                       ; c     
B7      resd    1                       ; d     
B8      resd    1                       ; e     
B5      resd    1                       ; w     
B6      resd    1                       ; z     

./output/116.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no116

_start:                                         
        mov     eax,[TRUE]              ; AReg = true
        mov     [B3],eax                ; b = AReg
        mov     eax,[B0]                ; AReg = yes
        and     eax,[TRUE]              ; AReg = yes and true
        mov     [T0],eax                ; deassign AReg
        mov     eax,[B1]                ; AReg = no
        or      eax,[FALSE]             ; AReg = no or false
        and     eax,[T0]                ; AReg = T1 and T0
        mov     [B7],eax                ; d = AReg
        mov     eax,[B3]                ; AReg = b
        not     eax                     ; AReg = !AReg
        and     eax,[B0]                ; AReg = T0 and yes
        mov     [B5],eax                ; w = AReg
        mov     eax,[B7]                ; load d in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[B5]                ; load w in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                            
SECTION .data                                   
FALSE   dd      0                       ; false 
B1      dd      0                       ; no    
TRUE    dd      -1                      ; true  
B0      dd      -1                      ; yes   

SECTION .bss                                    
T0      resd    1                       ; T0    
B2      resd    1                       ; a     
B3      resd    1                       ; b     
B4      resd    1                       ; c     
B7      resd    1                       ; d     
B8      resd    1                       ; e     
B5      resd    1                       ; w     
B6      resd    1                       ; z     

./output/117.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no117

_start:                                         
        mov     eax,[I0]                ; AReg = w
        cmp     eax,[I1]                ; compare w and z
        jl      .L0                     ; if w < z then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                            
        mov     [T0],eax                ; deassign AReg
        mov     eax,[B0]                ; AReg = a
        or      eax,[B1]                ; AReg = a or b
        and     eax,[T0]                ; AReg = T1 and T0
        mov     [B4],eax                ; e = AReg
        mov     eax,[I1]                ; AReg = z
        cmp     eax,[I4]                ; compare z and 3
        jge     .L2                     ; if z >= 3 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L3                     ; unconditionally jump
.L2:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L3:                                            
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I0]                ; AReg = w
        cmp     eax,[I5]                ; compare w and 4
        jl      .L4                     ; if w < 4 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L5                     ; unconditionally jump
.L4:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L5:                                            
        or      eax,[T0]                ; AReg = T1 or T0
        mov     [B3],eax                ; d = AReg
        Exit    {0}
                            
SECTION .data                                   
I4      dd      3                       ; 3     
I5      dd      4                       ; 4     
B0      dd      -1                      ; a     
B1      dd      0                       ; b     
FALSE   dd      0                       ; false 
TRUE    dd      -1                      ; true  

SECTION .bss                                    
T0      resd    1                       ; T0    
B2      resd    1                       ; c     
B3      resd    1                       ; d     
B4      resd    1                       ; e     
I0      resd    1                       ; w     
I3      resd    1                       ; x     
I2      resd    1                       ; y     
I1      resd    1                       ; z     

./output/118.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no118

_start:                                         
        mov     eax,[I0]                ; AReg = w
        cmp     eax,[I1]                ; compare w and z
        je      .L0                     ; if w = z then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                            
        mov     [T0],eax                ; deassign AReg
        mov     eax,[B0]                ; AReg = a
        cmp     eax,[B1]                ; compare a and b
        jne     .L2                     ; if a <> b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L3                     ; unconditionally jump
.L2:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L3:                                            
        and     eax,[T0]                ; AReg = T1 and T0
        mov     [B2],eax                ; c = AReg

./output/119.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no119

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I0],eax                ; store eax at f
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at g
        call    ReadInt                 ; read int; value placed in eax
        mov     [I2],eax                ; store eax at h
        mov     eax,[I0]                ; AReg = f
        cmp     eax,[I1]                ; compare f and g
        jle     .L0                     ; if f <= g then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                            
        mov     [B2],eax                ; c = AReg
        mov     eax,[B0]                ; AReg = a
        cmp     eax,[B1]                ; compare a and b
        je      .L2                     ; if a = b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L3                     ; unconditionally jump
.L2:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L3:                                            
        mov     [B3],eax                ; d = AReg
        mov     eax,[I0]                ; AReg = f
        cmp     eax,[I2]                ; compare f and h
        je      .L4                     ; if f = h then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L5                     ; unconditionally jump
.L4:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L5:                                            
        mov     [B4],eax                ; e = AReg
        mov     eax,[B2]                ; load c in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[B3]                ; load d in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[B4]                ; load e in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                            
SECTION .data                                   
B0      dd      -1                      ; a     
B1      dd      -1                      ; b     
FALSE   dd      0                       ; false 
TRUE    dd      -1                      ; true  

SECTION .bss                                    
B2      resd    1                       ; c     
B3      resd    1                       ; d     
B4      resd    1                       ; e     
I0      resd    1                       ; f     
I1      resd    1                       ; g     
I2      resd    1                       ; h     

./output/120.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:20 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no120

_start:                                         

./output/121.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no121

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at a
        call    ReadInt                 ; read int; value placed in eax
        mov     [I2],eax                ; store eax at b
        call    ReadInt                 ; read int; value placed in eax
        mov     [I3],eax                ; store eax at c
        call    ReadInt                 ; read int; value placed in eax
        mov     [I4],eax                ; store eax at d
        call    ReadInt                 ; read int; value placed in eax
        mov     [I5],eax                ; store eax at e
        call    ReadInt                 ; read int; value placed in eax
        mov     [I6],eax                ; store eax at f
        call    ReadInt                 ; read int; value placed in eax
        mov     [I7],eax                ; store eax at g
        call    ReadInt                 ; read int; value placed in eax
        mov     [I8],eax                ; store eax at h
        call    ReadInt                 ; read int; value placed in eax
        mov     [I9],eax                ; store eax at i
        call    ReadInt                 ; read int; value placed in eax
        mov     [I10],eax               ; store eax at j
        call    ReadInt                 ; read int; value placed in eax
        mov     [I11],eax               ; store eax at k
        call    ReadInt                 ; read int; value placed in eax
        mov     [I12],eax               ; store eax at l
        call    ReadInt                 ; read int; value placed in eax
        mov     [I13],eax               ; store eax at m
        call    ReadInt                 ; read int; value placed in eax
        mov     [I14],eax               ; store eax at n
        call    ReadInt                 ; read int; value placed in eax
        mov     [I15],eax               ; store eax at o
        call    ReadInt                 ; read int; value placed in eax
        mov     [I16],eax               ; store eax at p
        call    ReadInt                 ; read int; value placed in eax
        mov     [I17],eax               ; store eax at q
        call    ReadInt                 ; read int; value placed in eax
        mov     [I18],eax               ; store eax at r
        call    ReadInt                 ; read int; value placed in eax
        mov     [I19],eax               ; store eax at s
        call    ReadInt                 ; read int; value placed in eax
        mov     [I20],eax               ; store eax at t
        call    ReadInt                 ; read int; value placed in eax
        mov     [I21],eax               ; store eax at u
        call    ReadInt                 ; read int; value placed in eax
        mov     [I22],eax               ; store eax at v
        call    ReadInt                 ; read int; value placed in eax
        mov     [I23],eax               ; store eax at w
        call    ReadInt                 ; read int; value placed in eax
        mov     [I24],eax               ; store eax at x
        call    ReadInt                 ; read int; value placed in eax
        mov     [I25],eax               ; store eax at y
        call    ReadInt                 ; read int; value placed in eax
        mov     [I26],eax               ; store eax at z
        mov     eax,[I1]                ; AReg = a
        add     eax,[I2]                ; AReg = a + b
        add     eax,[I3]                ; AReg = T0 + c
        add     eax,[I4]                ; AReg = T0 + d
        add     eax,[I5]                ; AReg = T0 + e
        add     eax,[I6]                ; AReg = T0 + f
        add     eax,[I7]                ; AReg = T0 + g
        add     eax,[I8]                ; AReg = T0 + h
        add     eax,[I9]                ; AReg = T0 + i
        add     eax,[I10]               ; AReg = T0 + j
        add     eax,[I11]               ; AReg = T0 + k
        add     eax,[I12]               ; AReg = T0 + l
        add     eax,[I13]               ; AReg = T0 + m
        add     eax,[I14]               ; AReg = T0 + n
        add     eax,[I15]               ; AReg = T0 + o
        add     eax,[I16]               ; AReg = T0 + p
        add     eax,[I17]               ; AReg = T0 + q
        add     eax,[I18]               ; AReg = T0 + r
        add     eax,[I19]               ; AReg = T0 + s
        add     eax,[I20]               ; AReg = T0 + t
        add     eax,[I21]               ; AReg = T0 + u
        add     eax,[I22]               ; AReg = T0 + v
        add     eax,[I23]               ; AReg = T0 + w
        add     eax,[I24]               ; AReg = T0 + x
        add     eax,[I25]               ; AReg = T0 + y
        add     eax,[I26]               ; AReg = T0 + z
        mov     [I0],eax                ; sum = AReg
        mov     eax,[I1]                ; load a in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I2]                ; load b in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I3]                ; load c in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I4]                ; load d in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I5]                ; load e in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I6]                ; load f in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I7]                ; load g in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I8]                ; load h in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I9]                ; load i in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I10]               ; load j in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I11]               ; load k in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I12]               ; load l in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I13]               ; load m in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I14]               ; load n in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I15]               ; load o in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I16]               ; load p in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I17]               ; load q in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I18]               ; load r in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I19]               ; load s in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I20]               ; load t in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I21]               ; load u in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I22]               ; load v in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I23]               ; load w in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I24]               ; load x in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I25]               ; load y in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I26]               ; load z in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I0]                ; load sum in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                            
SECTION .data                                   

SECTION .bss                                    
I1      resd    1                       ; a     
I2      resd    1                       ; b     
I3      resd    1                       ; c     
I4      resd    1                       ; d     
I5      resd    1                       ; e     
I6      resd    1                       ; f     
I7      resd    1                       ; g     
I8      resd    1                       ; h     
I9      resd    1                       ; i     
I10     resd    1                       ; j     
I11     resd    1                       ; k     
I12     resd    1                       ; l     
I13     resd    1                       ; m     
I14     resd    1                       ; n     
I15     resd    1                       ; o     
I16     resd    1                       ; p     
I17     resd    1                       ; q     
I18     resd    1                       ; r     
I19     resd    1                       ; s     
I0      resd    1                       ; sum   
I20     resd    1                       ; t     
I21     resd    1                       ; u     
I22     resd    1                       ; v     
I23     resd    1                       ; w     
I24     resd    1                       ; x     
I25     resd    1                       ; y     
I26     resd    1                       ; z     

./output/122.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no122

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at a
        call    ReadInt                 ; read int; value placed in eax
        mov     [I2],eax                ; store eax at b
        call    ReadInt                 ; read int; value placed in eax
        mov     [I3],eax                ; store eax at c
        call    ReadInt                 ; read int; value placed in eax
        mov     [I4],eax                ; store eax at d
        call    ReadInt                 ; read int; value placed in eax
        mov     [I5],eax                ; store eax at e
        call    ReadInt                 ; read int; value placed in eax
        mov     [I6],eax                ; store eax at f
        call    ReadInt                 ; read int; value placed in eax
        mov     [I7],eax                ; store eax at g
        call    ReadInt                 ; read int; value placed in eax
        mov     [I8],eax                ; store eax at h
        call    ReadInt                 ; read int; value placed in eax
        mov     [I9],eax                ; store eax at i
        call    ReadInt                 ; read int; value placed in eax
        mov     [I10],eax               ; store eax at j
        call    ReadInt                 ; read int; value placed in eax
        mov     [I11],eax               ; store eax at k
        call    ReadInt                 ; read int; value placed in eax
        mov     [I12],eax               ; store eax at l
        call    ReadInt                 ; read int; value placed in eax
        mov     [I13],eax               ; store eax at m
        call    ReadInt                 ; read int; value placed in eax
        mov     [I14],eax               ; store eax at n
        call    ReadInt                 ; read int; value placed in eax
        mov     [I15],eax               ; store eax at o
        call    ReadInt                 ; read int; value placed in eax
        mov     [I16],eax               ; store eax at p
        call    ReadInt                 ; read int; value placed in eax
        mov     [I17],eax               ; store eax at q
        call    ReadInt                 ; read int; value placed in eax
        mov     [I18],eax               ; store eax at r
        call    ReadInt                 ; read int; value placed in eax
        mov     [I19],eax               ; store eax at s
        call    ReadInt                 ; read int; value placed in eax
        mov     [I20],eax               ; store eax at t
        call    ReadInt                 ; read int; value placed in eax
        mov     [I21],eax               ; store eax at u
        call    ReadInt                 ; read int; value placed in eax
        mov     [I22],eax               ; store eax at v
        call    ReadInt                 ; read int; value placed in eax
        mov     [I23],eax               ; store eax at w
        call    ReadInt                 ; read int; value placed in eax
        mov     [I24],eax               ; store eax at x
        call    ReadInt                 ; read int; value placed in eax
        mov     [I25],eax               ; store eax at y
        call    ReadInt                 ; read int; value placed in eax
        mov     [I26],eax               ; store eax at z
        mov     eax,[I1]                ; AReg = a
        add     eax,[I2]                ; AReg = a + b
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I3]                ; AReg = c
        add     eax,[I4]                ; AReg = c + d
        mov     [T1],eax                ; deassign AReg
        mov     eax,[I5]                ; AReg = e
        add     eax,[I6]                ; AReg = e + f
        mov     [T2],eax                ; deassign AReg
        mov     eax,[I7]                ; AReg = g
        add     eax,[I8]                ; AReg = g + h
        mov     [T3],eax                ; deassign AReg
        mov     eax,[I9]                ; AReg = i
        add     eax,[I10]               ; AReg = i + j
        mov     [T4],eax                ; deassign AReg
        mov     eax,[I11]               ; AReg = k
        add     eax,[I12]               ; AReg = k + l
        mov     [T5],eax                ; deassign AReg
        mov     eax,[I13]               ; AReg = m
        add     eax,[I14]               ; AReg = m + n
        mov     [T6],eax                ; deassign AReg
        mov     eax,[I15]               ; AReg = o
        add     eax,[I16]               ; AReg = o + p
        mov     [T7],eax                ; deassign AReg
        mov     eax,[I17]               ; AReg = q
        add     eax,[I18]               ; AReg = q + r
        mov     [T8],eax                ; deassign AReg
        mov     eax,[I19]               ; AReg = s
        add     eax,[I20]               ; AReg = s + t
        mov     [T9],eax                ; deassign AReg
        mov     eax,[I21]               ; AReg = u
        add     eax,[I22]               ; AReg = u + v
        mov     [T10],eax               ; deassign AReg
        mov     eax,[I23]               ; AReg = w
        add     eax,[I24]               ; AReg = w + x
        mov     [T11],eax               ; deassign AReg
        mov     eax,[I25]               ; AReg = y
        add     eax,[I26]               ; AReg = y + z
        add     eax,[T11]               ; AReg = T12 + T11
        add     eax,[T10]               ; AReg = T11 + T10
        add     eax,[T9]                ; AReg = T10 + T9
        add     eax,[T8]                ; AReg = T9 + T8
        add     eax,[T7]                ; AReg = T8 + T7
        add     eax,[T6]                ; AReg = T7 + T6
        add     eax,[T5]                ; AReg = T6 + T5
        add     eax,[T4]                ; AReg = T5 + T4
        add     eax,[T3]                ; AReg = T4 + T3
        add     eax,[T2]                ; AReg = T3 + T2
        add     eax,[T1]                ; AReg = T2 + T1
        add     eax,[T0]                ; AReg = T1 + T0
        mov     [I0],eax                ; sum = AReg
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                            
SECTION .data                                   

SECTION .bss                                    
T0      resd    1                       ; T0    
T1      resd    1                       ; T1    
T10     resd    1                       ; T10   
T11     resd    1                       ; T11   
T2      resd    1                       ; T2    
T3      resd    1                       ; T3    
T4      resd    1                       ; T4    
T5      resd    1                       ; T5    
T6      resd    1                       ; T6    
T7      resd    1                       ; T7    
T8      resd    1                       ; T8    
T9      resd    1                       ; T9    
I1      resd    1                       ; a     
I2      resd    1                       ; b     
I3      resd    1                       ; c     
I4      resd    1                       ; d     
I5      resd    1                       ; e     
I6      resd    1                       ; f     
I7      resd    1                       ; g     
I8      resd    1                       ; h     
I9      resd    1                       ; i     
I10     resd    1                       ; j     
I11     resd    1                       ; k     
I12     resd    1                       ; l     
I13     resd    1                       ; m     
I14     resd    1                       ; n     
I15     resd    1                       ; o     
I16     resd    1                       ; p     
I17     resd    1                       ; q     
I18     resd    1                       ; r     
I19     resd    1                       ; s     
I0      resd    1                       ; sum   
I20     resd    1                       ; t     
I21     resd    1                       ; u     
I22     resd    1                       ; v     
I23     resd    1                       ; w     
I24     resd    1                       ; x     
I25     resd    1                       ; y     
I26     resd    1                       ; z     

./output/123.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no123

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at a
        call    ReadInt                 ; read int; value placed in eax
        mov     [I2],eax                ; store eax at b
        call    ReadInt                 ; read int; value placed in eax
        mov     [I3],eax                ; store eax at c
        call    ReadInt                 ; read int; value placed in eax
        mov     [I4],eax                ; store eax at d
        call    ReadInt                 ; read int; value placed in eax
        mov     [I5],eax                ; store eax at e
        call    ReadInt                 ; read int; value placed in eax
        mov     [I6],eax                ; store eax at f
        call    ReadInt                 ; read int; value placed in eax
        mov     [I7],eax                ; store eax at g
        call    ReadInt                 ; read int; value placed in eax
        mov     [I8],eax                ; store eax at h
        call    ReadInt                 ; read int; value placed in eax
        mov     [I9],eax                ; store eax at i
        call    ReadInt                 ; read int; value placed in eax
        mov     [I10],eax               ; store eax at j
        call    ReadInt                 ; read int; value placed in eax
        mov     [I11],eax               ; store eax at k
        call    ReadInt                 ; read int; value placed in eax
        mov     [I12],eax               ; store eax at l
        call    ReadInt                 ; read int; value placed in eax
        mov     [I13],eax               ; store eax at m
        call    ReadInt                 ; read int; value placed in eax
        mov     [I14],eax               ; store eax at n
        call    ReadInt                 ; read int; value placed in eax
        mov     [I15],eax               ; store eax at o
        call    ReadInt                 ; read int; value placed in eax
        mov     [I16],eax               ; store eax at p
        call    ReadInt                 ; read int; value placed in eax
        mov     [I17],eax               ; store eax at q
        call    ReadInt                 ; read int; value placed in eax
        mov     [I18],eax               ; store eax at r
        call    ReadInt                 ; read int; value placed in eax
        mov     [I19],eax               ; store eax at s
        call    ReadInt                 ; read int; value placed in eax
        mov     [I20],eax               ; store eax at t
        call    ReadInt                 ; read int; value placed in eax
        mov     [I21],eax               ; store eax at u
        call    ReadInt                 ; read int; value placed in eax
        mov     [I22],eax               ; store eax at v
        call    ReadInt                 ; read int; value placed in eax
        mov     [I23],eax               ; store eax at w
        call    ReadInt                 ; read int; value placed in eax
        mov     [I24],eax               ; store eax at x
        call    ReadInt                 ; read int; value placed in eax
        mov     [I25],eax               ; store eax at y
        call    ReadInt                 ; read int; value placed in eax
        mov     [I26],eax               ; store eax at z
        mov     eax,[I1]                ; AReg = a
        sub     eax,[I2]                ; AReg = a - b
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I3]                ; AReg = c
        sub     eax,[I4]                ; AReg = c - d
        mov     [T1],eax                ; deassign AReg
        mov     eax,[I5]                ; AReg = e
        sub     eax,[I6]                ; AReg = e - f
        mov     [T2],eax                ; deassign AReg
        mov     eax,[I7]                ; AReg = g
        sub     eax,[I8]                ; AReg = g - h
        mov     [T3],eax                ; deassign AReg
        mov     eax,[I9]                ; AReg = i
        sub     eax,[I10]               ; AReg = i - j
        mov     [T4],eax                ; deassign AReg
        mov     eax,[I11]               ; AReg = k
        sub     eax,[I12]               ; AReg = k - l
        mov     [T5],eax                ; deassign AReg
        mov     eax,[I13]               ; AReg = m
        sub     eax,[I14]               ; AReg = m - n
        mov     [T6],eax                ; deassign AReg
        mov     eax,[I15]               ; AReg = o
        sub     eax,[I16]               ; AReg = o - p
        mov     [T7],eax                ; deassign AReg
        mov     eax,[I17]               ; AReg = q
        sub     eax,[I18]               ; AReg = q - r
        mov     [T8],eax                ; deassign AReg
        mov     eax,[I19]               ; AReg = s
        sub     eax,[I20]               ; AReg = s - t
        mov     [T9],eax                ; deassign AReg
        mov     eax,[I21]               ; AReg = u
        sub     eax,[I22]               ; AReg = u - v
        mov     [T10],eax               ; deassign AReg
        mov     eax,[I23]               ; AReg = w
        sub     eax,[I24]               ; AReg = w - x
        mov     [T11],eax               ; deassign AReg
        mov     eax,[I25]               ; AReg = y
        sub     eax,[I26]               ; AReg = y - z
        mov     [T12],eax               ; deassign AReg
        mov     eax,[T11]               ; AReg = T11
        sub     eax,[T12]               ; AReg = T11 - T12
        mov     [T11],eax               ; deassign AReg
        mov     eax,[T10]               ; AReg = T10
        sub     eax,[T11]               ; AReg = T10 - T11
        mov     [T10],eax               ; deassign AReg
        mov     eax,[T9]                ; AReg = T9
        sub     eax,[T10]               ; AReg = T9 - T10
        mov     [T9],eax                ; deassign AReg
        mov     eax,[T8]                ; AReg = T8
        sub     eax,[T9]                ; AReg = T8 - T9
        mov     [T8],eax                ; deassign AReg
        mov     eax,[T7]                ; AReg = T7
        sub     eax,[T8]                ; AReg = T7 - T8
        mov     [T7],eax                ; deassign AReg
        mov     eax,[T6]                ; AReg = T6
        sub     eax,[T7]                ; AReg = T6 - T7
        mov     [T6],eax                ; deassign AReg
        mov     eax,[T5]                ; AReg = T5
        sub     eax,[T6]                ; AReg = T5 - T6
        mov     [T5],eax                ; deassign AReg
        mov     eax,[T4]                ; AReg = T4
        sub     eax,[T5]                ; AReg = T4 - T5
        mov     [T4],eax                ; deassign AReg
        mov     eax,[T3]                ; AReg = T3
        sub     eax,[T4]                ; AReg = T3 - T4
        mov     [T3],eax                ; deassign AReg
        mov     eax,[T2]                ; AReg = T2
        sub     eax,[T3]                ; AReg = T2 - T3
        mov     [T2],eax                ; deassign AReg
        mov     eax,[T1]                ; AReg = T1
        sub     eax,[T2]                ; AReg = T1 - T2
        mov     [T1],eax                ; deassign AReg
        mov     eax,[T0]                ; AReg = T0
        sub     eax,[T1]                ; AReg = T0 - T1
        mov     [I0],eax                ; sum = AReg
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                            
SECTION .data                                   

SECTION .bss                                    
T0      resd    1                       ; T0    
T1      resd    1                       ; T1    
T10     resd    1                       ; T10   
T11     resd    1                       ; T11   
T12     resd    1                       ; T12   
T2      resd    1                       ; T2    
T3      resd    1                       ; T3    
T4      resd    1                       ; T4    
T5      resd    1                       ; T5    
T6      resd    1                       ; T6    
T7      resd    1                       ; T7    
T8      resd    1                       ; T8    
T9      resd    1                       ; T9    
I1      resd    1                       ; a     
I2      resd    1                       ; b     
I3      resd    1                       ; c     
I4      resd    1                       ; d     
I5      resd    1                       ; e     
I6      resd    1                       ; f     
I7      resd    1                       ; g     
I8      resd    1                       ; h     
I9      resd    1                       ; i     
I10     resd    1                       ; j     
I11     resd    1                       ; k     
I12     resd    1                       ; l     
I13     resd    1                       ; m     
I14     resd    1                       ; n     
I15     resd    1                       ; o     
I16     resd    1                       ; p     
I17     resd    1                       ; q     
I18     resd    1                       ; r     
I19     resd    1                       ; s     
I0      resd    1                       ; sum   
I20     resd    1                       ; t     
I21     resd    1                       ; u     
I22     resd    1                       ; v     
I23     resd    1                       ; w     
I24     resd    1                       ; x     
I25     resd    1                       ; y     
I26     resd    1                       ; z     

./output/124.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no124

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at a
        call    ReadInt                 ; read int; value placed in eax
        mov     [I2],eax                ; store eax at b
        call    ReadInt                 ; read int; value placed in eax
        mov     [I3],eax                ; store eax at c
        call    ReadInt                 ; read int; value placed in eax
        mov     [I4],eax                ; store eax at d
        call    ReadInt                 ; read int; value placed in eax
        mov     [I5],eax                ; store eax at e
        call    ReadInt                 ; read int; value placed in eax
        mov     [I6],eax                ; store eax at f
        call    ReadInt                 ; read int; value placed in eax
        mov     [I7],eax                ; store eax at g
        call    ReadInt                 ; read int; value placed in eax
        mov     [I8],eax                ; store eax at h
        call    ReadInt                 ; read int; value placed in eax
        mov     [I9],eax                ; store eax at i
        call    ReadInt                 ; read int; value placed in eax
        mov     [I10],eax               ; store eax at j
        call    ReadInt                 ; read int; value placed in eax
        mov     [I11],eax               ; store eax at k
        call    ReadInt                 ; read int; value placed in eax
        mov     [I12],eax               ; store eax at l
        call    ReadInt                 ; read int; value placed in eax
        mov     [I13],eax               ; store eax at m
        call    ReadInt                 ; read int; value placed in eax
        mov     [I14],eax               ; store eax at n
        mov     eax,[I13]               ; AReg = m
        sub     eax,[I14]               ; AReg = m - n
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I12]               ; AReg = l
        sub     eax,[T0]                ; AReg = l - T0
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I11]               ; AReg = k
        sub     eax,[T0]                ; AReg = k - T0
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I10]               ; AReg = j
        sub     eax,[T0]                ; AReg = j - T0
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I9]                ; AReg = i
        sub     eax,[T0]                ; AReg = i - T0
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I8]                ; AReg = h
        sub     eax,[T0]                ; AReg = h - T0
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I7]                ; AReg = g
        sub     eax,[T0]                ; AReg = g - T0
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I6]                ; AReg = f
        sub     eax,[T0]                ; AReg = f - T0
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I5]                ; AReg = e
        sub     eax,[T0]                ; AReg = e - T0
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I4]                ; AReg = d
        sub     eax,[T0]                ; AReg = d - T0
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I3]                ; AReg = c
        sub     eax,[T0]                ; AReg = c - T0
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I2]                ; AReg = b
        sub     eax,[T0]                ; AReg = b - T0
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I1]                ; AReg = a
        sub     eax,[T0]                ; AReg = a - T0
        mov     [I0],eax                ; sum = AReg
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                            
SECTION .data                                   

SECTION .bss                                    
T0      resd    1                       ; T0    
I1      resd    1                       ; a     
I2      resd    1                       ; b     
I3      resd    1                       ; c     
I4      resd    1                       ; d     
I5      resd    1                       ; e     
I6      resd    1                       ; f     
I7      resd    1                       ; g     
I8      resd    1                       ; h     
I9      resd    1                       ; i     
I10     resd    1                       ; j     
I11     resd    1                       ; k     
I12     resd    1                       ; l     
I13     resd    1                       ; m     
I14     resd    1                       ; n     
I0      resd    1                       ; sum   

./output/125.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no125

_start:                                         

./output/126.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no126

_start:                                         

./output/127.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no127

_start:                                         

./output/128.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no128

_start:                                         

./output/129.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no129

_start:                                         

./output/130.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no130

_start:                                         
        mov     eax,[I0]                ; load one in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out

./output/131.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no131

_start:                                         

./output/132.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no132

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I0],eax                ; store eax at a
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at b
        cmp     eax,[I0]                ; compare b and a
        jne     .L0                     ; if a <> b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                            
        mov     [B0],eax                ; c = AReg
        mov     eax,[I0]                ; load a in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I1]                ; load b in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[B0]                ; load c in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I0]                ; AReg = a
        cmp     eax,[I1]                ; compare a and b
        je      .L2                     ; if a = b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L3                     ; unconditionally jump
.L2:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L3:                                            
        mov     [B0],eax                ; c = AReg
        mov     eax,[I0]                ; load a in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I1]                ; load b in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[B0]                ; load c in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                            
SECTION .data                                   
FALSE   dd      0                       ; false 
TRUE    dd      -1                      ; true  

SECTION .bss                                    
I0      resd    1                       ; a     
I1      resd    1                       ; b     
B0      resd    1                       ; c     

./output/133.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no133

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I0],eax                ; store eax at a
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at b
        mov     eax,[I3]                ; AReg = 2
        imul    dword [I0]              ; AReg = 2 * a
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I1]                ; AReg = b
        cdq                             ; sign extend dividend from eax to edx:eax
        idiv    dword [T0]              ; AReg = b div T0
        neg     eax                     ; AReg = -AReg
        mov     [I2],eax                ; r = AReg
        mov     eax,[I0]                ; load a in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I1]                ; load b in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I2]                ; load r in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                            
SECTION .data                                   
I3      dd      2                       ; 2     

SECTION .bss                                    
T0      resd    1                       ; T0    
I0      resd    1                       ; a     
I1      resd    1                       ; b     
I2      resd    1                       ; r     

./output/134.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no134

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I0],eax                ; store eax at a
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at b
        add     eax,[I0]                ; AReg = b + a
        mov     [I2],eax                ; r = AReg
        mov     eax,[I0]                ; load a in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I1]                ; load b in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I2]                ; load r in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I0]                ; AReg = a
        add     eax,[I1]                ; AReg = a + b
        mov     [I2],eax                ; r = AReg
        mov     eax,[I0]                ; load a in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I1]                ; load b in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I2]                ; load r in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I0]                ; AReg = a
        add     eax,[I3]                ; AReg = a + 5
        mov     [I2],eax                ; r = AReg
        mov     eax,[I0]                ; load a in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I1]                ; load b in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I2]                ; load r in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                            
SECTION .data                                   
I3      dd      5                       ; 5     

SECTION .bss                                    
I0      resd    1                       ; a     
I1      resd    1                       ; b     
I2      resd    1                       ; r     

./output/135.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no135

_start:                                         
        mov     eax,[TRUE]              ; AReg = true
        mov     [B0],eax                ; a = AReg
        not     eax                     ; AReg = !AReg
        mov     [B1],eax                ; b = AReg
        mov     eax,[B0]                ; load a in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[B1]                ; load b in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[FALSE]             ; AReg = false
        mov     [B1],eax                ; b = AReg
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[TRUE]              ; AReg = true
        mov     [B1],eax                ; b = AReg
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        cmp     eax,[B0]                ; compare b and a
        je      .L0                     ; if a = b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                            
        not     eax                     ; AReg = !AReg
        mov     [B1],eax                ; b = AReg
        mov     eax,[B0]                ; load a in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[B1]                ; load b in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                            
SECTION .data                                   
FALSE   dd      0                       ; false 
TRUE    dd      -1                      ; true  

SECTION .bss                                    
B0      resd    1                       ; a     
B1      resd    1                       ; b     

./output/136.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no136

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I0],eax                ; store eax at a
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at b
        mov     eax,[I0]                ; load a in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I1]                ; load b in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        add     eax,[I0]                ; AReg = b + a
        mov     [I0],eax                ; a = AReg
        sub     eax,[I1]                ; AReg = a - b
        mov     [I1],eax                ; b = AReg
        mov     eax,[I0]                ; AReg = a
        sub     eax,[I1]                ; AReg = a - b
        mov     [I0],eax                ; a = AReg
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I1]                ; load b in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                            
SECTION .data                                   

SECTION .bss                                    
I0      resd    1                       ; a     
I1      resd    1                       ; b     

./output/137.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no137

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I0],eax                ; store eax at a
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at b
        call    ReadInt                 ; read int; value placed in eax
        mov     [I2],eax                ; store eax at c
        mov     eax,[I0]                ; load a in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I1]                ; load b in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I2]                ; load c in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I1]                ; AReg = b
        sub     eax,[I2]                ; AReg = b - c
        add     eax,[I0]                ; AReg = T0 + a
        mov     [I3],eax                ; d = AReg
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I1]                ; AReg = b
        imul    dword [I1]              ; AReg = b * b
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I4]                ; AReg = 4
        imul    dword [I0]              ; AReg = 4 * a
        imul    dword [I2]              ; AReg = T1 * c
        mov     [T1],eax                ; deassign AReg
        mov     eax,[T0]                ; AReg = T0
        sub     eax,[T1]                ; AReg = T0 - T1
        mov     [I3],eax                ; d = AReg
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                            
SECTION .data                                   
I4      dd      4                       ; 4     

SECTION .bss                                    
T0      resd    1                       ; T0    
T1      resd    1                       ; T1    
I0      resd    1                       ; a     
I1      resd    1                       ; b     
I2      resd    1                       ; c     
I3      resd    1                       ; d     

./output/138.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no138

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I0],eax                ; store eax at a
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at b
        mov     eax,[I0]                ; AReg = a
        cdq                             ; sign extend dividend from eax to edx:eax
        idiv    dword [I1]              ; AReg = a div b
        imul    dword [I1]              ; AReg = T0 * b
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I0]                ; AReg = a
        sub     eax,[T0]                ; AReg = a - T0
        mov     [I2],eax                ; c = AReg
        mov     eax,[I0]                ; AReg = a
        cdq                             ; sign extend dividend from eax to edx:eax
        idiv    dword [I1]              ; AReg = a div b
        xchg    eax,edx                 ; exchange quotient and remainder
        mov     [I3],eax                ; d = AReg
        cmp     eax,[I2]                ; compare d and c
        je      .L0                     ; if c = d then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                            
        mov     [B0],eax                ; e = AReg
        mov     eax,[I0]                ; load a in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I1]                ; load b in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I2]                ; load c in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I3]                ; load d in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[B0]                ; load e in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                            
SECTION .data                                   
FALSE   dd      0                       ; false 
TRUE    dd      -1                      ; true  

SECTION .bss                                    
T0      resd    1                       ; T0    
I0      resd    1                       ; a     
I1      resd    1                       ; b     
I2      resd    1                       ; c     
I3      resd    1                       ; d     
B0      resd    1                       ; e     

./output/139.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no139

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I0],eax                ; store eax at a
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at b
        call    ReadInt                 ; read int; value placed in eax
        mov     [I2],eax                ; store eax at c
        call    ReadInt                 ; read int; value placed in eax
        mov     [I3],eax                ; store eax at d
        call    ReadInt                 ; read int; value placed in eax
        mov     [I4],eax                ; store eax at e
        call    ReadInt                 ; read int; value placed in eax
        mov     [I5],eax                ; store eax at f
        mov     eax,[I0]                ; AReg = a
        cdq                             ; sign extend dividend from eax to edx:eax
        idiv    dword [I1]              ; AReg = a div b
        xchg    eax,edx                 ; exchange quotient and remainder
        imul    dword [I2]              ; AReg = T0 * c
        cdq                             ; sign extend dividend from eax to edx:eax
        idiv    dword [I3]              ; AReg = T0 div d
        sub     eax,[I4]                ; AReg = T0 - e
        add     eax,[I5]                ; AReg = T0 + f
        mov     [I6],eax                ; g = AReg
        mov     eax,[I0]                ; load a in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I1]                ; load b in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I2]                ; load c in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I3]                ; load d in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I4]                ; load e in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I5]                ; load f in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I6]                ; load g in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                            
SECTION .data                                   

SECTION .bss                                    
I0      resd    1                       ; a     
I1      resd    1                       ; b     
I2      resd    1                       ; c     
I3      resd    1                       ; d     
I4      resd    1                       ; e     
I5      resd    1                       ; f     
I6      resd    1                       ; g     

./output/140.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no140

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I0],eax                ; store eax at a
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at b
        call    ReadInt                 ; read int; value placed in eax
        mov     [I2],eax                ; store eax at c
        call    ReadInt                 ; read int; value placed in eax
        mov     [I3],eax                ; store eax at d
        call    ReadInt                 ; read int; value placed in eax
        mov     [I4],eax                ; store eax at e
        call    ReadInt                 ; read int; value placed in eax
        mov     [I5],eax                ; store eax at f
        add     eax,[I4]                ; AReg = f + e
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I3]                ; AReg = d
        sub     eax,[T0]                ; AReg = d - T0
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I2]                ; AReg = c
        cdq                             ; sign extend dividend from eax to edx:eax
        idiv    dword [T0]              ; AReg = c div T0
        imul    dword [I1]              ; AReg = T0 * b
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I0]                ; AReg = a
        cdq                             ; sign extend dividend from eax to edx:eax
        idiv    dword [T0]              ; AReg = a div T0
        xchg    eax,edx                 ; exchange quotient and remainder
        mov     [I6],eax                ; g = AReg
        mov     eax,[I0]                ; load a in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I1]                ; load b in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I2]                ; load c in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I3]                ; load d in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I4]                ; load e in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I5]                ; load f in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I6]                ; load g in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                            
SECTION .data                                   

SECTION .bss                                    
T0      resd    1                       ; T0    
I0      resd    1                       ; a     
I1      resd    1                       ; b     
I2      resd    1                       ; c     
I3      resd    1                       ; d     
I4      resd    1                       ; e     
I5      resd    1                       ; f     
I6      resd    1                       ; g     

./output/141.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no141

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I0],eax                ; store eax at aaaaaaaaaaaaaaa
        call    ReadInt                 ; read int; value placed in eax
        mov     [I0],eax                ; store eax at aaaaaaaaaaaaaaa
        call    ReadInt                 ; read int; value placed in eax
        mov     [I0],eax                ; store eax at aaaaaaaaaaaaaaa
        add     eax,[I0]                ; AReg = aaaaaaaaaaaaaaa + aaaaaaaaaaaaaaa
        mov     [I0],eax                ; aaaaaaaaaaaaaaa = AReg
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                            
SECTION .data                                   

SECTION .bss                                    
I0      resd    1                       ; aaaaaaaaaaaaaaa

./output/142.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no142

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I0],eax                ; store eax at a
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at b
        call    ReadInt                 ; read int; value placed in eax
        mov     [I2],eax                ; store eax at c
        call    ReadInt                 ; read int; value placed in eax
        mov     [I3],eax                ; store eax at d
        call    ReadInt                 ; read int; value placed in eax
        mov     [I4],eax                ; store eax at e
        call    ReadInt                 ; read int; value placed in eax
        mov     [I5],eax                ; store eax at f
        add     eax,[I4]                ; AReg = f + e
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I3]                ; AReg = d
        sub     eax,[T0]                ; AReg = d - T0
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I2]                ; AReg = c
        cdq                             ; sign extend dividend from eax to edx:eax
        idiv    dword [T0]              ; AReg = c div T0
        imul    dword [I1]              ; AReg = T0 * b

./output/143.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no143

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I0],eax                ; store eax at a
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at b
        call    ReadInt                 ; read int; value placed in eax
        mov     [I2],eax                ; store eax at c
        call    ReadInt                 ; read int; value placed in eax
        mov     [I3],eax                ; store eax at d
        call    ReadInt                 ; read int; value placed in eax
        mov     [I4],eax                ; store eax at e
        call    ReadInt                 ; read int; value placed in eax
        mov     [I5],eax                ; store eax at f

./output/144.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program dwwtest1

_start:                                         
        mov     eax,[I0]                ; AReg = a
        add     eax,[I1]                ; AReg = a + b
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I2]                ; AReg = c
        add     eax,[I3]                ; AReg = c + d
        mov     [T1],eax                ; deassign AReg
        mov     eax,[I4]                ; AReg = e
        add     eax,[I5]                ; AReg = e + f
        mov     [T2],eax                ; deassign AReg
        mov     eax,[I6]                ; AReg = g
        add     eax,[I7]                ; AReg = g + h
        mov     [T3],eax                ; deassign AReg
        mov     eax,[I8]                ; AReg = i
        add     eax,[I9]                ; AReg = i + j
        mov     [T4],eax                ; deassign AReg
        mov     eax,[I10]               ; AReg = k
        add     eax,[I11]               ; AReg = k + l
        mov     [T5],eax                ; deassign AReg
        mov     eax,[I12]               ; AReg = m
        add     eax,[I13]               ; AReg = m + n
        mov     [T6],eax                ; deassign AReg
        mov     eax,[I14]               ; AReg = o
        add     eax,[I15]               ; AReg = o + p
        mov     [T7],eax                ; deassign AReg
        mov     eax,[I16]               ; AReg = q
        add     eax,[I17]               ; AReg = q + r
        mov     [T8],eax                ; deassign AReg
        mov     eax,[I18]               ; AReg = s
        add     eax,[I19]               ; AReg = s + t
        mov     [T9],eax                ; deassign AReg
        mov     eax,[I20]               ; AReg = u
        add     eax,[I21]               ; AReg = u + v
        mov     [T10],eax               ; deassign AReg
        mov     eax,[I22]               ; AReg = w
        add     eax,[I23]               ; AReg = w + x
        mov     [T11],eax               ; deassign AReg
        mov     eax,[I24]               ; AReg = y
        add     eax,[I25]               ; AReg = y + z
        add     eax,[T11]               ; AReg = T12 + T11
        add     eax,[T10]               ; AReg = T11 + T10
        add     eax,[T9]                ; AReg = T10 + T9
        add     eax,[T8]                ; AReg = T9 + T8
        add     eax,[T7]                ; AReg = T8 + T7
        add     eax,[T6]                ; AReg = T7 + T6
        add     eax,[T5]                ; AReg = T6 + T5
        add     eax,[T4]                ; AReg = T5 + T4
        add     eax,[T3]                ; AReg = T4 + T3
        add     eax,[T2]                ; AReg = T3 + T2
        add     eax,[T1]                ; AReg = T2 + T1
        add     eax,[T0]                ; AReg = T1 + T0
        mov     [I26],eax               ; sum1 = AReg
        mov     eax,[I1]                ; AReg = b
        imul    dword [I2]              ; AReg = b * c
        add     eax,[I0]                ; AReg = T0 + a
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I3]                ; AReg = d
        imul    dword [I4]              ; AReg = d * e
        add     eax,[T0]                ; AReg = T1 + T0
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I5]                ; AReg = f
        imul    dword [I6]              ; AReg = f * g
        add     eax,[T0]                ; AReg = T1 + T0
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I7]                ; AReg = h
        imul    dword [I8]              ; AReg = h * i
        add     eax,[T0]                ; AReg = T1 + T0
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I9]                ; AReg = j
        imul    dword [I10]             ; AReg = j * k
        add     eax,[T0]                ; AReg = T1 + T0
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I11]               ; AReg = l
        imul    dword [I12]             ; AReg = l * m
        add     eax,[T0]                ; AReg = T1 + T0
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I13]               ; AReg = n
        imul    dword [I14]             ; AReg = n * o
        add     eax,[T0]                ; AReg = T1 + T0
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I15]               ; AReg = p
        imul    dword [I16]             ; AReg = p * q
        add     eax,[T0]                ; AReg = T1 + T0
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I17]               ; AReg = r
        imul    dword [I18]             ; AReg = r * s
        add     eax,[T0]                ; AReg = T1 + T0
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I19]               ; AReg = t
        imul    dword [I20]             ; AReg = t * u
        add     eax,[T0]                ; AReg = T1 + T0
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I21]               ; AReg = v
        imul    dword [I22]             ; AReg = v * w
        add     eax,[T0]                ; AReg = T1 + T0
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I23]               ; AReg = x
        imul    dword [I24]             ; AReg = x * y
        add     eax,[T0]                ; AReg = T1 + T0
        add     eax,[I25]               ; AReg = T0 + z
        mov     [I27],eax               ; sum2 = AReg
        mov     eax,[I0]                ; AReg = a
        add     eax,[I1]                ; AReg = a + b
        add     eax,[I2]                ; AReg = T0 + c
        add     eax,[I3]                ; AReg = T0 + d
        add     eax,[I4]                ; AReg = T0 + e
        add     eax,[I5]                ; AReg = T0 + f
        add     eax,[I6]                ; AReg = T0 + g
        add     eax,[I7]                ; AReg = T0 + h
        add     eax,[I8]                ; AReg = T0 + i
        add     eax,[I9]                ; AReg = T0 + j
        add     eax,[I10]               ; AReg = T0 + k
        add     eax,[I11]               ; AReg = T0 + l
        add     eax,[I12]               ; AReg = T0 + m
        add     eax,[I13]               ; AReg = T0 + n
        add     eax,[I14]               ; AReg = T0 + o
        add     eax,[I15]               ; AReg = T0 + p
        add     eax,[I16]               ; AReg = T0 + q
        add     eax,[I17]               ; AReg = T0 + r
        add     eax,[I18]               ; AReg = T0 + s
        add     eax,[I19]               ; AReg = T0 + t
        add     eax,[I20]               ; AReg = T0 + u
        add     eax,[I21]               ; AReg = T0 + v
        add     eax,[I22]               ; AReg = T0 + w
        add     eax,[I23]               ; AReg = T0 + x
        add     eax,[I24]               ; AReg = T0 + y
        add     eax,[I25]               ; AReg = T0 + z
        mov     [I28],eax               ; sum3 = AReg
        mov     eax,[I0]                ; AReg = a
        neg     eax                     ; AReg = -AReg
        add     eax,[I1]                ; AReg = T0 + b
        neg     eax                     ; AReg = -AReg
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I3]                ; AReg = d
        neg     eax                     ; AReg = -AReg
        add     eax,[I2]                ; AReg = T1 + c
        imul    dword [T0]              ; AReg = T1 * T0
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I4]                ; AReg = e
        sub     eax,[I5]                ; AReg = e - f
        neg     eax                     ; AReg = -AReg
        imul    dword [T0]              ; AReg = T1 * T0
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I6]                ; AReg = g
        neg     eax                     ; AReg = -AReg
        mov     [T1],eax                ; deassign AReg
        mov     eax,[I7]                ; AReg = h
        neg     eax                     ; AReg = -AReg
        mov     [T2],eax                ; deassign AReg
        mov     eax,[T1]                ; AReg = T1
        sub     eax,[T2]                ; AReg = T1 - T2
        imul    dword [T0]              ; AReg = T1 * T0
        mov     [I29],eax               ; sum4 = AReg
        mov     eax,[I0]                ; AReg = a
        neg     eax                     ; AReg = -AReg
        neg     eax                     ; AReg = -AReg
        neg     eax                     ; AReg = -AReg
        neg     eax                     ; AReg = -AReg
        neg     eax                     ; AReg = -AReg
        neg     eax                     ; AReg = -AReg
        mov     [I30],eax               ; sum5 = AReg
        mov     eax,[I0]                ; AReg = a
        cmp     eax,[I1]                ; compare a and b
        je      .L0                     ; if a = b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                            
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I2]                ; AReg = c
        cmp     eax,[I3]                ; compare c and d
        jl      .L2                     ; if c < d then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L3                     ; unconditionally jump
.L2:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L3:                                            
        or      eax,[T0]                ; AReg = T1 or T0
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I4]                ; AReg = e
        cmp     eax,[I5]                ; compare e and f
        jle     .L4                     ; if e <= f then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L5                     ; unconditionally jump
.L4:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L5:                                            
        or      eax,[T0]                ; AReg = T1 or T0
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I6]                ; AReg = g
        cmp     eax,[I7]                ; compare g and h
        jg      .L6                     ; if g > h then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L7                     ; unconditionally jump
.L6:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L7:                                            
        or      eax,[T0]                ; AReg = T1 or T0
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I8]                ; AReg = i
        cmp     eax,[I9]                ; compare i and j
        jge     .L8                     ; if i >= j then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L9                     ; unconditionally jump
.L8:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L9:                                            
        or      eax,[T0]                ; AReg = T1 or T0
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I10]               ; AReg = k
        cmp     eax,[I11]               ; compare k and l
        jne     .L10                    ; if k <> l then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L11                    ; unconditionally jump
.L10:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L11:                                           
        or      eax,[T0]                ; AReg = T1 or T0
        mov     [B0],eax                ; aa = AReg
        cmp     eax,[B1]                ; compare aa and bb
        je      .L12                    ; if aa = bb then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L13                    ; unconditionally jump
.L12:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L13:                                           
        mov     [T0],eax                ; deassign AReg
        mov     eax,[B2]                ; AReg = cc
        cmp     eax,[B3]                ; compare cc and dd
        jne     .L14                    ; if cc <> dd then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L15                    ; unconditionally jump
.L14:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L15:                                           
        and     eax,[T0]                ; AReg = T1 and T0
        mov     [B1],eax                ; bb = AReg
        mov     eax,[B0]                ; AReg = aa
        not     eax                     ; AReg = !AReg
        mov     [T0],eax                ; deassign AReg
        mov     eax,[B1]                ; AReg = bb
        not     eax                     ; AReg = !AReg
        cmp     eax,[T0]                ; compare T1 and T0
        je      .L16                    ; if T0 = T1 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L17                    ; unconditionally jump
.L16:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L17:                                           
        not     eax                     ; AReg = !AReg
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I2]                ; AReg = c
        cmp     eax,[I3]                ; compare c and d
        jl      .L18                    ; if c < d then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L19                    ; unconditionally jump
.L18:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L19:                                           
        not     eax                     ; AReg = !AReg
        and     eax,[T0]                ; AReg = T1 and T0
        mov     [B2],eax                ; cc = AReg
        mov     eax,[B0]                ; AReg = aa
        not     eax                     ; AReg = !AReg
        not     eax                     ; AReg = !AReg
        not     eax                     ; AReg = !AReg
        not     eax                     ; AReg = !AReg
        mov     [B3],eax                ; dd = AReg
        Exit    {0}
                            
SECTION .data                                   
FALSE   dd      0                       ; false 
TRUE    dd      -1                      ; true  

SECTION .bss                                    
T0      resd    1                       ; T0    
T1      resd    1                       ; T1    
T10     resd    1                       ; T10   
T11     resd    1                       ; T11   
T2      resd    1                       ; T2    
T3      resd    1                       ; T3    
T4      resd    1                       ; T4    
T5      resd    1                       ; T5    
T6      resd    1                       ; T6    
T7      resd    1                       ; T7    
T8      resd    1                       ; T8    
T9      resd    1                       ; T9    
I0      resd    1                       ; a     
B0      resd    1                       ; aa    
I1      resd    1                       ; b     
B1      resd    1                       ; bb    
I2      resd    1                       ; c     
B2      resd    1                       ; cc    
I3      resd    1                       ; d     
B3      resd    1                       ; dd    
I4      resd    1                       ; e     
I5      resd    1                       ; f     
I6      resd    1                       ; g     
I7      resd    1                       ; h     
I8      resd    1                       ; i     
I9      resd    1                       ; j     
I10     resd    1                       ; k     
I11     resd    1                       ; l     
I12     resd    1                       ; m     
I13     resd    1                       ; n     
I14     resd    1                       ; o     
I15     resd    1                       ; p     
I16     resd    1                       ; q     
I17     resd    1                       ; r     
I18     resd    1                       ; s     
I26     resd    1                       ; sum1  
I27     resd    1                       ; sum2  
I28     resd    1                       ; sum3  
I29     resd    1                       ; sum4  
I30     resd    1                       ; sum5  
I19     resd    1                       ; t     
I20     resd    1                       ; u     
I21     resd    1                       ; v     
I22     resd    1                       ; w     
I23     resd    1                       ; x     
I24     resd    1                       ; y     
I25     resd    1                       ; z     

./output/145.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no145

_start:                                         
        Exit    {0}
                            
SECTION .data                                   

SECTION .bss                                    
I0      resd    1                       ; var000
I1      resd    1                       ; var001
I2      resd    1                       ; var002
I3      resd    1                       ; var003
I4      resd    1                       ; var004
I5      resd    1                       ; var005
I6      resd    1                       ; var006
I7      resd    1                       ; var007
I8      resd    1                       ; var008
I9      resd    1                       ; var009
I10     resd    1                       ; var010
I11     resd    1                       ; var011
I12     resd    1                       ; var012
I13     resd    1                       ; var013
I14     resd    1                       ; var014
I15     resd    1                       ; var015
I16     resd    1                       ; var016
I17     resd    1                       ; var017
I18     resd    1                       ; var018
I19     resd    1                       ; var019
I20     resd    1                       ; var020
I21     resd    1                       ; var021
I22     resd    1                       ; var022
I23     resd    1                       ; var023
I24     resd    1                       ; var024
I25     resd    1                       ; var025
I26     resd    1                       ; var026
I27     resd    1                       ; var027
I28     resd    1                       ; var028
I29     resd    1                       ; var029
I30     resd    1                       ; var030
I31     resd    1                       ; var031
I32     resd    1                       ; var032
I33     resd    1                       ; var033
I34     resd    1                       ; var034
I35     resd    1                       ; var035
I36     resd    1                       ; var036
I37     resd    1                       ; var037
I38     resd    1                       ; var038
I39     resd    1                       ; var039
I40     resd    1                       ; var040
I41     resd    1                       ; var041
I42     resd    1                       ; var042
I43     resd    1                       ; var043
I44     resd    1                       ; var044
I45     resd    1                       ; var045
I46     resd    1                       ; var046
I47     resd    1                       ; var047
I48     resd    1                       ; var048
I49     resd    1                       ; var049
I50     resd    1                       ; var050
I51     resd    1                       ; var051
I52     resd    1                       ; var052
I53     resd    1                       ; var053
I54     resd    1                       ; var054
I55     resd    1                       ; var055
I56     resd    1                       ; var056
I57     resd    1                       ; var057
I58     resd    1                       ; var058
I59     resd    1                       ; var059
I60     resd    1                       ; var060
I61     resd    1                       ; var061
I62     resd    1                       ; var062
I63     resd    1                       ; var063
I64     resd    1                       ; var064
I65     resd    1                       ; var065
I66     resd    1                       ; var066
I67     resd    1                       ; var067
I68     resd    1                       ; var068
I69     resd    1                       ; var069
I70     resd    1                       ; var070
I71     resd    1                       ; var071
I72     resd    1                       ; var072
I73     resd    1                       ; var073
I74     resd    1                       ; var074
I75     resd    1                       ; var075
I76     resd    1                       ; var076
I77     resd    1                       ; var077
I78     resd    1                       ; var078
I79     resd    1                       ; var079
I80     resd    1                       ; var080
I81     resd    1                       ; var081
I82     resd    1                       ; var082
I83     resd    1                       ; var083
I84     resd    1                       ; var084
I85     resd    1                       ; var085
I86     resd    1                       ; var086
I87     resd    1                       ; var087
I88     resd    1                       ; var088
I89     resd    1                       ; var089
I90     resd    1                       ; var090
I91     resd    1                       ; var091
I92     resd    1                       ; var092
I93     resd    1                       ; var093
I94     resd    1                       ; var094
I95     resd    1                       ; var095
I96     resd    1                       ; var096
I97     resd    1                       ; var097
I98     resd    1                       ; var098
I99     resd    1                       ; var099
I100    resd    1                       ; var100
I101    resd    1                       ; var101
I102    resd    1                       ; var102
I103    resd    1                       ; var103
I104    resd    1                       ; var104
I105    resd    1                       ; var105
I106    resd    1                       ; var106
I107    resd    1                       ; var107
I108    resd    1                       ; var108
I109    resd    1                       ; var109
I110    resd    1                       ; var110
I111    resd    1                       ; var111
I112    resd    1                       ; var112
I113    resd    1                       ; var113
I114    resd    1                       ; var114
I115    resd    1                       ; var115
I116    resd    1                       ; var116
I117    resd    1                       ; var117
I118    resd    1                       ; var118
I119    resd    1                       ; var119
I120    resd    1                       ; var120
I121    resd    1                       ; var121
I122    resd    1                       ; var122
I123    resd    1                       ; var123
I124    resd    1                       ; var124
I125    resd    1                       ; var125
I126    resd    1                       ; var126
I127    resd    1                       ; var127
I128    resd    1                       ; var128
I129    resd    1                       ; var129
I130    resd    1                       ; var130
I131    resd    1                       ; var131
I132    resd    1                       ; var132
I133    resd    1                       ; var133
I134    resd    1                       ; var134
I135    resd    1                       ; var135
I136    resd    1                       ; var136
I137    resd    1                       ; var137
I138    resd    1                       ; var138
I139    resd    1                       ; var139
I140    resd    1                       ; var140
I141    resd    1                       ; var141
I142    resd    1                       ; var142
I143    resd    1                       ; var143
I144    resd    1                       ; var144
I145    resd    1                       ; var145
I146    resd    1                       ; var146
I147    resd    1                       ; var147
I148    resd    1                       ; var148
I149    resd    1                       ; var149
I150    resd    1                       ; var150
I151    resd    1                       ; var151
I152    resd    1                       ; var152
I153    resd    1                       ; var153
I154    resd    1                       ; var154
I155    resd    1                       ; var155
I156    resd    1                       ; var156
I157    resd    1                       ; var157
I158    resd    1                       ; var158
I159    resd    1                       ; var159
I160    resd    1                       ; var160
I161    resd    1                       ; var161
I162    resd    1                       ; var162
I163    resd    1                       ; var163
I164    resd    1                       ; var164
I165    resd    1                       ; var165
I166    resd    1                       ; var166
I167    resd    1                       ; var167
I168    resd    1                       ; var168
I169    resd    1                       ; var169
I170    resd    1                       ; var170
I171    resd    1                       ; var171
I172    resd    1                       ; var172
I173    resd    1                       ; var173
I174    resd    1                       ; var174
I175    resd    1                       ; var175
I176    resd    1                       ; var176
I177    resd    1                       ; var177
I178    resd    1                       ; var178
I179    resd    1                       ; var179
I180    resd    1                       ; var180
I181    resd    1                       ; var181
I182    resd    1                       ; var182
I183    resd    1                       ; var183
I184    resd    1                       ; var184
I185    resd    1                       ; var185
I186    resd    1                       ; var186
I187    resd    1                       ; var187
I188    resd    1                       ; var188
I189    resd    1                       ; var189
I190    resd    1                       ; var190
I191    resd    1                       ; var191
I192    resd    1                       ; var192
I193    resd    1                       ; var193
I194    resd    1                       ; var194
I195    resd    1                       ; var195
I196    resd    1                       ; var196
I197    resd    1                       ; var197
I198    resd    1                       ; var198
I199    resd    1                       ; var199
I200    resd    1                       ; var200
I201    resd    1                       ; var201
I202    resd    1                       ; var202
I203    resd    1                       ; var203
I204    resd    1                       ; var204
I205    resd    1                       ; var205
I206    resd    1                       ; var206
I207    resd    1                       ; var207
I208    resd    1                       ; var208
I209    resd    1                       ; var209
I210    resd    1                       ; var210
I211    resd    1                       ; var211
I212    resd    1                       ; var212
I213    resd    1                       ; var213
I214    resd    1                       ; var214
I215    resd    1                       ; var215
I216    resd    1                       ; var216
I217    resd    1                       ; var217
I218    resd    1                       ; var218
I219    resd    1                       ; var219
I220    resd    1                       ; var220
I221    resd    1                       ; var221
I222    resd    1                       ; var222
I223    resd    1                       ; var223
I224    resd    1                       ; var224
I225    resd    1                       ; var225
I226    resd    1                       ; var226
I227    resd    1                       ; var227
I228    resd    1                       ; var228
I229    resd    1                       ; var229
I230    resd    1                       ; var230
I231    resd    1                       ; var231
I232    resd    1                       ; var232
I233    resd    1                       ; var233
I234    resd    1                       ; var234
I235    resd    1                       ; var235
I236    resd    1                       ; var236
I237    resd    1                       ; var237
I238    resd    1                       ; var238
I239    resd    1                       ; var239
I240    resd    1                       ; var240
I241    resd    1                       ; var241
I242    resd    1                       ; var242
I243    resd    1                       ; var243
I244    resd    1                       ; var244
I245    resd    1                       ; var245
I246    resd    1                       ; var246
I247    resd    1                       ; var247
I248    resd    1                       ; var248
I249    resd    1                       ; var249
I250    resd    1                       ; var250
I251    resd    1                       ; var251
I252    resd    1                       ; var252
I253    resd    1                       ; var253
I254    resd    1                       ; var254

./output/146.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no146

_start:                                         
        mov     eax,[I4]                ; AReg = 3
        add     eax,[I5]                ; AReg = 3 + 34
        imul    dword [I0]              ; AReg = T0 * five
        mov     [I1],eax                ; a = AReg
        mov     eax,[I6]                ; AReg = -5
        cdq                             ; sign extend dividend from eax to edx:eax
        idiv    dword [I1]              ; AReg = -5 div a
        xchg    eax,edx                 ; exchange quotient and remainder
        add     eax,[I1]                ; AReg = T0 + a
        mov     [I2],eax                ; b = AReg
        add     eax,[I1]                ; AReg = b + a
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I2]                ; AReg = b
        sub     eax,[I1]                ; AReg = b - a
        imul    dword [T0]              ; AReg = T1 * T0
        mov     [I3],eax                ; c = AReg
        mov     eax,[I1]                ; load a in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I2]                ; load b in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I3]                ; load c in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                            
SECTION .data                                   
I6      dd      -5                      ; -5    
I4      dd      3                       ; 3     
I5      dd      34                      ; 34    
I0      dd      5                       ; five  

SECTION .bss                                    
T0      resd    1                       ; T0    
I1      resd    1                       ; a     
I2      resd    1                       ; b     
I3      resd    1                       ; c     

./output/147.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no147

_start:                                         
        mov     eax,[I4]                ; AReg = 3
        add     eax,[I5]                ; AReg = 3 + 34
        imul    dword [I0]              ; AReg = T0 * five
        mov     [I1],eax                ; a = AReg
        mov     eax,[I6]                ; AReg = -5
        cdq                             ; sign extend dividend from eax to edx:eax
        idiv    dword [I1]              ; AReg = -5 div a
        xchg    eax,edx                 ; exchange quotient and remainder
        add     eax,[I1]                ; AReg = T0 + a
        mov     [I2],eax                ; b = AReg
        add     eax,[I1]                ; AReg = b + a
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I2]                ; AReg = b
        sub     eax,[I1]                ; AReg = b - a
        mov     [T1],eax                ; deassign AReg
        mov     eax,[T0]                ; AReg = T0
        sub     eax,[T1]                ; AReg = T0 - T1
        mov     [I3],eax                ; c = AReg
        mov     eax,[I1]                ; load a in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I2]                ; load b in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I3]                ; load c in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                            
SECTION .data                                   
I6      dd      -5                      ; -5    
I4      dd      3                       ; 3     
I5      dd      34                      ; 34    
I0      dd      5                       ; five  

SECTION .bss                                    
T0      resd    1                       ; T0    
T1      resd    1                       ; T1    
I1      resd    1                       ; a     
I2      resd    1                       ; b     
I3      resd    1                       ; c     

./output/148.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no148

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at a
        call    ReadInt                 ; read int; value placed in eax
        mov     [I2],eax                ; store eax at b
        call    ReadInt                 ; read int; value placed in eax
        mov     [I3],eax                ; store eax at c
        mov     eax,[I1]                ; AReg = a
        cmp     eax,[I0]                ; compare a and zero
        je      .L0                     ; if a = zero then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                            
        mov     [B0],eax                ; d = AReg
        mov     eax,[I2]                ; AReg = b
        cmp     eax,[I3]                ; compare b and c
        jl      .L2                     ; if b < c then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L3                     ; unconditionally jump
.L2:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L3:                                            
        mov     [B1],eax                ; e = AReg
        mov     eax,[I1]                ; AReg = a
        cmp     eax,[I2]                ; compare a and b
        jg      .L4                     ; if a > b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L5                     ; unconditionally jump
.L4:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L5:                                            
        mov     [B2],eax                ; f = AReg
        mov     eax,[I1]                ; load a in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I2]                ; load b in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I3]                ; load c in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[B0]                ; load d in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[B1]                ; load e in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[B2]                ; load f in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                            
SECTION .data                                   
FALSE   dd      0                       ; false 
TRUE    dd      -1                      ; true  
I0      dd      0                       ; zero  

SECTION .bss                                    
I1      resd    1                       ; a     
I2      resd    1                       ; b     
I3      resd    1                       ; c     
B0      resd    1                       ; d     
B1      resd    1                       ; e     
B2      resd    1                       ; f     

./output/149.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no149

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I0],eax                ; store eax at a
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at b
        call    ReadInt                 ; read int; value placed in eax
        mov     [I2],eax                ; store eax at c
        call    ReadInt                 ; read int; value placed in eax
        mov     [I3],eax                ; store eax at d
        call    ReadInt                 ; read int; value placed in eax
        mov     [I4],eax                ; store eax at e
        call    ReadInt                 ; read int; value placed in eax
        mov     [I5],eax                ; store eax at f
        mov     eax,[I0]                ; AReg = a
        add     eax,[I1]                ; AReg = a + b
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I2]                ; AReg = c
        add     eax,[I3]                ; AReg = c + d
        mov     [T1],eax                ; deassign AReg
        mov     eax,[I4]                ; AReg = e
        add     eax,[I5]                ; AReg = e + f
        add     eax,[T1]                ; AReg = T2 + T1
        add     eax,[T0]                ; AReg = T1 + T0
        mov     [I0],eax                ; a = AReg
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                            
SECTION .data                                   

SECTION .bss                                    
T0      resd    1                       ; T0    
T1      resd    1                       ; T1    
I0      resd    1                       ; a     
I1      resd    1                       ; b     
I2      resd    1                       ; c     
I3      resd    1                       ; d     
I4      resd    1                       ; e     
I5      resd    1                       ; f     

./output/150.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no150

_start:                                         

./output/151.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no151

_start:                                         
        mov     eax,[TRUE]              ; AReg = true
        mov     [B1],eax                ; b = AReg
        mov     eax,[FALSE]             ; AReg = false
        mov     [B2],eax                ; c = AReg
        mov     eax,[TRUE]              ; AReg = true
        mov     [B0],eax                ; a = AReg
        mov     eax,[B1]                ; AReg = b
        cmp     eax,[B2]                ; compare b and c
        je      .L0                     ; if b = c then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                            
        cmp     eax,[B0]                ; compare T0 and a
        je      .L2                     ; if T0 = a then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L3                     ; unconditionally jump
.L2:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L3:                                            
        mov     [B3],eax                ; d = AReg
        mov     eax,[I1]                ; AReg = 5
        neg     eax                     ; AReg = -AReg
        mov     [I0],eax                ; e = AReg
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                            
SECTION .data                                   
I1      dd      5                       ; 5     
FALSE   dd      0                       ; false 
TRUE    dd      -1                      ; true  

SECTION .bss                                    
B0      resd    1                       ; a     
B1      resd    1                       ; b     
B2      resd    1                       ; c     
B3      resd    1                       ; d     
I0      resd    1                       ; e     

./output/152.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no152

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at a
        call    ReadInt                 ; read int; value placed in eax
        mov     [I2],eax                ; store eax at b
        call    ReadInt                 ; read int; value placed in eax
        mov     [I3],eax                ; store eax at c
        call    ReadInt                 ; read int; value placed in eax
        mov     [I4],eax                ; store eax at d
        call    ReadInt                 ; read int; value placed in eax
        mov     [I5],eax                ; store eax at e
        call    ReadInt                 ; read int; value placed in eax
        mov     [I6],eax                ; store eax at f
        call    ReadInt                 ; read int; value placed in eax
        mov     [I7],eax                ; store eax at g
        call    ReadInt                 ; read int; value placed in eax
        mov     [I8],eax                ; store eax at h
        call    ReadInt                 ; read int; value placed in eax
        mov     [I9],eax                ; store eax at i
        call    ReadInt                 ; read int; value placed in eax
        mov     [I10],eax               ; store eax at j
        call    ReadInt                 ; read int; value placed in eax
        mov     [I11],eax               ; store eax at k
        call    ReadInt                 ; read int; value placed in eax
        mov     [I12],eax               ; store eax at l
        call    ReadInt                 ; read int; value placed in eax
        mov     [I13],eax               ; store eax at m
        call    ReadInt                 ; read int; value placed in eax
        mov     [I14],eax               ; store eax at n
        call    ReadInt                 ; read int; value placed in eax
        mov     [I15],eax               ; store eax at o
        call    ReadInt                 ; read int; value placed in eax
        mov     [I16],eax               ; store eax at p
        call    ReadInt                 ; read int; value placed in eax
        mov     [I17],eax               ; store eax at q
        call    ReadInt                 ; read int; value placed in eax
        mov     [I18],eax               ; store eax at r
        call    ReadInt                 ; read int; value placed in eax
        mov     [I19],eax               ; store eax at s
        call    ReadInt                 ; read int; value placed in eax
        mov     [I20],eax               ; store eax at t
        call    ReadInt                 ; read int; value placed in eax
        mov     [I21],eax               ; store eax at u
        call    ReadInt                 ; read int; value placed in eax
        mov     [I22],eax               ; store eax at v
        mov     eax,[I1]                ; AReg = a
        add     eax,[I2]                ; AReg = a + b
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I3]                ; AReg = c
        add     eax,[I4]                ; AReg = c + d
        mov     [T1],eax                ; deassign AReg
        mov     eax,[I5]                ; AReg = e
        add     eax,[I6]                ; AReg = e + f
        mov     [T2],eax                ; deassign AReg
        mov     eax,[I7]                ; AReg = g
        add     eax,[I8]                ; AReg = g + h
        mov     [T3],eax                ; deassign AReg
        mov     eax,[I9]                ; AReg = i
        add     eax,[I10]               ; AReg = i + j
        mov     [T4],eax                ; deassign AReg
        mov     eax,[I11]               ; AReg = k
        add     eax,[I12]               ; AReg = k + l
        mov     [T5],eax                ; deassign AReg
        mov     eax,[I13]               ; AReg = m
        add     eax,[I14]               ; AReg = m + n
        mov     [T6],eax                ; deassign AReg
        mov     eax,[I15]               ; AReg = o
        add     eax,[I16]               ; AReg = o + p
        mov     [T7],eax                ; deassign AReg
        mov     eax,[I17]               ; AReg = q
        add     eax,[I18]               ; AReg = q + r
        mov     [T8],eax                ; deassign AReg
        mov     eax,[I19]               ; AReg = s
        add     eax,[I20]               ; AReg = s + t
        mov     [T9],eax                ; deassign AReg
        mov     eax,[I21]               ; AReg = u
        add     eax,[I22]               ; AReg = u + v
        mov     [T10],eax               ; deassign AReg
        mov     eax,[I3]                ; AReg = c
        add     eax,[I4]                ; AReg = c + d
        mov     [T11],eax               ; deassign AReg
        mov     eax,[I5]                ; AReg = e
        add     eax,[I6]                ; AReg = e + f
        mov     [T12],eax               ; deassign AReg
        mov     eax,[I7]                ; AReg = g
        add     eax,[I8]                ; AReg = g + h
        mov     [T13],eax               ; deassign AReg
        mov     eax,[I9]                ; AReg = i
        add     eax,[I10]               ; AReg = i + j
        mov     [T14],eax               ; deassign AReg
        mov     eax,[I11]               ; AReg = k
        add     eax,[I12]               ; AReg = k + l
        mov     [T15],eax               ; deassign AReg
        mov     eax,[I13]               ; AReg = m
        add     eax,[I14]               ; AReg = m + n
        mov     [T16],eax               ; deassign AReg
        mov     eax,[I15]               ; AReg = o
        add     eax,[I16]               ; AReg = o + p
        mov     [T17],eax               ; deassign AReg
        mov     eax,[I17]               ; AReg = q
        add     eax,[I18]               ; AReg = q + r
        mov     [T18],eax               ; deassign AReg
        mov     eax,[I19]               ; AReg = s
        add     eax,[I20]               ; AReg = s + t
        mov     [T19],eax               ; deassign AReg
        mov     eax,[I21]               ; AReg = u
        add     eax,[I22]               ; AReg = u + v
        mov     [T20],eax               ; deassign AReg
        mov     eax,[I3]                ; AReg = c
        add     eax,[I4]                ; AReg = c + d
        mov     [T21],eax               ; deassign AReg
        mov     eax,[I5]                ; AReg = e
        add     eax,[I6]                ; AReg = e + f
        mov     [T22],eax               ; deassign AReg
        mov     eax,[I7]                ; AReg = g
        add     eax,[I8]                ; AReg = g + h
        mov     [T23],eax               ; deassign AReg
        mov     eax,[I9]                ; AReg = i
        add     eax,[I10]               ; AReg = i + j
        mov     [T24],eax               ; deassign AReg
        mov     eax,[I11]               ; AReg = k
        add     eax,[I12]               ; AReg = k + l
        mov     [T25],eax               ; deassign AReg
        mov     eax,[I13]               ; AReg = m
        add     eax,[I14]               ; AReg = m + n
        mov     [T26],eax               ; deassign AReg
        mov     eax,[I15]               ; AReg = o
        add     eax,[I16]               ; AReg = o + p
        mov     [T27],eax               ; deassign AReg
        mov     eax,[I17]               ; AReg = q
        add     eax,[I18]               ; AReg = q + r
        mov     [T28],eax               ; deassign AReg
        mov     eax,[I19]               ; AReg = s
        add     eax,[I20]               ; AReg = s + t
        mov     [T29],eax               ; deassign AReg
        mov     eax,[I21]               ; AReg = u
        add     eax,[I22]               ; AReg = u + v
        mov     [T30],eax               ; deassign AReg
        mov     eax,[I3]                ; AReg = c
        add     eax,[I4]                ; AReg = c + d
        mov     [T31],eax               ; deassign AReg
        mov     eax,[I5]                ; AReg = e
        add     eax,[I6]                ; AReg = e + f
        mov     [T32],eax               ; deassign AReg
        mov     eax,[I7]                ; AReg = g
        add     eax,[I8]                ; AReg = g + h
        mov     [T33],eax               ; deassign AReg
        mov     eax,[I9]                ; AReg = i
        add     eax,[I10]               ; AReg = i + j
        mov     [T34],eax               ; deassign AReg
        mov     eax,[I11]               ; AReg = k
        add     eax,[I12]               ; AReg = k + l
        mov     [T35],eax               ; deassign AReg
        mov     eax,[I13]               ; AReg = m
        add     eax,[I14]               ; AReg = m + n
        mov     [T36],eax               ; deassign AReg
        mov     eax,[I15]               ; AReg = o
        add     eax,[I16]               ; AReg = o + p
        mov     [T37],eax               ; deassign AReg
        mov     eax,[I17]               ; AReg = q
        add     eax,[I18]               ; AReg = q + r
        mov     [T38],eax               ; deassign AReg
        mov     eax,[I19]               ; AReg = s
        add     eax,[I20]               ; AReg = s + t
        mov     [T39],eax               ; deassign AReg
        mov     eax,[I21]               ; AReg = u
        add     eax,[I22]               ; AReg = u + v
        mov     [T40],eax               ; deassign AReg
        mov     eax,[I3]                ; AReg = c
        add     eax,[I4]                ; AReg = c + d
        mov     [T41],eax               ; deassign AReg
        mov     eax,[I5]                ; AReg = e
        add     eax,[I6]                ; AReg = e + f
        mov     [T42],eax               ; deassign AReg
        mov     eax,[I7]                ; AReg = g
        add     eax,[I8]                ; AReg = g + h
        mov     [T43],eax               ; deassign AReg
        mov     eax,[I9]                ; AReg = i
        add     eax,[I10]               ; AReg = i + j
        mov     [T44],eax               ; deassign AReg
        mov     eax,[I11]               ; AReg = k
        add     eax,[I12]               ; AReg = k + l
        mov     [T45],eax               ; deassign AReg
        mov     eax,[I13]               ; AReg = m
        add     eax,[I14]               ; AReg = m + n
        mov     [T46],eax               ; deassign AReg
        mov     eax,[I15]               ; AReg = o
        add     eax,[I16]               ; AReg = o + p
        mov     [T47],eax               ; deassign AReg
        mov     eax,[I17]               ; AReg = q
        add     eax,[I18]               ; AReg = q + r
        mov     [T48],eax               ; deassign AReg
        mov     eax,[I19]               ; AReg = s
        add     eax,[I20]               ; AReg = s + t
        mov     [T49],eax               ; deassign AReg
        mov     eax,[I21]               ; AReg = u
        add     eax,[I22]               ; AReg = u + v
        mov     [T50],eax               ; deassign AReg
        mov     eax,[I3]                ; AReg = c
        add     eax,[I4]                ; AReg = c + d
        mov     [T51],eax               ; deassign AReg
        mov     eax,[I5]                ; AReg = e
        add     eax,[I6]                ; AReg = e + f
        mov     [T52],eax               ; deassign AReg
        mov     eax,[I7]                ; AReg = g
        add     eax,[I8]                ; AReg = g + h
        mov     [T53],eax               ; deassign AReg
        mov     eax,[I9]                ; AReg = i
        add     eax,[I10]               ; AReg = i + j
        mov     [T54],eax               ; deassign AReg
        mov     eax,[I11]               ; AReg = k
        add     eax,[I12]               ; AReg = k + l
        mov     [T55],eax               ; deassign AReg
        mov     eax,[I13]               ; AReg = m
        add     eax,[I14]               ; AReg = m + n
        mov     [T56],eax               ; deassign AReg
        mov     eax,[I15]               ; AReg = o
        add     eax,[I16]               ; AReg = o + p
        mov     [T57],eax               ; deassign AReg
        mov     eax,[I17]               ; AReg = q
        add     eax,[I18]               ; AReg = q + r
        mov     [T58],eax               ; deassign AReg
        mov     eax,[I19]               ; AReg = s
        add     eax,[I20]               ; AReg = s + t
        mov     [T59],eax               ; deassign AReg
        mov     eax,[I21]               ; AReg = u
        add     eax,[I22]               ; AReg = u + v
        mov     [T60],eax               ; deassign AReg
        mov     eax,[I3]                ; AReg = c
        add     eax,[I4]                ; AReg = c + d
        mov     [T61],eax               ; deassign AReg
        mov     eax,[I5]                ; AReg = e
        add     eax,[I6]                ; AReg = e + f
        mov     [T62],eax               ; deassign AReg
        mov     eax,[I7]                ; AReg = g
        add     eax,[I8]                ; AReg = g + h
        mov     [T63],eax               ; deassign AReg
        mov     eax,[I9]                ; AReg = i
        add     eax,[I10]               ; AReg = i + j
        mov     [T64],eax               ; deassign AReg
        mov     eax,[I11]               ; AReg = k
        add     eax,[I12]               ; AReg = k + l
        mov     [T65],eax               ; deassign AReg
        mov     eax,[I13]               ; AReg = m
        add     eax,[I14]               ; AReg = m + n
        mov     [T66],eax               ; deassign AReg
        mov     eax,[I15]               ; AReg = o
        add     eax,[I16]               ; AReg = o + p
        mov     [T67],eax               ; deassign AReg
        mov     eax,[I17]               ; AReg = q
        add     eax,[I18]               ; AReg = q + r
        mov     [T68],eax               ; deassign AReg
        mov     eax,[I19]               ; AReg = s
        add     eax,[I20]               ; AReg = s + t
        mov     [T69],eax               ; deassign AReg
        mov     eax,[I21]               ; AReg = u
        add     eax,[I22]               ; AReg = u + v
        mov     [T70],eax               ; deassign AReg
        mov     eax,[I3]                ; AReg = c
        add     eax,[I4]                ; AReg = c + d
        mov     [T71],eax               ; deassign AReg
        mov     eax,[I5]                ; AReg = e
        add     eax,[I6]                ; AReg = e + f
        mov     [T72],eax               ; deassign AReg
        mov     eax,[I7]                ; AReg = g
        add     eax,[I8]                ; AReg = g + h
        mov     [T73],eax               ; deassign AReg
        mov     eax,[I9]                ; AReg = i
        add     eax,[I10]               ; AReg = i + j
        mov     [T74],eax               ; deassign AReg
        mov     eax,[I11]               ; AReg = k
        add     eax,[I12]               ; AReg = k + l
        mov     [T75],eax               ; deassign AReg
        mov     eax,[I13]               ; AReg = m
        add     eax,[I14]               ; AReg = m + n
        mov     [T76],eax               ; deassign AReg
        mov     eax,[I15]               ; AReg = o
        add     eax,[I16]               ; AReg = o + p
        mov     [T77],eax               ; deassign AReg
        mov     eax,[I17]               ; AReg = q
        add     eax,[I18]               ; AReg = q + r
        mov     [T78],eax               ; deassign AReg
        mov     eax,[I19]               ; AReg = s
        add     eax,[I20]               ; AReg = s + t
        mov     [T79],eax               ; deassign AReg
        mov     eax,[I21]               ; AReg = u
        add     eax,[I22]               ; AReg = u + v
        mov     [T80],eax               ; deassign AReg
        mov     eax,[I3]                ; AReg = c
        add     eax,[I4]                ; AReg = c + d
        mov     [T81],eax               ; deassign AReg
        mov     eax,[I5]                ; AReg = e
        add     eax,[I6]                ; AReg = e + f
        mov     [T82],eax               ; deassign AReg
        mov     eax,[I7]                ; AReg = g
        add     eax,[I8]                ; AReg = g + h
        mov     [T83],eax               ; deassign AReg
        mov     eax,[I9]                ; AReg = i
        add     eax,[I10]               ; AReg = i + j
        mov     [T84],eax               ; deassign AReg
        mov     eax,[I11]               ; AReg = k
        add     eax,[I12]               ; AReg = k + l
        mov     [T85],eax               ; deassign AReg
        mov     eax,[I13]               ; AReg = m
        add     eax,[I14]               ; AReg = m + n
        mov     [T86],eax               ; deassign AReg
        mov     eax,[I15]               ; AReg = o
        add     eax,[I16]               ; AReg = o + p
        mov     [T87],eax               ; deassign AReg
        mov     eax,[I17]               ; AReg = q
        add     eax,[I18]               ; AReg = q + r
        mov     [T88],eax               ; deassign AReg
        mov     eax,[I19]               ; AReg = s
        add     eax,[I20]               ; AReg = s + t
        mov     [T89],eax               ; deassign AReg
        mov     eax,[I21]               ; AReg = u
        add     eax,[I22]               ; AReg = u + v
        mov     [T90],eax               ; deassign AReg
        mov     eax,[I3]                ; AReg = c
        add     eax,[I4]                ; AReg = c + d
        mov     [T91],eax               ; deassign AReg
        mov     eax,[I5]                ; AReg = e
        add     eax,[I6]                ; AReg = e + f
        mov     [T92],eax               ; deassign AReg
        mov     eax,[I7]                ; AReg = g
        add     eax,[I8]                ; AReg = g + h
        mov     [T93],eax               ; deassign AReg
        mov     eax,[I9]                ; AReg = i
        add     eax,[I10]               ; AReg = i + j
        mov     [T94],eax               ; deassign AReg
        mov     eax,[I11]               ; AReg = k
        add     eax,[I12]               ; AReg = k + l
        mov     [T95],eax               ; deassign AReg
        mov     eax,[I13]               ; AReg = m
        add     eax,[I14]               ; AReg = m + n
        mov     [T96],eax               ; deassign AReg
        mov     eax,[I15]               ; AReg = o
        add     eax,[I16]               ; AReg = o + p
        mov     [T97],eax               ; deassign AReg
        mov     eax,[I17]               ; AReg = q
        add     eax,[I18]               ; AReg = q + r
        mov     [T98],eax               ; deassign AReg
        mov     eax,[I19]               ; AReg = s
        add     eax,[I20]               ; AReg = s + t
        mov     [T99],eax               ; deassign AReg
        mov     eax,[I21]               ; AReg = u
        add     eax,[I22]               ; AReg = u + v
        mov     [T100],eax              ; deassign AReg
        mov     eax,[I1]                ; AReg = a
        add     eax,[I2]                ; AReg = a + b
        add     eax,[T100]              ; AReg = T101 + T100
        add     eax,[T99]               ; AReg = T100 + T99
        add     eax,[T98]               ; AReg = T99 + T98
        add     eax,[T97]               ; AReg = T98 + T97
        add     eax,[T96]               ; AReg = T97 + T96
        add     eax,[T95]               ; AReg = T96 + T95
        add     eax,[T94]               ; AReg = T95 + T94
        add     eax,[T93]               ; AReg = T94 + T93
        add     eax,[T92]               ; AReg = T93 + T92
        add     eax,[T91]               ; AReg = T92 + T91
        add     eax,[T90]               ; AReg = T91 + T90
        add     eax,[T89]               ; AReg = T90 + T89
        add     eax,[T88]               ; AReg = T89 + T88
        add     eax,[T87]               ; AReg = T88 + T87
        add     eax,[T86]               ; AReg = T87 + T86
        add     eax,[T85]               ; AReg = T86 + T85
        add     eax,[T84]               ; AReg = T85 + T84
        add     eax,[T83]               ; AReg = T84 + T83
        add     eax,[T82]               ; AReg = T83 + T82
        add     eax,[T81]               ; AReg = T82 + T81
        add     eax,[T80]               ; AReg = T81 + T80
        add     eax,[T79]               ; AReg = T80 + T79
        add     eax,[T78]               ; AReg = T79 + T78
        add     eax,[T77]               ; AReg = T78 + T77
        add     eax,[T76]               ; AReg = T77 + T76
        add     eax,[T75]               ; AReg = T76 + T75
        add     eax,[T74]               ; AReg = T75 + T74
        add     eax,[T73]               ; AReg = T74 + T73
        add     eax,[T72]               ; AReg = T73 + T72
        add     eax,[T71]               ; AReg = T72 + T71
        add     eax,[T70]               ; AReg = T71 + T70
        add     eax,[T69]               ; AReg = T70 + T69
        add     eax,[T68]               ; AReg = T69 + T68
        add     eax,[T67]               ; AReg = T68 + T67
        add     eax,[T66]               ; AReg = T67 + T66
        add     eax,[T65]               ; AReg = T66 + T65
        add     eax,[T64]               ; AReg = T65 + T64
        add     eax,[T63]               ; AReg = T64 + T63
        add     eax,[T62]               ; AReg = T63 + T62
        add     eax,[T61]               ; AReg = T62 + T61
        add     eax,[T60]               ; AReg = T61 + T60
        add     eax,[T59]               ; AReg = T60 + T59
        add     eax,[T58]               ; AReg = T59 + T58
        add     eax,[T57]               ; AReg = T58 + T57
        add     eax,[T56]               ; AReg = T57 + T56
        add     eax,[T55]               ; AReg = T56 + T55
        add     eax,[T54]               ; AReg = T55 + T54
        add     eax,[T53]               ; AReg = T54 + T53
        add     eax,[T52]               ; AReg = T53 + T52
        add     eax,[T51]               ; AReg = T52 + T51
        add     eax,[T50]               ; AReg = T51 + T50
        add     eax,[T49]               ; AReg = T50 + T49
        add     eax,[T48]               ; AReg = T49 + T48
        add     eax,[T47]               ; AReg = T48 + T47
        add     eax,[T46]               ; AReg = T47 + T46
        add     eax,[T45]               ; AReg = T46 + T45
        add     eax,[T44]               ; AReg = T45 + T44
        add     eax,[T43]               ; AReg = T44 + T43
        add     eax,[T42]               ; AReg = T43 + T42
        add     eax,[T41]               ; AReg = T42 + T41
        add     eax,[T40]               ; AReg = T41 + T40
        add     eax,[T39]               ; AReg = T40 + T39
        add     eax,[T38]               ; AReg = T39 + T38
        add     eax,[T37]               ; AReg = T38 + T37
        add     eax,[T36]               ; AReg = T37 + T36
        add     eax,[T35]               ; AReg = T36 + T35
        add     eax,[T34]               ; AReg = T35 + T34
        add     eax,[T33]               ; AReg = T34 + T33
        add     eax,[T32]               ; AReg = T33 + T32
        add     eax,[T31]               ; AReg = T32 + T31
        add     eax,[T30]               ; AReg = T31 + T30
        add     eax,[T29]               ; AReg = T30 + T29
        add     eax,[T28]               ; AReg = T29 + T28
        add     eax,[T27]               ; AReg = T28 + T27
        add     eax,[T26]               ; AReg = T27 + T26
        add     eax,[T25]               ; AReg = T26 + T25
        add     eax,[T24]               ; AReg = T25 + T24
        add     eax,[T23]               ; AReg = T24 + T23
        add     eax,[T22]               ; AReg = T23 + T22
        add     eax,[T21]               ; AReg = T22 + T21
        add     eax,[T20]               ; AReg = T21 + T20
        add     eax,[T19]               ; AReg = T20 + T19
        add     eax,[T18]               ; AReg = T19 + T18
        add     eax,[T17]               ; AReg = T18 + T17
        add     eax,[T16]               ; AReg = T17 + T16
        add     eax,[T15]               ; AReg = T16 + T15
        add     eax,[T14]               ; AReg = T15 + T14
        add     eax,[T13]               ; AReg = T14 + T13
        add     eax,[T12]               ; AReg = T13 + T12
        add     eax,[T11]               ; AReg = T12 + T11
        add     eax,[T10]               ; AReg = T11 + T10
        add     eax,[T9]                ; AReg = T10 + T9
        add     eax,[T8]                ; AReg = T9 + T8
        add     eax,[T7]                ; AReg = T8 + T7
        add     eax,[T6]                ; AReg = T7 + T6
        add     eax,[T5]                ; AReg = T6 + T5
        add     eax,[T4]                ; AReg = T5 + T4
        add     eax,[T3]                ; AReg = T4 + T3
        add     eax,[T2]                ; AReg = T3 + T2
        add     eax,[T1]                ; AReg = T2 + T1
        add     eax,[T0]                ; AReg = T1 + T0
        mov     [I0],eax                ; sum = AReg
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                            
SECTION .data                                   

SECTION .bss                                    
T0      resd    1                       ; T0    
T1      resd    1                       ; T1    
T10     resd    1                       ; T10   
T100    resd    1                       ; T100  
T11     resd    1                       ; T11   
T12     resd    1                       ; T12   
T13     resd    1                       ; T13   
T14     resd    1                       ; T14   
T15     resd    1                       ; T15   
T16     resd    1                       ; T16   
T17     resd    1                       ; T17   
T18     resd    1                       ; T18   
T19     resd    1                       ; T19   
T2      resd    1                       ; T2    
T20     resd    1                       ; T20   
T21     resd    1                       ; T21   
T22     resd    1                       ; T22   
T23     resd    1                       ; T23   
T24     resd    1                       ; T24   
T25     resd    1                       ; T25   
T26     resd    1                       ; T26   
T27     resd    1                       ; T27   
T28     resd    1                       ; T28   
T29     resd    1                       ; T29   
T3      resd    1                       ; T3    
T30     resd    1                       ; T30   
T31     resd    1                       ; T31   
T32     resd    1                       ; T32   
T33     resd    1                       ; T33   
T34     resd    1                       ; T34   
T35     resd    1                       ; T35   
T36     resd    1                       ; T36   
T37     resd    1                       ; T37   
T38     resd    1                       ; T38   
T39     resd    1                       ; T39   
T4      resd    1                       ; T4    
T40     resd    1                       ; T40   
T41     resd    1                       ; T41   
T42     resd    1                       ; T42   
T43     resd    1                       ; T43   
T44     resd    1                       ; T44   
T45     resd    1                       ; T45   
T46     resd    1                       ; T46   
T47     resd    1                       ; T47   
T48     resd    1                       ; T48   
T49     resd    1                       ; T49   
T5      resd    1                       ; T5    
T50     resd    1                       ; T50   
T51     resd    1                       ; T51   
T52     resd    1                       ; T52   
T53     resd    1                       ; T53   
T54     resd    1                       ; T54   
T55     resd    1                       ; T55   
T56     resd    1                       ; T56   
T57     resd    1                       ; T57   
T58     resd    1                       ; T58   
T59     resd    1                       ; T59   
T6      resd    1                       ; T6    
T60     resd    1                       ; T60   
T61     resd    1                       ; T61   
T62     resd    1                       ; T62   
T63     resd    1                       ; T63   
T64     resd    1                       ; T64   
T65     resd    1                       ; T65   
T66     resd    1                       ; T66   
T67     resd    1                       ; T67   
T68     resd    1                       ; T68   
T69     resd    1                       ; T69   
T7      resd    1                       ; T7    
T70     resd    1                       ; T70   
T71     resd    1                       ; T71   
T72     resd    1                       ; T72   
T73     resd    1                       ; T73   
T74     resd    1                       ; T74   
T75     resd    1                       ; T75   
T76     resd    1                       ; T76   
T77     resd    1                       ; T77   
T78     resd    1                       ; T78   
T79     resd    1                       ; T79   
T8      resd    1                       ; T8    
T80     resd    1                       ; T80   
T81     resd    1                       ; T81   
T82     resd    1                       ; T82   
T83     resd    1                       ; T83   
T84     resd    1                       ; T84   
T85     resd    1                       ; T85   
T86     resd    1                       ; T86   
T87     resd    1                       ; T87   
T88     resd    1                       ; T88   
T89     resd    1                       ; T89   
T9      resd    1                       ; T9    
T90     resd    1                       ; T90   
T91     resd    1                       ; T91   
T92     resd    1                       ; T92   
T93     resd    1                       ; T93   
T94     resd    1                       ; T94   
T95     resd    1                       ; T95   
T96     resd    1                       ; T96   
T97     resd    1                       ; T97   
T98     resd    1                       ; T98   
T99     resd    1                       ; T99   
I1      resd    1                       ; a     
I2      resd    1                       ; b     
I3      resd    1                       ; c     
I4      resd    1                       ; d     
I5      resd    1                       ; e     
I6      resd    1                       ; f     
I7      resd    1                       ; g     
I8      resd    1                       ; h     
I9      resd    1                       ; i     
I10     resd    1                       ; j     
I11     resd    1                       ; k     
I12     resd    1                       ; l     
I13     resd    1                       ; m     
I14     resd    1                       ; n     
I15     resd    1                       ; o     
I16     resd    1                       ; p     
I17     resd    1                       ; q     
I18     resd    1                       ; r     
I19     resd    1                       ; s     
I0      resd    1                       ; sum   
I20     resd    1                       ; t     
I21     resd    1                       ; u     
I22     resd    1                       ; v     

./output/153.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no153

_start:                                         
        mov     eax,[B0]                ; load a in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[B1]                ; load b in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[B2]                ; load c in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[B3]                ; load d in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out

./output/154.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no154

_start:                                         

./output/155.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no155

_start:                                         

./output/156.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no156

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I4],eax                ; store eax at i

./output/157.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no157

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I4],eax                ; store eax at i
        call    ReadInt                 ; read int; value placed in eax
        mov     [I5],eax                ; store eax at j

./output/158.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no158

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I4],eax                ; store eax at i
        call    ReadInt                 ; read int; value placed in eax
        mov     [I5],eax                ; store eax at j

./output/159.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no159

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I4],eax                ; store eax at i
        call    ReadInt                 ; read int; value placed in eax
        mov     [I5],eax                ; store eax at j
        mov     eax,[I4]                ; load i in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I5]                ; load j in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out

./output/160.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no160

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I4],eax                ; store eax at i
        call    ReadInt                 ; read int; value placed in eax
        mov     [I5],eax                ; store eax at j
        mov     eax,[I4]                ; load i in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I5]                ; load j in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[B0]                ; AReg = a
        cmp     eax,[B2]                ; compare a and c
        je      .L0                     ; if a = c then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                            

./output/161.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no161

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I4],eax                ; store eax at i
        call    ReadInt                 ; read int; value placed in eax
        mov     [I5],eax                ; store eax at j
        mov     eax,[I4]                ; load i in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I5]                ; load j in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[B0]                ; AReg = a
        cmp     eax,[B2]                ; compare a and c
        je      .L0                     ; if a = c then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                            
        not     eax                     ; AReg = !AReg
        mov     [B4],eax                ; k = AReg
        mov     eax,[FALSE]             ; AReg = false
        mov     [B4],eax                ; k = AReg
        mov     eax,[B2]                ; AReg = c
        not     eax                     ; AReg = !AReg
        mov     [B4],eax                ; k = AReg

./output/162.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no162

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I4],eax                ; store eax at i
        call    ReadInt                 ; read int; value placed in eax
        mov     [I5],eax                ; store eax at j
        mov     eax,[I4]                ; load i in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I5]                ; load j in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[B0]                ; AReg = a
        cmp     eax,[B2]                ; compare a and c
        je      .L0                     ; if a = c then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                            
        not     eax                     ; AReg = !AReg
        mov     [B4],eax                ; k = AReg
        mov     eax,[FALSE]             ; AReg = false
        mov     [B4],eax                ; k = AReg
        mov     eax,[B2]                ; AReg = c
        not     eax                     ; AReg = !AReg
        mov     [B4],eax                ; k = AReg
        mov     eax,[I0]                ; AReg = e
        add     eax,[I1]                ; AReg = e + f

./output/163.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no163

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I4],eax                ; store eax at i
        call    ReadInt                 ; read int; value placed in eax
        mov     [I5],eax                ; store eax at j
        mov     eax,[I4]                ; load i in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I5]                ; load j in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[B0]                ; AReg = a
        cmp     eax,[B2]                ; compare a and c
        je      .L0                     ; if a = c then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                            
        not     eax                     ; AReg = !AReg
        mov     [B4],eax                ; k = AReg
        mov     eax,[FALSE]             ; AReg = false
        mov     [B4],eax                ; k = AReg
        mov     eax,[B2]                ; AReg = c
        not     eax                     ; AReg = !AReg
        mov     [B4],eax                ; k = AReg
        mov     eax,[I0]                ; AReg = e
        add     eax,[I1]                ; AReg = e + f
        mov     [I4],eax                ; i = AReg
        mov     eax,[I6]                ; AReg = 4301
        mov     [I4],eax                ; i = AReg
        mov     eax,[I2]                ; AReg = g
        mov     [I4],eax                ; i = AReg

./output/164.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no164

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I4],eax                ; store eax at i
        call    ReadInt                 ; read int; value placed in eax
        mov     [I5],eax                ; store eax at j
        mov     eax,[I4]                ; load i in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I5]                ; load j in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[B0]                ; AReg = a
        cmp     eax,[B2]                ; compare a and c
        je      .L0                     ; if a = c then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                            
        not     eax                     ; AReg = !AReg
        mov     [B4],eax                ; k = AReg
        mov     eax,[FALSE]             ; AReg = false
        mov     [B4],eax                ; k = AReg
        mov     eax,[B2]                ; AReg = c
        not     eax                     ; AReg = !AReg
        mov     [B4],eax                ; k = AReg
        mov     eax,[I0]                ; AReg = e
        add     eax,[I1]                ; AReg = e + f
        mov     [I4],eax                ; i = AReg
        mov     eax,[I6]                ; AReg = 4301
        mov     [I4],eax                ; i = AReg
        mov     eax,[I2]                ; AReg = g
        mov     [I4],eax                ; i = AReg
        mov     eax,[I0]                ; AReg = e
        add     eax,[I1]                ; AReg = e + f
        mov     [I4],eax                ; i = AReg
        mov     eax,[I1]                ; AReg = f
        sub     eax,[I2]                ; AReg = f - g

./output/165.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no165

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I4],eax                ; store eax at i
        call    ReadInt                 ; read int; value placed in eax
        mov     [I5],eax                ; store eax at j
        mov     eax,[I4]                ; load i in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I5]                ; load j in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[B0]                ; AReg = a
        cmp     eax,[B2]                ; compare a and c
        je      .L0                     ; if a = c then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                            
        not     eax                     ; AReg = !AReg
        mov     [B4],eax                ; k = AReg
        mov     eax,[FALSE]             ; AReg = false
        mov     [B4],eax                ; k = AReg
        mov     eax,[B2]                ; AReg = c
        not     eax                     ; AReg = !AReg
        mov     [B4],eax                ; k = AReg
        mov     eax,[I0]                ; AReg = e
        add     eax,[I1]                ; AReg = e + f
        mov     [I4],eax                ; i = AReg
        mov     eax,[I6]                ; AReg = 4301
        mov     [I4],eax                ; i = AReg
        mov     eax,[I2]                ; AReg = g
        mov     [I4],eax                ; i = AReg
        mov     eax,[I1]                ; AReg = f
        sub     eax,[I2]                ; AReg = f - g
        neg     eax                     ; AReg = -AReg
        mov     [I4],eax                ; i = AReg
        mov     eax,[I7]                ; AReg = -4301
        mov     [I4],eax                ; i = AReg
        mov     eax,[I2]                ; AReg = g
        neg     eax                     ; AReg = -AReg
        mov     [I4],eax                ; i = AReg

./output/166.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no166

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at a

./output/167.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no167

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at a

./output/168.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no168

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at a

./output/169.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no169

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at a

./output/170.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no170

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at a
        mov     eax,[I6]                ; AReg = -5
        mov     [I4],eax                ; d = AReg
        neg     eax                     ; AReg = -AReg
        mov     [I4],eax                ; d = AReg
        neg     eax                     ; AReg = -AReg
        neg     eax                     ; AReg = -AReg
        neg     eax                     ; AReg = -AReg
        mov     [I4],eax                ; d = AReg

./output/171.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no171

_start:                                         
        mov     eax,[B0]                ; AReg = x
        not     eax                     ; AReg = !AReg
        mov     [B1],eax                ; d = AReg
        mov     eax,[FALSE]             ; AReg = false
        mov     [B1],eax                ; d = AReg
        mov     eax,[TRUE]              ; AReg = true
        mov     [B1],eax                ; d = AReg
        mov     eax,[B0]                ; AReg = x
        not     eax                     ; AReg = !AReg
        not     eax                     ; AReg = !AReg
        not     eax                     ; AReg = !AReg
        mov     [B1],eax                ; d = AReg

./output/172.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no172

_start:                                         
        mov     eax,[B0]                ; AReg = x
        or      eax,[B0]                ; AReg = x or x
        mov     [B1],eax                ; d = AReg
        mov     eax,[B0]                ; AReg = x
        or      eax,[TRUE]              ; AReg = x or true
        mov     [B1],eax                ; d = AReg
        mov     eax,[FALSE]             ; AReg = false
        or      eax,[B0]                ; AReg = false or x
        mov     [B1],eax                ; d = AReg
        mov     eax,[FALSE]             ; AReg = false
        or      eax,[FALSE]             ; AReg = false or false
        mov     [B1],eax                ; d = AReg
        mov     eax,[FALSE]             ; AReg = false
        or      eax,[TRUE]              ; AReg = false or true
        mov     [B1],eax                ; d = AReg
        mov     eax,[TRUE]              ; AReg = true
        or      eax,[FALSE]             ; AReg = true or false
        mov     [B1],eax                ; d = AReg
        mov     eax,[TRUE]              ; AReg = true
        or      eax,[TRUE]              ; AReg = true or true
        mov     [B1],eax                ; d = AReg
        mov     eax,[TRUE]              ; AReg = true
        or      eax,[TRUE]              ; AReg = true or true
        mov     [B1],eax                ; d = AReg
        mov     eax,[TRUE]              ; AReg = true
        or      eax,[FALSE]             ; AReg = true or false
        mov     [B1],eax                ; d = AReg
        mov     eax,[FALSE]             ; AReg = false
        or      eax,[TRUE]              ; AReg = false or true
        mov     [B1],eax                ; d = AReg
        mov     eax,[FALSE]             ; AReg = false
        or      eax,[FALSE]             ; AReg = false or false
        mov     [B1],eax                ; d = AReg

./output/173.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no173

_start:                                         
        mov     eax,[B0]                ; AReg = x
        cmp     eax,[B0]                ; compare x and x
        je      .L0                     ; if x = x then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                            
        mov     [B1],eax                ; d = AReg
        mov     eax,[B0]                ; AReg = x
        not     eax                     ; AReg = !AReg
        cmp     eax,[B0]                ; compare T0 and x
        je      .L2                     ; if x = T0 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L3                     ; unconditionally jump
.L2:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L3:                                            
        mov     [B1],eax                ; d = AReg
        mov     eax,[B0]                ; AReg = x
        not     eax                     ; AReg = !AReg
        cmp     eax,[B0]                ; compare T0 and x
        je      .L4                     ; if T0 = x then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L5                     ; unconditionally jump
.L4:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L5:                                            
        mov     [B1],eax                ; d = AReg
        mov     eax,[B0]                ; AReg = x
        not     eax                     ; AReg = !AReg
        mov     [T0],eax                ; deassign AReg
        mov     eax,[B0]                ; AReg = x
        not     eax                     ; AReg = !AReg
        cmp     eax,[T0]                ; compare T1 and T0
        je      .L6                     ; if T0 = T1 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L7                     ; unconditionally jump
.L6:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L7:                                            
        mov     [B1],eax                ; d = AReg
        mov     eax,[B0]                ; AReg = x
        cmp     eax,[TRUE]              ; compare x and true
        je      .L8                     ; if x = true then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L9                     ; unconditionally jump
.L8:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L9:                                            
        mov     [B1],eax                ; d = AReg
        mov     eax,[FALSE]             ; AReg = false
        cmp     eax,[B0]                ; compare false and x
        je      .L10                    ; if false = x then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L11                    ; unconditionally jump
.L10:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L11:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[FALSE]             ; AReg = false
        cmp     eax,[FALSE]             ; compare false and false
        je      .L12                    ; if false = false then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L13                    ; unconditionally jump
.L12:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L13:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[FALSE]             ; AReg = false
        cmp     eax,[TRUE]              ; compare false and true
        je      .L14                    ; if false = true then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L15                    ; unconditionally jump
.L14:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L15:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[TRUE]              ; AReg = true
        cmp     eax,[FALSE]             ; compare true and false
        je      .L16                    ; if true = false then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L17                    ; unconditionally jump
.L16:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L17:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[TRUE]              ; AReg = true
        cmp     eax,[TRUE]              ; compare true and true
        je      .L18                    ; if true = true then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L19                    ; unconditionally jump
.L18:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L19:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[TRUE]              ; AReg = true
        cmp     eax,[TRUE]              ; compare true and true
        je      .L20                    ; if true = true then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L21                    ; unconditionally jump
.L20:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L21:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[TRUE]              ; AReg = true
        cmp     eax,[FALSE]             ; compare true and false
        je      .L22                    ; if true = false then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L23                    ; unconditionally jump
.L22:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L23:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[FALSE]             ; AReg = false
        cmp     eax,[TRUE]              ; compare false and true
        je      .L24                    ; if false = true then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L25                    ; unconditionally jump
.L24:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L25:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[FALSE]             ; AReg = false
        cmp     eax,[FALSE]             ; compare false and false
        je      .L26                    ; if false = false then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L27                    ; unconditionally jump
.L26:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L27:                                           
        mov     [B1],eax                ; d = AReg
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at a
        call    ReadInt                 ; read int; value placed in eax
        mov     [I2],eax                ; store eax at b
        mov     eax,[I1]                ; AReg = a
        neg     eax                     ; AReg = -AReg
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I2]                ; AReg = b
        neg     eax                     ; AReg = -AReg
        cmp     eax,[T0]                ; compare T1 and T0
        je      .L28                    ; if T0 = T1 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L29                    ; unconditionally jump
.L28:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L29:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I1]                ; AReg = a
        neg     eax                     ; AReg = -AReg
        cmp     eax,[I2]                ; compare T0 and b
        je      .L30                    ; if T0 = b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L31                    ; unconditionally jump
.L30:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L31:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I1]                ; AReg = a
        neg     eax                     ; AReg = -AReg
        cmp     eax,[I2]                ; compare T0 and b
        je      .L32                    ; if T0 = b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L33                    ; unconditionally jump
.L32:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L33:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I2]                ; AReg = b
        neg     eax                     ; AReg = -AReg
        cmp     eax,[I1]                ; compare T0 and a
        je      .L34                    ; if a = T0 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L35                    ; unconditionally jump
.L34:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L35:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I1]                ; AReg = a
        cmp     eax,[I2]                ; compare a and b
        je      .L36                    ; if a = b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L37                    ; unconditionally jump
.L36:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L37:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I1]                ; AReg = a
        cmp     eax,[I2]                ; compare a and b
        je      .L38                    ; if a = b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L39                    ; unconditionally jump
.L38:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L39:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I2]                ; AReg = b
        neg     eax                     ; AReg = -AReg
        cmp     eax,[I1]                ; compare T0 and a
        je      .L40                    ; if a = T0 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L41                    ; unconditionally jump
.L40:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L41:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I1]                ; AReg = a
        cmp     eax,[I2]                ; compare a and b
        je      .L42                    ; if a = b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L43                    ; unconditionally jump
.L42:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L43:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I1]                ; AReg = a
        cmp     eax,[I2]                ; compare a and b
        je      .L44                    ; if a = b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L45                    ; unconditionally jump
.L44:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L45:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I3]                ; AReg = -4301
        cmp     eax,[I3]                ; compare -4301 and -4301
        je      .L46                    ; if -4301 = -4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L47                    ; unconditionally jump
.L46:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L47:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I3]                ; AReg = -4301
        cmp     eax,[I4]                ; compare -4301 and 4301
        je      .L48                    ; if -4301 = 4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L49                    ; unconditionally jump
.L48:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L49:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I3]                ; AReg = -4301
        cmp     eax,[I4]                ; compare -4301 and 4301
        je      .L50                    ; if -4301 = 4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L51                    ; unconditionally jump
.L50:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L51:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I4]                ; AReg = 4301
        cmp     eax,[I3]                ; compare 4301 and -4301
        je      .L52                    ; if 4301 = -4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L53                    ; unconditionally jump
.L52:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L53:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I4]                ; AReg = 4301
        cmp     eax,[I4]                ; compare 4301 and 4301
        je      .L54                    ; if 4301 = 4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L55                    ; unconditionally jump
.L54:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L55:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I4]                ; AReg = 4301
        cmp     eax,[I4]                ; compare 4301 and 4301
        je      .L56                    ; if 4301 = 4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L57                    ; unconditionally jump
.L56:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L57:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I4]                ; AReg = 4301
        cmp     eax,[I3]                ; compare 4301 and -4301
        je      .L58                    ; if 4301 = -4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L59                    ; unconditionally jump
.L58:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L59:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I4]                ; AReg = 4301
        cmp     eax,[I4]                ; compare 4301 and 4301
        je      .L60                    ; if 4301 = 4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L61                    ; unconditionally jump
.L60:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L61:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I4]                ; AReg = 4301
        cmp     eax,[I4]                ; compare 4301 and 4301
        je      .L62                    ; if 4301 = 4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L63                    ; unconditionally jump
.L62:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L63:                                           
        mov     [B1],eax                ; d = AReg

./output/174.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no174

_start:                                         
        mov     eax,[B0]                ; AReg = x
        cmp     eax,[B0]                ; compare x and x
        jne     .L0                     ; if x <> x then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                            
        mov     [B1],eax                ; d = AReg
        mov     eax,[B0]                ; AReg = x
        not     eax                     ; AReg = !AReg
        cmp     eax,[B0]                ; compare T0 and x
        jne     .L2                     ; if x <> T0 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L3                     ; unconditionally jump
.L2:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L3:                                            
        mov     [B1],eax                ; d = AReg
        mov     eax,[B0]                ; AReg = x
        not     eax                     ; AReg = !AReg
        cmp     eax,[B0]                ; compare T0 and x
        jne     .L4                     ; if T0 <> x then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L5                     ; unconditionally jump
.L4:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L5:                                            
        mov     [B1],eax                ; d = AReg
        mov     eax,[B0]                ; AReg = x
        not     eax                     ; AReg = !AReg
        mov     [T0],eax                ; deassign AReg
        mov     eax,[B0]                ; AReg = x
        not     eax                     ; AReg = !AReg
        cmp     eax,[T0]                ; compare T1 and T0
        jne     .L6                     ; if T0 <> T1 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L7                     ; unconditionally jump
.L6:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L7:                                            
        mov     [B1],eax                ; d = AReg
        mov     eax,[B0]                ; AReg = x
        cmp     eax,[TRUE]              ; compare x and true
        jne     .L8                     ; if x <> true then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L9                     ; unconditionally jump
.L8:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L9:                                            
        mov     [B1],eax                ; d = AReg
        mov     eax,[FALSE]             ; AReg = false
        cmp     eax,[B0]                ; compare false and x
        jne     .L10                    ; if false <> x then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L11                    ; unconditionally jump
.L10:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L11:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[FALSE]             ; AReg = false
        cmp     eax,[FALSE]             ; compare false and false
        jne     .L12                    ; if false <> false then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L13                    ; unconditionally jump
.L12:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L13:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[FALSE]             ; AReg = false
        cmp     eax,[TRUE]              ; compare false and true
        jne     .L14                    ; if false <> true then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L15                    ; unconditionally jump
.L14:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L15:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[TRUE]              ; AReg = true
        cmp     eax,[FALSE]             ; compare true and false
        jne     .L16                    ; if true <> false then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L17                    ; unconditionally jump
.L16:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L17:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[TRUE]              ; AReg = true
        cmp     eax,[TRUE]              ; compare true and true
        jne     .L18                    ; if true <> true then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L19                    ; unconditionally jump
.L18:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L19:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[TRUE]              ; AReg = true
        cmp     eax,[TRUE]              ; compare true and true
        jne     .L20                    ; if true <> true then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L21                    ; unconditionally jump
.L20:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L21:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[TRUE]              ; AReg = true
        cmp     eax,[FALSE]             ; compare true and false
        jne     .L22                    ; if true <> false then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L23                    ; unconditionally jump
.L22:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L23:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[FALSE]             ; AReg = false
        cmp     eax,[TRUE]              ; compare false and true
        jne     .L24                    ; if false <> true then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L25                    ; unconditionally jump
.L24:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L25:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[FALSE]             ; AReg = false
        cmp     eax,[FALSE]             ; compare false and false
        jne     .L26                    ; if false <> false then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L27                    ; unconditionally jump
.L26:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L27:                                           
        mov     [B1],eax                ; d = AReg
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at a
        call    ReadInt                 ; read int; value placed in eax
        mov     [I2],eax                ; store eax at b
        mov     eax,[I1]                ; AReg = a
        neg     eax                     ; AReg = -AReg
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I2]                ; AReg = b
        neg     eax                     ; AReg = -AReg
        cmp     eax,[T0]                ; compare T1 and T0
        jne     .L28                    ; if T0 <> T1 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L29                    ; unconditionally jump
.L28:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L29:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I1]                ; AReg = a
        neg     eax                     ; AReg = -AReg
        cmp     eax,[I2]                ; compare T0 and b
        jne     .L30                    ; if T0 <> b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L31                    ; unconditionally jump
.L30:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L31:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I1]                ; AReg = a
        neg     eax                     ; AReg = -AReg
        cmp     eax,[I2]                ; compare T0 and b
        jne     .L32                    ; if T0 <> b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L33                    ; unconditionally jump
.L32:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L33:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I2]                ; AReg = b
        neg     eax                     ; AReg = -AReg
        cmp     eax,[I1]                ; compare T0 and a
        jne     .L34                    ; if a <> T0 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L35                    ; unconditionally jump
.L34:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L35:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I1]                ; AReg = a
        cmp     eax,[I2]                ; compare a and b
        jne     .L36                    ; if a <> b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L37                    ; unconditionally jump
.L36:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L37:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I1]                ; AReg = a
        cmp     eax,[I2]                ; compare a and b
        jne     .L38                    ; if a <> b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L39                    ; unconditionally jump
.L38:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L39:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I2]                ; AReg = b
        neg     eax                     ; AReg = -AReg
        cmp     eax,[I1]                ; compare T0 and a
        jne     .L40                    ; if a <> T0 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L41                    ; unconditionally jump
.L40:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L41:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I1]                ; AReg = a
        cmp     eax,[I2]                ; compare a and b
        jne     .L42                    ; if a <> b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L43                    ; unconditionally jump
.L42:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L43:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I1]                ; AReg = a
        cmp     eax,[I2]                ; compare a and b
        jne     .L44                    ; if a <> b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L45                    ; unconditionally jump
.L44:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L45:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I3]                ; AReg = -4301
        cmp     eax,[I3]                ; compare -4301 and -4301
        jne     .L46                    ; if -4301 <> -4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L47                    ; unconditionally jump
.L46:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L47:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I3]                ; AReg = -4301
        cmp     eax,[I4]                ; compare -4301 and 4301
        jne     .L48                    ; if -4301 <> 4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L49                    ; unconditionally jump
.L48:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L49:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I3]                ; AReg = -4301
        cmp     eax,[I4]                ; compare -4301 and 4301
        jne     .L50                    ; if -4301 <> 4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L51                    ; unconditionally jump
.L50:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L51:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I4]                ; AReg = 4301
        cmp     eax,[I3]                ; compare 4301 and -4301
        jne     .L52                    ; if 4301 <> -4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L53                    ; unconditionally jump
.L52:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L53:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I4]                ; AReg = 4301
        cmp     eax,[I4]                ; compare 4301 and 4301
        jne     .L54                    ; if 4301 <> 4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L55                    ; unconditionally jump
.L54:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L55:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I4]                ; AReg = 4301
        cmp     eax,[I4]                ; compare 4301 and 4301
        jne     .L56                    ; if 4301 <> 4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L57                    ; unconditionally jump
.L56:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L57:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I4]                ; AReg = 4301
        cmp     eax,[I3]                ; compare 4301 and -4301
        jne     .L58                    ; if 4301 <> -4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L59                    ; unconditionally jump
.L58:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L59:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I4]                ; AReg = 4301
        cmp     eax,[I4]                ; compare 4301 and 4301
        jne     .L60                    ; if 4301 <> 4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L61                    ; unconditionally jump
.L60:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L61:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I4]                ; AReg = 4301
        cmp     eax,[I4]                ; compare 4301 and 4301
        jne     .L62                    ; if 4301 <> 4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L63                    ; unconditionally jump
.L62:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L63:                                           
        mov     [B1],eax                ; d = AReg

./output/175.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no175

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at a
        call    ReadInt                 ; read int; value placed in eax
        mov     [I2],eax                ; store eax at b
        mov     eax,[I1]                ; AReg = a
        neg     eax                     ; AReg = -AReg
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I2]                ; AReg = b
        neg     eax                     ; AReg = -AReg
        cmp     eax,[T0]                ; compare T1 and T0
        jl      .L0                     ; if T1 < T0 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                            
        mov     [B1],eax                ; d = AReg
        mov     eax,[I1]                ; AReg = a
        neg     eax                     ; AReg = -AReg
        cmp     eax,[I2]                ; compare T0 and b
        jl      .L2                     ; if T0 < b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L3                     ; unconditionally jump
.L2:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L3:                                            
        mov     [B1],eax                ; d = AReg
        mov     eax,[I1]                ; AReg = a
        neg     eax                     ; AReg = -AReg
        cmp     eax,[I2]                ; compare T0 and b
        jl      .L4                     ; if T0 < b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L5                     ; unconditionally jump
.L4:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L5:                                            
        mov     [B1],eax                ; d = AReg
        mov     eax,[I2]                ; AReg = b
        neg     eax                     ; AReg = -AReg
        cmp     eax,[I1]                ; compare T0 and a
        jl      .L6                     ; if T0 < a then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L7                     ; unconditionally jump
.L6:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L7:                                            
        mov     [B1],eax                ; d = AReg
        mov     eax,[I1]                ; AReg = a
        cmp     eax,[I2]                ; compare a and b
        jl      .L8                     ; if a < b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L9                     ; unconditionally jump
.L8:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L9:                                            
        mov     [B1],eax                ; d = AReg
        mov     eax,[I1]                ; AReg = a
        cmp     eax,[I2]                ; compare a and b
        jl      .L10                    ; if a < b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L11                    ; unconditionally jump
.L10:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L11:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I2]                ; AReg = b
        neg     eax                     ; AReg = -AReg
        cmp     eax,[I1]                ; compare T0 and a
        jl      .L12                    ; if T0 < a then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L13                    ; unconditionally jump
.L12:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L13:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I1]                ; AReg = a
        cmp     eax,[I2]                ; compare a and b
        jl      .L14                    ; if a < b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L15                    ; unconditionally jump
.L14:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L15:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I1]                ; AReg = a
        cmp     eax,[I2]                ; compare a and b
        jl      .L16                    ; if a < b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L17                    ; unconditionally jump
.L16:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L17:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I3]                ; AReg = -4301
        cmp     eax,[I3]                ; compare -4301 and -4301
        jl      .L18                    ; if -4301 < -4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L19                    ; unconditionally jump
.L18:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L19:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I3]                ; AReg = -4301
        cmp     eax,[I4]                ; compare -4301 and 4301
        jl      .L20                    ; if -4301 < 4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L21                    ; unconditionally jump
.L20:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L21:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I3]                ; AReg = -4301
        cmp     eax,[I4]                ; compare -4301 and 4301
        jl      .L22                    ; if -4301 < 4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L23                    ; unconditionally jump
.L22:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L23:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I4]                ; AReg = 4301
        cmp     eax,[I3]                ; compare 4301 and -4301
        jl      .L24                    ; if 4301 < -4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L25                    ; unconditionally jump
.L24:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L25:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I4]                ; AReg = 4301
        cmp     eax,[I4]                ; compare 4301 and 4301
        jl      .L26                    ; if 4301 < 4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L27                    ; unconditionally jump
.L26:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L27:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I4]                ; AReg = 4301
        cmp     eax,[I4]                ; compare 4301 and 4301
        jl      .L28                    ; if 4301 < 4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L29                    ; unconditionally jump
.L28:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L29:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I4]                ; AReg = 4301
        cmp     eax,[I3]                ; compare 4301 and -4301
        jl      .L30                    ; if 4301 < -4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L31                    ; unconditionally jump
.L30:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L31:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I4]                ; AReg = 4301
        cmp     eax,[I4]                ; compare 4301 and 4301
        jl      .L32                    ; if 4301 < 4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L33                    ; unconditionally jump
.L32:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L33:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I4]                ; AReg = 4301
        cmp     eax,[I4]                ; compare 4301 and 4301
        jl      .L34                    ; if 4301 < 4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L35                    ; unconditionally jump
.L34:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L35:                                           
        mov     [B1],eax                ; d = AReg

./output/176.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no176

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at a
        call    ReadInt                 ; read int; value placed in eax
        mov     [I2],eax                ; store eax at b
        mov     eax,[I1]                ; AReg = a
        neg     eax                     ; AReg = -AReg
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I2]                ; AReg = b
        neg     eax                     ; AReg = -AReg
        cmp     eax,[T0]                ; compare T1 and T0
        jle     .L0                     ; if T1 <= T0 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                            
        mov     [B1],eax                ; d = AReg
        mov     eax,[I1]                ; AReg = a
        neg     eax                     ; AReg = -AReg
        cmp     eax,[I2]                ; compare T0 and b
        jle     .L2                     ; if T0 <= b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L3                     ; unconditionally jump
.L2:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L3:                                            
        mov     [B1],eax                ; d = AReg
        mov     eax,[I1]                ; AReg = a
        neg     eax                     ; AReg = -AReg
        cmp     eax,[I2]                ; compare T0 and b
        jle     .L4                     ; if T0 <= b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L5                     ; unconditionally jump
.L4:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L5:                                            
        mov     [B1],eax                ; d = AReg
        mov     eax,[I2]                ; AReg = b
        neg     eax                     ; AReg = -AReg
        cmp     eax,[I1]                ; compare T0 and a
        jle     .L6                     ; if T0 <= a then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L7                     ; unconditionally jump
.L6:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L7:                                            
        mov     [B1],eax                ; d = AReg
        mov     eax,[I1]                ; AReg = a
        cmp     eax,[I2]                ; compare a and b
        jle     .L8                     ; if a <= b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L9                     ; unconditionally jump
.L8:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L9:                                            
        mov     [B1],eax                ; d = AReg
        mov     eax,[I1]                ; AReg = a
        cmp     eax,[I2]                ; compare a and b
        jle     .L10                    ; if a <= b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L11                    ; unconditionally jump
.L10:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L11:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I2]                ; AReg = b
        neg     eax                     ; AReg = -AReg
        cmp     eax,[I1]                ; compare T0 and a
        jle     .L12                    ; if T0 <= a then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L13                    ; unconditionally jump
.L12:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L13:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I1]                ; AReg = a
        cmp     eax,[I2]                ; compare a and b
        jle     .L14                    ; if a <= b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L15                    ; unconditionally jump
.L14:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L15:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I1]                ; AReg = a
        cmp     eax,[I2]                ; compare a and b
        jle     .L16                    ; if a <= b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L17                    ; unconditionally jump
.L16:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L17:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I3]                ; AReg = -4301
        cmp     eax,[I3]                ; compare -4301 and -4301
        jle     .L18                    ; if -4301 <= -4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L19                    ; unconditionally jump
.L18:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L19:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I3]                ; AReg = -4301
        cmp     eax,[I4]                ; compare -4301 and 4301
        jle     .L20                    ; if -4301 <= 4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L21                    ; unconditionally jump
.L20:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L21:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I3]                ; AReg = -4301
        cmp     eax,[I4]                ; compare -4301 and 4301
        jle     .L22                    ; if -4301 <= 4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L23                    ; unconditionally jump
.L22:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L23:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I4]                ; AReg = 4301
        cmp     eax,[I3]                ; compare 4301 and -4301
        jle     .L24                    ; if 4301 <= -4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L25                    ; unconditionally jump
.L24:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L25:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I4]                ; AReg = 4301
        cmp     eax,[I4]                ; compare 4301 and 4301
        jle     .L26                    ; if 4301 <= 4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L27                    ; unconditionally jump
.L26:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L27:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I4]                ; AReg = 4301
        cmp     eax,[I4]                ; compare 4301 and 4301
        jle     .L28                    ; if 4301 <= 4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L29                    ; unconditionally jump
.L28:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L29:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I4]                ; AReg = 4301
        cmp     eax,[I3]                ; compare 4301 and -4301
        jle     .L30                    ; if 4301 <= -4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L31                    ; unconditionally jump
.L30:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L31:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I4]                ; AReg = 4301
        cmp     eax,[I4]                ; compare 4301 and 4301
        jle     .L32                    ; if 4301 <= 4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L33                    ; unconditionally jump
.L32:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L33:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I4]                ; AReg = 4301
        cmp     eax,[I4]                ; compare 4301 and 4301
        jle     .L34                    ; if 4301 <= 4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L35                    ; unconditionally jump
.L34:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L35:                                           
        mov     [B1],eax                ; d = AReg

./output/177.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no177

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at a
        call    ReadInt                 ; read int; value placed in eax
        mov     [I2],eax                ; store eax at b
        mov     eax,[I1]                ; AReg = a
        neg     eax                     ; AReg = -AReg
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I2]                ; AReg = b
        neg     eax                     ; AReg = -AReg
        cmp     eax,[T0]                ; compare T1 and T0
        jg      .L0                     ; if T1 > T0 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                            
        mov     [B1],eax                ; d = AReg
        mov     eax,[I1]                ; AReg = a
        neg     eax                     ; AReg = -AReg
        cmp     eax,[I2]                ; compare T0 and b
        jg      .L2                     ; if T0 > b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L3                     ; unconditionally jump
.L2:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L3:                                            
        mov     [B1],eax                ; d = AReg
        mov     eax,[I1]                ; AReg = a
        neg     eax                     ; AReg = -AReg
        cmp     eax,[I2]                ; compare T0 and b
        jg      .L4                     ; if T0 > b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L5                     ; unconditionally jump
.L4:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L5:                                            
        mov     [B1],eax                ; d = AReg
        mov     eax,[I2]                ; AReg = b
        neg     eax                     ; AReg = -AReg
        cmp     eax,[I1]                ; compare T0 and a
        jg      .L6                     ; if T0 > a then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L7                     ; unconditionally jump
.L6:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L7:                                            
        mov     [B1],eax                ; d = AReg
        mov     eax,[I1]                ; AReg = a
        cmp     eax,[I2]                ; compare a and b
        jg      .L8                     ; if a > b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L9                     ; unconditionally jump
.L8:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L9:                                            
        mov     [B1],eax                ; d = AReg
        mov     eax,[I1]                ; AReg = a
        cmp     eax,[I2]                ; compare a and b
        jg      .L10                    ; if a > b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L11                    ; unconditionally jump
.L10:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L11:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I2]                ; AReg = b
        neg     eax                     ; AReg = -AReg
        cmp     eax,[I1]                ; compare T0 and a
        jg      .L12                    ; if T0 > a then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L13                    ; unconditionally jump
.L12:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L13:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I1]                ; AReg = a
        cmp     eax,[I2]                ; compare a and b
        jg      .L14                    ; if a > b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L15                    ; unconditionally jump
.L14:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L15:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I1]                ; AReg = a
        cmp     eax,[I2]                ; compare a and b
        jg      .L16                    ; if a > b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L17                    ; unconditionally jump
.L16:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L17:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I3]                ; AReg = -4301
        cmp     eax,[I3]                ; compare -4301 and -4301
        jg      .L18                    ; if -4301 > -4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L19                    ; unconditionally jump
.L18:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L19:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I3]                ; AReg = -4301
        cmp     eax,[I4]                ; compare -4301 and 4301
        jg      .L20                    ; if -4301 > 4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L21                    ; unconditionally jump
.L20:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L21:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I3]                ; AReg = -4301
        cmp     eax,[I4]                ; compare -4301 and 4301
        jg      .L22                    ; if -4301 > 4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L23                    ; unconditionally jump
.L22:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L23:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I4]                ; AReg = 4301
        cmp     eax,[I3]                ; compare 4301 and -4301
        jg      .L24                    ; if 4301 > -4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L25                    ; unconditionally jump
.L24:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L25:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I4]                ; AReg = 4301
        cmp     eax,[I4]                ; compare 4301 and 4301
        jg      .L26                    ; if 4301 > 4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L27                    ; unconditionally jump
.L26:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L27:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I4]                ; AReg = 4301
        cmp     eax,[I4]                ; compare 4301 and 4301
        jg      .L28                    ; if 4301 > 4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L29                    ; unconditionally jump
.L28:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L29:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I4]                ; AReg = 4301
        cmp     eax,[I3]                ; compare 4301 and -4301
        jg      .L30                    ; if 4301 > -4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L31                    ; unconditionally jump
.L30:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L31:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I4]                ; AReg = 4301
        cmp     eax,[I4]                ; compare 4301 and 4301
        jg      .L32                    ; if 4301 > 4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L33                    ; unconditionally jump
.L32:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L33:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I4]                ; AReg = 4301
        cmp     eax,[I4]                ; compare 4301 and 4301
        jg      .L34                    ; if 4301 > 4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L35                    ; unconditionally jump
.L34:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L35:                                           
        mov     [B1],eax                ; d = AReg

./output/178.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Sun Nov 27 09:52:21 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                                   
global  _start                          ; program stage1no178

_start:                                         
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at a
        call    ReadInt                 ; read int; value placed in eax
        mov     [I2],eax                ; store eax at b
        mov     eax,[I1]                ; AReg = a
        neg     eax                     ; AReg = -AReg
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I2]                ; AReg = b
        neg     eax                     ; AReg = -AReg
        cmp     eax,[T0]                ; compare T1 and T0
        jge     .L0                     ; if T1 >= T0 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                            
        mov     [B1],eax                ; d = AReg
        mov     eax,[I1]                ; AReg = a
        neg     eax                     ; AReg = -AReg
        cmp     eax,[I2]                ; compare T0 and b
        jge     .L2                     ; if T0 >= b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L3                     ; unconditionally jump
.L2:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L3:                                            
        mov     [B1],eax                ; d = AReg
        mov     eax,[I1]                ; AReg = a
        neg     eax                     ; AReg = -AReg
        cmp     eax,[I2]                ; compare T0 and b
        jge     .L4                     ; if T0 >= b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L5                     ; unconditionally jump
.L4:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L5:                                            
        mov     [B1],eax                ; d = AReg
        mov     eax,[I2]                ; AReg = b
        neg     eax                     ; AReg = -AReg
        cmp     eax,[I1]                ; compare T0 and a
        jge     .L6                     ; if T0 >= a then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L7                     ; unconditionally jump
.L6:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L7:                                            
        mov     [B1],eax                ; d = AReg
        mov     eax,[I1]                ; AReg = a
        cmp     eax,[I2]                ; compare a and b
        jge     .L8                     ; if a >= b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L9                     ; unconditionally jump
.L8:                                            
        mov     eax,[TRUE]              ; set eax to TRUE
.L9:                                            
        mov     [B1],eax                ; d = AReg
        mov     eax,[I1]                ; AReg = a
        cmp     eax,[I2]                ; compare a and b
        jge     .L10                    ; if a >= b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L11                    ; unconditionally jump
.L10:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L11:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I2]                ; AReg = b
        neg     eax                     ; AReg = -AReg
        cmp     eax,[I1]                ; compare T0 and a
        jge     .L12                    ; if T0 >= a then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L13                    ; unconditionally jump
.L12:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L13:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I1]                ; AReg = a
        cmp     eax,[I2]                ; compare a and b
        jge     .L14                    ; if a >= b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L15                    ; unconditionally jump
.L14:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L15:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I1]                ; AReg = a
        cmp     eax,[I2]                ; compare a and b
        jge     .L16                    ; if a >= b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L17                    ; unconditionally jump
.L16:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L17:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I3]                ; AReg = -4301
        cmp     eax,[I3]                ; compare -4301 and -4301
        jge     .L18                    ; if -4301 >= -4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L19                    ; unconditionally jump
.L18:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L19:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I3]                ; AReg = -4301
        cmp     eax,[I4]                ; compare -4301 and 4301
        jge     .L20                    ; if -4301 >= 4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L21                    ; unconditionally jump
.L20:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L21:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I3]                ; AReg = -4301
        cmp     eax,[I4]                ; compare -4301 and 4301
        jge     .L22                    ; if -4301 >= 4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L23                    ; unconditionally jump
.L22:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L23:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I4]                ; AReg = 4301
        cmp     eax,[I3]                ; compare 4301 and -4301
        jge     .L24                    ; if 4301 >= -4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L25                    ; unconditionally jump
.L24:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L25:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I4]                ; AReg = 4301
        cmp     eax,[I4]                ; compare 4301 and 4301
        jge     .L26                    ; if 4301 >= 4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L27                    ; unconditionally jump
.L26:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L27:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I4]                ; AReg = 4301
        cmp     eax,[I4]                ; compare 4301 and 4301
        jge     .L28                    ; if 4301 >= 4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L29                    ; unconditionally jump
.L28:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L29:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I4]                ; AReg = 4301
        cmp     eax,[I3]                ; compare 4301 and -4301
        jge     .L30                    ; if 4301 >= -4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L31                    ; unconditionally jump
.L30:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L31:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I4]                ; AReg = 4301
        cmp     eax,[I4]                ; compare 4301 and 4301
        jge     .L32                    ; if 4301 >= 4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L33                    ; unconditionally jump
.L32:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L33:                                           
        mov     [B1],eax                ; d = AReg
        mov     eax,[I4]                ; AReg = 4301
        cmp     eax,[I4]                ; compare 4301 and 4301
        jge     .L34                    ; if 4301 >= 4301 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L35                    ; unconditionally jump
.L34:                                           
        mov     eax,[TRUE]              ; set eax to TRUE
.L35:                                           
        mov     [B1],eax                ; d = AReg

