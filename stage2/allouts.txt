All Listing and Assembly Files

./output/201.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no201;   {needs a lot of temps}  
    2|  var a,b,c,d,e:integer;
    3|  begin    
    4|    read(b);
    5|    read(c);
    6|    read(d);
    7|    read(e);
    8|    a:=(b+c)+((c+d)+((d+e))) ;    
    9|    b:= a+c;
   10|    write(a);
   11|    write(b);
   12|  end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/202.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no202;
    2|  var y,z:integer;
    3|  begin
    4|    read(y);
    5|    while (y < 10) do
    6|      y:=y+1;
    7|    z:=y+1;
    8|    write(y);
    9|    write(z);
   10|  end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/203.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no203;
    2|  var x,y,a :integer;
    3|  begin
    4|    read(x);
    5|    read(y);
    6|    if (x<y) then
    7|      a := x+3;
    8|    else
    9|      a := y+5;
   10|    write(x);
   11|    write(y);
   12|    write(a);
   13|  end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/204.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no204;
    2|  var w,x,y,z:integer; a,b,c:integer;
    3|  begin
    4|    a := -1;
    5|    read(w);
    6|    read(x);
    7|    read(y);
    8|    read(z);
    9|    read(b);
   10|    read(c);
   11|    if ((x<y) and (w=z)) then
   12|      a := b*c;
   13|    write(a);
   14|  end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/205.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no205;
    2|  var x,y:integer;
    3|  begin
    4|    read(x);
    5|    read(y);
    6|    while (x > y) do
    7|      x:=x-3;
    8|    write(x);
    9|    write(y);
   10|  end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/206.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no206;
    2|  var x,a,b:integer;
    3|  begin
    4|    read(a);
    5|    read(x);
    6|    b := 3;
    7|    repeat
    8|      b:=a+b;
    9|    until(b>x);
   10|    write(b);
   11|  end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/207.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no207;
    2|  var x,y,a,b:integer;
    3|      c,d:integer;
    4|  begin
    5|    read(x);
    6|    read(a);
    7|    read(y);
    8|    read(b);
    9|    c := 0;
   10|    if x > a then
   11|      if (y < b) then
   12|        begin
   13|          c:=a+b;
   14|          d:=y+2;
   15|        end;
   16|    else
   17|      c:=1;
   18|      d:=y+3;
   19|    write(c);
   20|    write(d);
   21|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/208.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no208; {computes gcd}
    2|  var a,b,x,y:integer;
    3|  begin
    4|    read(x);
    5|    read(y);
    6|    if ((x>0) and (y>0)) then {x and y should be positive}
    7|      begin
    8|        a:=x;b:=y;
    9|        repeat
   10|          while (a > b) do a:=a-b;
   11|          while (b > a) do b:=b-a;
   12|        until (a = b);
   13|        write(x);
   14|        write(y);
   15|        write(a);
   16|        {a = b = gcd(x,y);}
   17|      end;
   18|    end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/209.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program  stage2no209;      
    2|         {demonstrates correct usage of Pascallite features} 
    3|  var   a,b,c,
    4|        d :integer;  
    5|  begin    
    6|    a := 3;    
    7|    d := a+b  *  c;    
    8|    b := a*b+c ;    
    9|    a := a+b+c;    
   10|    d := a*b*c;    d := a+b; 
   11|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/210.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no210;  {improper uses of Pascallite features.}
    2|  var x,y,z:integer;  why:boolean;
    3|  begin
    4|    if x then 
Error: Line 4: if predicate must be of type boolean

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/211.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no211;  {improper uses of Pascallite features.}
    2|  var x,y,z:integer;  why:boolean;
    3|  begin
    4|    if why then
    5|	   z:=0;    
    6|	else 
    7|	   w 
Error: Line 7: reference to undefined variable

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/212.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no212;  {improper uses of Pascallite features.}
    2|  var x,y,z:integer;  why:boolean;
    3|  begin
    4|    if why then
    5|	   z:=0;    
    6|	else 
    7|	   z := -3; else 
Error: Line 7: one of ";", "begin", "if", "read", "repeat", "while", "write", "end", or "until" expected

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/213.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no213;  {improper uses of Pascallite features.}
    2|  var x,y,z:integer;  why:boolean;
    3|  begin
    4|    if why then
    5|	   z:=0;    
    6|	else 
    7|	   z := -3; 
    8|	while why do 
    9|	  begin;
   10|  	    x := y + 2;
   11|  	    if x = 3 then
   12|	  end;                        {improper nesting of if statement}
   13|	else 
Error: Line 13: one of ";", "begin", "if", "read", "repeat", "while", "write", "end", or "until" expected

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/214.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no214;  {improper uses of Pascallite features.}
    2|  var x,y,z:integer;  why:boolean;
    3|  begin
    4|    x := 24;
    5|	if x > 0 then   {then clause may not be empty}
    6|	else d:
Error: Line 6: reference to undefined variable

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/215.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no215;  {improper uses of Pascallite features.}
    2|  var x,y,z:integer;  why:boolean;
    3|  begin
    4|    x := 24;
    5|	if x > 0 then  
    6|	   z:=0;
    7|	    
    8|	else ;          {can use null statement, though}
    9| 
   10|    begin;
   11|  	    if x = 3 then; end;  {improper nesting}
   12|	  else 
Error: Line 12: one of ";", "begin", "if", "read", "repeat", "while", "write", "end", or "until" expected

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/216.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no216;  {improper uses of Pascallite features.}
    2|  var x,y,z:integer;  why:boolean;
    3|  begin
    4|    x := 24;
    5|	if x > 0 then  
    6|	   z:=0;
    7|	    
    8|	else ;          {can use null statement, though}
    9| 
   10|    while (x > y)   {missing do}
   11|	 begin

Error: Line 11: do expected

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/217.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no217;
    2|  var x,y,a,b:integer;
    3|      c,d:integer;
    4|  begin
    5|    read(x);
    6|    read(a);
    7|    read(y);
    8|    read(b);
    9|    c := 0;
   10|    if x > a then
   11|      begin
   12|        if (y < b) then
   13|          begin
   14|            c:=a+b;
   15|            d:=y+2;
   16|          end;
   17|      end;
   18|    else
   19|      c:=1;
   20|    d:=y+3;
   21|    write(c);
   22|    write(d);
   23|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/218.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no218;
    2|var
    3|  a, b, c : integer;
    4|begin
    5|  read(a, b, c);
    6|  if (a < b) then
    7|    if (b < c) then
    8|      write(a, b, c);
    9|    else
   10|      if (a < c) then
   11|        write(a, c, b);
   12|      else
   13|        write(c, a, b);
   14|  else
   15|    if (a < c) then
   16|      write(b, a, c);
   17|    else
   18|      if (b < c) then
   19|        write(b, c, a);
   20|      else
   21|        write(c, b, a);
   22|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/219.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no219;
    2|var a,b,c,d,e:integer;
    3|begin    
    4|  begin
    5|    begin
    6|      read(a,b);
    7|      read(c);
    8|      read(d);
    9|      read(e);
   10|    end;
   11|  end;
   12|    write(a,b,c,d,e);
   13|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/220.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no220;
    2|var a,b,c,d,e:integer;
    3|begin    
    4|  read(b,c,d,e);
    5|  if a < b then
    6|    begin
    7|      a:=(b+c)+((c+d)+((d+e))) ;    
    8|    end;
    9|  else
   10|    b:= a+c;
   11|  write(a,b,c,d,e);
   12|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/221.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no221;
    2|var a,b,c,d,e:integer;
    3|begin    
    4|  read(b,c,d,e);
    5|  if a < b then
    6|    a:=(b+c)+((c+d)+((d+e))) ;    
    7|  else
    8|    begin
    9|      b:= a+c;
   10|    end;
   11|  write(a,b,c,d,e);
   12|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/222.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no222;
    2|var a,b,c,d,e:integer;
    3|    f:boolean;
    4|begin    
    5|  read(a,b,c,d,e);
    6|  f := a < b;
    7|  if f then
    8|    a:=(b+c)+((c+d)+((d+e))) ;    
    9|  else
   10|    b:= a+c;
   11|  write(a,b,c,d,e,f);
   12|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/223.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no223;
    2|var a, month, year:integer;
    3|begin    
    4|  read(month,year);
    5|  if (month = 1) or (month = 2) then
    6|    begin
    7|      a := month + 10;
    8|      year := year - 1;
    9|    end;
   10|  else
   11|    begin
   12|      a := month - 2;
   13|      year := year + 1;
   14|    end;
   15|  write(a,month,year);
   16|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/224.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no224;
    2|var a,b,c:integer;
    3|    f:boolean;
    4|begin    
    5|  read(a,b);
    6|  f := a < b;
    7|  c := 0;
    8|  if f then
    9|    c := a;
   10|  else
   11|    c := b;
   12|  write(a,b,c);
   13|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/225.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no225;
    2|var a,b,gcd:integer;
    3|begin    
    4|  read(a,b);
    5|
    6|  if a < 0 then
    7|    a := a * -1;
    8|
    9|  if b < 0 then
   10|    b := b * -1;
   11|
   12|  if a < b then
   13|    gcd := a;
   14|  else
   15|    gcd := b;
   16|
   17|  while (a mod gcd <> 0) or (b mod gcd <> 0) do
   18|    begin
   19|      gcd := gcd - 1;
   20|      write(gcd);
   21|    end;
   22|
   23|  write(a,b,gcd);
   24|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/226.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no226;
    2|var a:integer;
    3|    f:boolean;
    4|begin    
    5|  a := 0;
    6|  f := a < 10;
    7|  while f do
    8|    begin
    9|      a := a + 1;
   10|      f := a < 10;
   11|      write(f,a);      
   12|    end;
   13|  write(a,f);      
   14|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/227.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no227;
    2|var a:integer;
    3|begin    
    4|  a := 0;
    5|  if true then
    6|    a := 1;
    7|  write(a);
    8|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/228.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no228;
    2|var a:integer;
    3|begin    
    4|  a := 0;
    5|  if false then
    6|    ;
    7|  else
    8|    a := 1;
    9|  write(a);
   10|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/229.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no229;
    2|var a:integer;
    3|begin    
    4|  a := 0;
    5|  while a do 
Error: Line 5: while predicate must be of type boolean

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/230.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no230;
    2|const month=12;
    3|begin    
    4|  while true do;
    5|  write(month);
    6|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/231.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no231;
    2|const month=12;
    3|begin    
    4|  while false do
    5|    begin
    6|      ;
    7|    end;
    8|  write(month);
    9|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/232.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no232;
    2|var
    3|  a,b:integer;
    4|  f:boolean;
    5|begin    
    6|  a := 0;
    7|  repeat
    8|    a := a + 1;
    9|    write(a);
   10|    f := a = 10;
   11|    b := a;
   12|  until f;
   13|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/233.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no233;
    2|begin    
    3|  repeat
    4|    ;
    5|  until false;
    6|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/234.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no234;
    2|begin    
    3|  repeat
    4|    ;
    5|  until true;
    6|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/235.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no235;
    2|var t:integer;
    3|begin    
    4|  t := 0;
    5|  repeat
    6|    t := 1;
    7|    write(t);
    8|  until t; 
Error: Line 8: predicate of until must be of type boolean

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/236.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no236;
    2|begin    
    3|  begin
    4|  end;
    5|  begin
    6|  end.

Error: Line 6: non-keyword id, "read", or "write" expected 

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/237.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no237;
    2|  var
    3|var000,var001,var002,var003,var004,var005,var006,var007,var008,var009,
    4|var010,var011,var012,var013,var014,var015,var016,var017,var018,var019,
    5|var020,var021,var022,var023,var024,var025,var026,var027,var028,var029,
    6|var030,var031,var032,var033,var034,var035,var036,var037,var038,var039,
    7|var040,var041,var042,var043,var044,var045,var046,var047,var048,var049,
    8|var050,var051,small
    9|: integer;
   10|begin
   11|  read(
   12|       var000,var001,var002,var003,var004,var005,var006,var007,var008,var009,
   13|       var010,var011,var012,var013,var014,var015,var016,var017,var018,var019,
   14|       var020,var021,var022,var023,var024,var025,var026,var027,var028,var029,
   15|       var030,var031,var032,var033,var034,var035,var036,var037,var038,var039,
   16|       var040,var041,var042,var043,var044,var045,var046,var047,var048,var049,
   17|       var050,var051
   18|      );
   19|  if var000 < var001 then begin
   20|  if var000 < var002 then begin
   21|  if var000 < var003 then begin
   22|  if var000 < var004 then begin
   23|  if var000 < var005 then begin
   24|  if var000 < var006 then begin
   25|  if var000 < var007 then begin
   26|  if var000 < var008 then begin
   27|  if var000 < var009 then begin
   28|  if var000 < var010 then begin
   29|  if var000 < var011 then begin
   30|  if var000 < var012 then begin
   31|  if var000 < var013 then begin
   32|  if var000 < var014 then begin
   33|  if var000 < var015 then begin
   34|  if var000 < var016 then begin
   35|  if var000 < var017 then begin
   36|  if var000 < var018 then begin
   37|  if var000 < var019 then begin
   38|  if var000 < var020 then begin
   39|  if var000 < var021 then begin
   40|  if var000 < var022 then begin
   41|  if var000 < var023 then begin
   42|  if var000 < var024 then begin
   43|  if var000 < var025 then begin
   44|  if var000 < var026 then begin
   45|  if var000 < var027 then begin
   46|  if var000 < var028 then begin
   47|  if var000 < var029 then begin
   48|  if var000 < var030 then begin
   49|  if var000 < var031 then begin
   50|  if var000 < var032 then begin
   51|  if var000 < var033 then begin
   52|  if var000 < var034 then begin
   53|  if var000 < var035 then begin
   54|  if var000 < var036 then begin
   55|  if var000 < var037 then begin
   56|  if var000 < var038 then begin
   57|  if var000 < var039 then begin
   58|  if var000 < var040 then begin
   59|  if var000 < var041 then begin
   60|  if var000 < var042 then begin
   61|  if var000 < var043 then begin
   62|  if var000 < var044 then begin
   63|  if var000 < var045 then begin
   64|  if var000 < var046 then begin
   65|  if var000 < var047 then begin
   66|  if var000 < var048 then begin
   67|  if var000 < var049 then begin
   68|  if var000 < var050 then begin
   69|  if var000 < var051 then begin
   70|    small := var000;
   71|  end; end; end; end; end; end; end; end; end; end;
   72|  end; end; end; end; end; end; end; end; end; end;
   73|  end; end; end; end; end; end; end; end; end; end;
   74|  end; end; end; end; end; end; end; end; end; end;
   75|  end; end; end; end; end; end; end; end; end; end;
   76|  end;
   77|  write(small);
   78|end  .

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/238.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no238;
    2|  var
    3|var000,var001,var002,var003,var004,var005,var006,var007,var008,var009,
    4|var010,var011,var012,var013,var014,var015,var016,var017,var018,var019,
    5|var020,var021,var022,var023,var024,var025,var026,var027,var028,var029,
    6|var030,var031,var032,var033,var034,var035,var036,var037,var038,var039,
    7|var040,var041,var042,var043,var044,var045,var046,var047,var048,var049,
    8|var050,var051,small
    9|: integer;
   10|begin
   11|  read(
   12|       var000,var001,var002,var003,var004,var005,var006,var007,var008,var009,
   13|       var010,var011,var012,var013,var014,var015,var016,var017,var018,var019,
   14|       var020,var021,var022,var023,var024,var025,var026,var027,var028,var029,
   15|       var030,var031,var032,var033,var034,var035,var036,var037,var038,var039,
   16|       var040,var041,var042,var043,var044,var045,var046,var047,var048,var049,
   17|       var050,var051
   18|      );
   19|
   20|  if var000 < var001 then
   21|  if var000 < var002 then
   22|  if var000 < var003 then
   23|  if var000 < var004 then
   24|  if var000 < var005 then
   25|  if var000 < var006 then
   26|  if var000 < var007 then
   27|  if var000 < var008 then
   28|  if var000 < var009 then
   29|  if var000 < var010 then
   30|  if var000 < var011 then
   31|  if var000 < var012 then
   32|  if var000 < var013 then
   33|  if var000 < var014 then
   34|  if var000 < var015 then
   35|  if var000 < var016 then
   36|  if var000 < var017 then
   37|  if var000 < var018 then
   38|  if var000 < var019 then
   39|  if var000 < var020 then
   40|  if var000 < var021 then
   41|  if var000 < var022 then
   42|  if var000 < var023 then
   43|  if var000 < var024 then
   44|  if var000 < var025 then
   45|  if var000 < var026 then
   46|  if var000 < var027 then
   47|  if var000 < var028 then
   48|  if var000 < var029 then
   49|  if var000 < var030 then
   50|  if var000 < var031 then
   51|  if var000 < var032 then
   52|  if var000 < var033 then
   53|  if var000 < var034 then
   54|  if var000 < var035 then
   55|  if var000 < var036 then
   56|  if var000 < var037 then
   57|  if var000 < var038 then
   58|  if var000 < var039 then
   59|  if var000 < var040 then
   60|  if var000 < var041 then
   61|  if var000 < var042 then
   62|  if var000 < var043 then
   63|  if var000 < var044 then
   64|  if var000 < var045 then
   65|  if var000 < var046 then
   66|  if var000 < var047 then
   67|  if var000 < var048 then
   68|  if var000 < var049 then
   69|  if var000 < var050 then
   70|  if var000 < var051 then
   71|    small := var000;
   72|
   73|  write(small);
   74|end  .

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/239.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no239;   {CS 4301 Lab 11; determine the date of Easter}
    2|  var x,a,b,c,d,e,f,g,h,i,k,l,m,n,p:integer;
    3|      counter:integer;
    4|  begin    
    5|    counter := 0;
    6|    repeat
    7|      read(x);
    8|      a := x mod 19;
    9|      b := x div 100;
   10|      c := x mod 100;
   11|      d := b div 4;
   12|      e := b mod 4;
   13|      f := (b + 8) div 25;
   14|      g := (b - f + 1) div 3;
   15|      h := (19 * a + b - d - g + 15) mod 30;
   16|      i := c div 4;
   17|      k := c mod 4;
   18|      l := (32 + 2 * e + 2 * i - h - k) mod 7;
   19|      m := (a + 11 * h + 22 * l) div 451;
   20|      n := (h + l - 7 * m + 114) div 31;
   21|      p := (h + l - 7 * m + 114) mod 31;
   22|      write(n);
   23|      p := p + 1;
   24|      write(p);
   25|      write(x);
   26|      counter := counter + 1;
   27|    until counter = 40;
   28|  end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/240.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no240;   {CS 4301 Lab 12; determine GCD}
    2|  var h, u, v, gcd, rem:integer;
    3|  begin    
    4|    read(h);
    5|    while h > 0 do
    6|      begin
    7|        read(u, v);
    8|        write(u, v);
    9|
   10|        if u < 0 then
   11|          u := u * -1;
   12|
   13|        if (v < 0) then
   14|          v := v * -1;
   15|          
   16|        if (u = 0) then
   17|          gcd := v;
   18|
   19|        else if v = 0 then
   20|          gcd := u;
   21|
   22|        else
   23|          begin
   24|            repeat
   25|              rem := u mod v;
   26|              u := v;
   27|              v := rem;
   28|            until rem = 0;
   29|            gcd := u;
   30|          end;
   31|
   32|        write(gcd);
   33|      
   34|        h := h - 1;
   35|      end;
   36|  end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/241.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no241;
    2|  const largest = 2147483647;
    3|  var   first, second, ct : integer;
    4|begin    
    5|  read(first);
    6|  read(second);
    7|  ct := 0;
    8|  while ct < 47 do
    9|    begin
   10|      write(first);
   11|      second := first + second;
   12|      first := second - first;
   13|      ct := ct + 1;
   14|    end;
   15|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/242.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no242;
    2|  var m, n, rem:integer;
    3|begin
    4|  read(m);
    5|  read(n);
    6|  write(m);
    7|  write(n);
    8|
    9|  if m < 0 then
   10|    m := -1 * m;
   11|  if n < 0 then
   12|    n := -n;
   13|
   14|  rem := m mod n;
   15|  while not (rem = 0) do
   16|    begin
   17|      m := n;
   18|      n := rem;
   19|      rem := m mod n;
   20|    end;
   21|  write(n);
   22|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/243.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no243;
    2|  var m, n, rem:integer;
    3|      done:boolean;
    4|begin
    5|  read(m);
    6|  read(n);
    7|  write(m);
    8|  write(n);
    9|
   10|  if m < 0 then
   11|    m := -1 * m;
   12|  if n < 0 then
   13|    n := -n;
   14|
   15|  rem := m mod n;
   16|  done := rem = 0;
   17|  while not done do
   18|    begin
   19|      m := n;
   20|      n := rem;
   21|      rem := m mod n;
   22|      done := rem = 0;
   23|    end;
   24|  write(n);
   25|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/244.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no244;
    2|  var m, n, rem:integer;
    3|      done:boolean;
    4|begin
    5|  read(m);
    6|  read(n);
    7|  write(m);
    8|  write(n);
    9|
   10|  if m < 0 then
   11|    m := -1 * m;
   12|  if n < 0 then
   13|    n := -n;
   14|
   15|  repeat
   16|      rem := m mod n;
   17|      m := n;
   18|      n := rem;
   19|  until rem = 0;
   20|  write(m);
   21|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/245.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no245;
    2|  var m, n, rem:integer;
    3|      done:boolean;
    4|begin
    5|  read(m);
    6|  read(n);
    7|  write(m);
    8|  write(n);
    9|
   10|  if m < 0 then
   11|    m := -1 * m;
   12|  if n < 0 then
   13|    n := -n;
   14|
   15|  repeat
   16|    begin
   17|      rem := m mod n;
   18|      done := rem = 0;
   19|      if not done then
   20|        begin
   21|          m := n;
   22|          n := rem;
   23|        end;
   24|    end;
   25|  until done;
   26|  write(n);
   27|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/246.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no246;
    2|  var m, n, cmp:integer;
    3|begin
    4|  read(m);
    5|  read(n);
    6|  write(m);
    7|  write(n);
    8|
    9|  if m < n then
   10|    cmp := -1;
   11|  else if m = n then
   12|    cmp := 0;
   13|  else
   14|    cmp := 1;
   15|
   16|  write(cmp);
   17|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/247.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no247;
    2|  var m, n, cmp:integer;
    3|begin
    4|  read(m);
    5|  read(n);
    6|  write(m);
    7|  write(n);
    8|
    9|  cmp := 0;
   10|  if m <= n then
   11|    if m = n then
   12|      cmp := 1;
   13|    else
   14|      cmp := 2;
   15|  write(cmp);
   16|
   17|  cmp := 0;
   18|  if m <= n then
   19|    begin
   20|      if m = n then
   21|        cmp := 1;
   22|    end;
   23|  else
   24|    cmp := 2;
   25|  write(cmp);
   26|
   27|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/248.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no248;
    2|  var m, n, cmp, x, y:integer;
    3|begin
    4|  read(x);
    5|  read(y);
    6|  write(x);
    7|  write(y);
    8|
    9|  cmp := 0;
   10|  m := x; n := y;
   11|  if m < n then
   12|    cmp := cmp + 1;
   13|  cmp := cmp + 2;
   14|  write(cmp);
   15|
   16|  cmp := 0;
   17|  m := x; n := y;
   18|  while m < n do
   19|    begin
   20|      m := m + 1;
   21|      if m < n then
   22|        cmp := cmp + 1;
   23|    end;
   24|  write(cmp);
   25|
   26|  cmp := 0;
   27|  m := x; n := y;
   28|  if m < n then
   29|    cmp := 1;
   30|  ;
   31|  write(cmp);
   32|
   33|  cmp := 0;
   34|  m := x; n := y;
   35|  if m < n then
   36|    cmp := 1;
   37|  write(cmp);
   38|
   39|  cmp := 0;
   40|  m := x; n := y;
   41|  if m < n then
   42|    cmp := 1;
   43|  if m = n then
   44|    cmp := 2;
   45|  write(cmp);
   46|
   47|  cmp := 0;
   48|  m := x; n := y;
   49|  if m < n then
   50|    cmp := 1;
   51|  while m < n do
   52|    begin
   53|      m := m + 1;
   54|      if m < n then
   55|        cmp := cmp + 1;
   56|    end;
   57|  write(cmp);
   58|
   59|  cmp := 0;
   60|  m := x; n := y;
   61|  if m < n then
   62|    cmp := 1;
   63|  repeat
   64|    m := m + 1;
   65|    if m < n then
   66|      cmp := cmp + 1;
   67|  until m >= n;
   68|  write(cmp);
   69|
   70|  cmp := 0;
   71|  m := x; n := y;
   72|  if m < n then
   73|    cmp := 1;
   74|  begin
   75|    write(cmp);
   76|  end;
   77|
   78|  cmp := 0;
   79|  m := x; n := y;
   80|  if m < n then
   81|    cmp := 1;
   82|  read(cmp);
   83|  write(cmp);
   84|
   85|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/249.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|program stage2no249;
    2|  const n = 10;
    3|  var pass, temp, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9 : integer;
    4|begin
    5|  read(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
    6|  write(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
    7|
    8|  pass := 0;
    9|  while pass < n do
   10|    begin
   11|      if v0 > v1 then begin temp := v0; v0 := v1; v1 := temp; end;
   12|      if v1 > v2 then begin temp := v1; v1 := v2; v2 := temp; end;
   13|      if v2 > v3 then begin temp := v2; v2 := v3; v3 := temp; end;
   14|      if v3 > v4 then begin temp := v3; v3 := v4; v4 := temp; end;
   15|      if v4 > v5 then begin temp := v4; v4 := v5; v5 := temp; end;
   16|      if v5 > v6 then begin temp := v5; v5 := v6; v6 := temp; end;
   17|      if v6 > v7 then begin temp := v6; v6 := v7; v7 := temp; end;
   18|      if v7 > v8 then begin temp := v7; v7 := v8; v8 := temp; end;
   19|      if v8 > v9 then begin temp := v8; v8 := v9; v9 := temp; end;
   20|      pass := pass + 1;
   21|    end;
   22|
   23|  write(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
   24|end.

COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/250.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|{contributed by Joel King and William Blazier, 2021-Dec-05}
    2|program stage2no250;
    3|begin    
    4|  begin
    5|  end;
    6|  begin
    7|  end. 
Error: Line 7: non-keyword id, "read", or "write" expected 

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/251.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|{contributed by Joel King and William Blazier, 2021-Dec-05}
    2|program stage2no251;
    3|begin    
    4|end; 
Error: Line 4: {Final end lacks period, has semicolon instead.}

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/252.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|{contributed by Joel King and William Blazier, 2021-Dec-05}
    2|program stage2no252;
    3|begin    
    4|  begin
    5|  end;
    6|  begin
    7|  end;
    8|{Missing the final "end."}

Error: Line 8: reference to undefined variable

COMPILATION TERMINATED      1 ERROR ENCOUNTERED

./output/253.my.lst
------------------------------
STAGE2:  Kangmin Kim, Jeff Caldwell   Wed Dec  7 00:20:48 2022

LINE NO.              SOURCE STATEMENT

    1|{contributed by Mason Barnhill, 2022-Dec-2}
    2|program mytest; {should allocate memory for exactly 2 constants}
    3|   const
    4|      s = -3;
    5|      a = 2;
    6|   var
    7|      t,b:integer;
    8|   begin
    9|      t := s + -3;
   10|      b := a + 2;
   11|      write(t,b);
   12|   end.
COMPILATION TERMINATED      0 ERRORS ENCOUNTERED

./output/201.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no201

_start:                                 
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at b
        call    ReadInt                 ; read int; value placed in eax
        mov     [I2],eax                ; store eax at c
        call    ReadInt                 ; read int; value placed in eax
        mov     [I3],eax                ; store eax at d
        call    ReadInt                 ; read int; value placed in eax
        mov     [I4],eax                ; store eax at e
        mov     eax,[I1]                ; AReg = b
        add     eax,[I2]                ; AReg = b + c
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I2]                ; AReg = c
        add     eax,[I3]                ; AReg = c + d
        mov     [T1],eax                ; deassign AReg
        mov     eax,[I3]                ; AReg = d
        add     eax,[I4]                ; AReg = d + e
        add     eax,[T1]                ; AReg = T2 + T1
        add     eax,[T0]                ; AReg = T1 + T0
        mov     [I0],eax                ; a = AReg
        add     eax,[I2]                ; AReg = a + c
        mov     [I1],eax                ; b = AReg
        mov     eax,[I0]                ; load a in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I1]                ; load b in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                    
SECTION .data                           

SECTION .bss                            
T0      resd    1                       ; T0
T1      resd    1                       ; T1
I0      resd    1                       ; a
I1      resd    1                       ; b
I2      resd    1                       ; c
I3      resd    1                       ; d
I4      resd    1                       ; e

./output/202.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no202

_start:                                 
        call    ReadInt                 ; read int; value placed in eax
        mov     [I0],eax                ; store eax at y
.L0:                                    ; while
        mov     eax,[I0]                ; AReg = y
        cmp     eax,[I2]                ; compare y and 10
        jl      .L1                     ; if y < 10 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L2                     ; unconditionally jump
.L1:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L2:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L3                     ; if T0 is false then jump to end while
        mov     eax,[I0]                ; AReg = y
        add     eax,[I3]                ; AReg = y + 1
        mov     [I0],eax                ; y = AReg
        jmp     .L0                     ; end while
.L3:                                    
        mov     eax,[I0]                ; AReg = y
        add     eax,[I3]                ; AReg = y + 1
        mov     [I1],eax                ; z = AReg
        mov     eax,[I0]                ; load y in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I1]                ; load z in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                    
SECTION .data                           
I3      dd      1                       ; 1
I2      dd      10                      ; 10
FALSE   dd      0                       ; false
TRUE    dd      -1                      ; true

SECTION .bss                            
I0      resd    1                       ; y
I1      resd    1                       ; z

./output/203.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no203

_start:                                 
        call    ReadInt                 ; read int; value placed in eax
        mov     [I0],eax                ; store eax at x
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at y
        mov     eax,[I0]                ; AReg = x
        cmp     eax,[I1]                ; compare x and y
        jl      .L0                     ; if x < y then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L2                     ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = x
        add     eax,[I3]                ; AReg = x + 3
        mov     [I2],eax                ; a = AReg
        jmp     .L3                     ; jump to end if
.L2:                                    ; else
        mov     eax,[I1]                ; AReg = y
        add     eax,[I4]                ; AReg = y + 5
        mov     [I2],eax                ; a = AReg
.L3:                                    ; end if
        mov     eax,[I0]                ; load x in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I1]                ; load y in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I2]                ; load a in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                    
SECTION .data                           
I3      dd      3                       ; 3
I4      dd      5                       ; 5
FALSE   dd      0                       ; false
TRUE    dd      -1                      ; true

SECTION .bss                            
I2      resd    1                       ; a
I0      resd    1                       ; x
I1      resd    1                       ; y

./output/204.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no204

_start:                                 
        mov     eax,[I7]                ; AReg = -1
        mov     [I4],eax                ; a = AReg
        call    ReadInt                 ; read int; value placed in eax
        mov     [I0],eax                ; store eax at w
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at x
        call    ReadInt                 ; read int; value placed in eax
        mov     [I2],eax                ; store eax at y
        call    ReadInt                 ; read int; value placed in eax
        mov     [I3],eax                ; store eax at z
        call    ReadInt                 ; read int; value placed in eax
        mov     [I5],eax                ; store eax at b
        call    ReadInt                 ; read int; value placed in eax
        mov     [I6],eax                ; store eax at c
        mov     eax,[I1]                ; AReg = x
        cmp     eax,[I2]                ; compare x and y
        jl      .L0                     ; if x < y then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                    
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I0]                ; AReg = w
        cmp     eax,[I3]                ; compare w and z
        je      .L2                     ; if w = z then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L3                     ; unconditionally jump
.L2:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L3:                                    
        and     eax,[T0]                ; AReg = T1 and T0
        cmp     eax,0                   ; compare eax to 0
        je      .L4                     ; if T0 is false then jump to end of if
        mov     eax,[I5]                ; AReg = b
        imul    dword [I6]              ; AReg = b * c
        mov     [I4],eax                ; a = AReg
.L4:                                    ; end if
        mov     eax,[I4]                ; load a in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                    
SECTION .data                           
I7      dd      -1                      ; -1
FALSE   dd      0                       ; false
TRUE    dd      -1                      ; true

SECTION .bss                            
T0      resd    1                       ; T0
I4      resd    1                       ; a
I5      resd    1                       ; b
I6      resd    1                       ; c
I0      resd    1                       ; w
I1      resd    1                       ; x
I2      resd    1                       ; y
I3      resd    1                       ; z

./output/205.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no205

_start:                                 
        call    ReadInt                 ; read int; value placed in eax
        mov     [I0],eax                ; store eax at x
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at y
.L0:                                    ; while
        mov     eax,[I0]                ; AReg = x
        cmp     eax,[I1]                ; compare x and y
        jg      .L1                     ; if x > y then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L2                     ; unconditionally jump
.L1:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L2:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L3                     ; if T0 is false then jump to end while
        mov     eax,[I0]                ; AReg = x
        sub     eax,[I2]                ; AReg = x - 3
        mov     [I0],eax                ; x = AReg
        jmp     .L0                     ; end while
.L3:                                    
        mov     eax,[I0]                ; load x in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I1]                ; load y in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                    
SECTION .data                           
I2      dd      3                       ; 3
FALSE   dd      0                       ; false
TRUE    dd      -1                      ; true

SECTION .bss                            
I0      resd    1                       ; x
I1      resd    1                       ; y

./output/206.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no206

_start:                                 
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at a
        call    ReadInt                 ; read int; value placed in eax
        mov     [I0],eax                ; store eax at x
        mov     eax,[I3]                ; AReg = 3
        mov     [I2],eax                ; b = AReg
.L0:                                    ; repeat
        mov     eax,[I1]                ; AReg = a
        add     eax,[I2]                ; AReg = a + b
        mov     [I2],eax                ; b = AReg
        cmp     eax,[I0]                ; compare b and x
        jg      .L1                     ; if b > x then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L2                     ; unconditionally jump
.L1:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L2:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L0                     ; until T0 is true
        mov     eax,[I2]                ; load b in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                    
SECTION .data                           
I3      dd      3                       ; 3
FALSE   dd      0                       ; false
TRUE    dd      -1                      ; true

SECTION .bss                            
I1      resd    1                       ; a
I2      resd    1                       ; b
I0      resd    1                       ; x

./output/207.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no207

_start:                                 
        call    ReadInt                 ; read int; value placed in eax
        mov     [I0],eax                ; store eax at x
        call    ReadInt                 ; read int; value placed in eax
        mov     [I2],eax                ; store eax at a
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at y
        call    ReadInt                 ; read int; value placed in eax
        mov     [I3],eax                ; store eax at b
        mov     eax,[I6]                ; AReg = 0
        mov     [I4],eax                ; c = AReg
        mov     eax,[I0]                ; AReg = x
        cmp     eax,[I2]                ; compare x and a
        jg      .L0                     ; if x > a then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L2                     ; if T0 is false then jump to end of if
        mov     eax,[I1]                ; AReg = y
        cmp     eax,[I3]                ; compare y and b
        jl      .L3                     ; if y < b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L4                     ; unconditionally jump
.L3:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L4:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L5                     ; if T0 is false then jump to end of if
        mov     eax,[I2]                ; AReg = a
        add     eax,[I3]                ; AReg = a + b
        mov     [I4],eax                ; c = AReg
        mov     eax,[I1]                ; AReg = y
        add     eax,[I7]                ; AReg = y + 2
        mov     [I5],eax                ; d = AReg
        jmp     .L6                     ; jump to end if
.L5:                                    ; else
        mov     eax,[I8]                ; AReg = 1
        mov     [I4],eax                ; c = AReg
.L6:                                    ; end if
.L2:                                    ; end if
        mov     eax,[I1]                ; AReg = y
        add     eax,[I9]                ; AReg = y + 3
        mov     [I5],eax                ; d = AReg
        mov     eax,[I4]                ; load c in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I5]                ; load d in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                    
SECTION .data                           
I6      dd      0                       ; 0
I8      dd      1                       ; 1
I7      dd      2                       ; 2
I9      dd      3                       ; 3
FALSE   dd      0                       ; false
TRUE    dd      -1                      ; true

SECTION .bss                            
I2      resd    1                       ; a
I3      resd    1                       ; b
I4      resd    1                       ; c
I5      resd    1                       ; d
I0      resd    1                       ; x
I1      resd    1                       ; y

./output/208.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no208

_start:                                 
        call    ReadInt                 ; read int; value placed in eax
        mov     [I2],eax                ; store eax at x
        call    ReadInt                 ; read int; value placed in eax
        mov     [I3],eax                ; store eax at y
        mov     eax,[I2]                ; AReg = x
        cmp     eax,[I4]                ; compare x and 0
        jg      .L0                     ; if x > 0 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                    
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I3]                ; AReg = y
        cmp     eax,[I4]                ; compare y and 0
        jg      .L2                     ; if y > 0 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L3                     ; unconditionally jump
.L2:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L3:                                    
        and     eax,[T0]                ; AReg = T1 and T0
        cmp     eax,0                   ; compare eax to 0
        je      .L4                     ; if T0 is false then jump to end of if
        mov     eax,[I2]                ; AReg = x
        mov     [I0],eax                ; a = AReg
        mov     eax,[I3]                ; AReg = y
        mov     [I1],eax                ; b = AReg
.L5:                                    ; repeat
.L6:                                    ; while
        mov     eax,[I0]                ; AReg = a
        cmp     eax,[I1]                ; compare a and b
        jg      .L7                     ; if a > b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L8                     ; unconditionally jump
.L7:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L8:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L9                     ; if T0 is false then jump to end while
        mov     eax,[I0]                ; AReg = a
        sub     eax,[I1]                ; AReg = a - b
        mov     [I0],eax                ; a = AReg
        jmp     .L6                     ; end while
.L9:                                    
.L10:                                   ; while
        mov     eax,[I1]                ; AReg = b
        cmp     eax,[I0]                ; compare b and a
        jg      .L11                    ; if b > a then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L12                    ; unconditionally jump
.L11:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L12:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L13                    ; if T0 is false then jump to end while
        mov     eax,[I1]                ; AReg = b
        sub     eax,[I0]                ; AReg = b - a
        mov     [I1],eax                ; b = AReg
        jmp     .L10                    ; end while
.L13:                                   
        mov     eax,[I0]                ; AReg = a
        cmp     eax,[I1]                ; compare a and b
        je      .L14                    ; if a = b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L15                    ; unconditionally jump
.L14:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L15:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L5                     ; until T0 is true
        mov     eax,[I2]                ; load x in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I3]                ; load y in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I0]                ; load a in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
.L4:                                    ; end if
        Exit    {0}
                    
SECTION .data                           
I4      dd      0                       ; 0
FALSE   dd      0                       ; false
TRUE    dd      -1                      ; true

SECTION .bss                            
T0      resd    1                       ; T0
I0      resd    1                       ; a
I1      resd    1                       ; b
I2      resd    1                       ; x
I3      resd    1                       ; y

./output/209.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no209

_start:                                 
        mov     eax,[I4]                ; AReg = 3
        mov     [I0],eax                ; a = AReg
        mov     eax,[I1]                ; AReg = b
        imul    dword [I2]              ; AReg = b * c
        add     eax,[I0]                ; AReg = T0 + a
        mov     [I3],eax                ; d = AReg
        mov     eax,[I0]                ; AReg = a
        imul    dword [I1]              ; AReg = a * b
        add     eax,[I2]                ; AReg = T0 + c
        mov     [I1],eax                ; b = AReg
        add     eax,[I0]                ; AReg = b + a
        add     eax,[I2]                ; AReg = T0 + c
        mov     [I0],eax                ; a = AReg
        imul    dword [I1]              ; AReg = a * b
        imul    dword [I2]              ; AReg = T0 * c
        mov     [I3],eax                ; d = AReg
        mov     eax,[I0]                ; AReg = a
        add     eax,[I1]                ; AReg = a + b
        mov     [I3],eax                ; d = AReg
        Exit    {0}
                    
SECTION .data                           
I4      dd      3                       ; 3

SECTION .bss                            
I0      resd    1                       ; a
I1      resd    1                       ; b
I2      resd    1                       ; c
I3      resd    1                       ; d

./output/210.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no210

_start:                                 

./output/211.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no211

_start:                                 
        mov     eax,[B0]                ; AReg = why
        cmp     eax,0                   ; compare eax to 0
        je      .L0                     ; if why is false then jump to end of if
        mov     eax,[I3]                ; AReg = 0
        mov     [I2],eax                ; z = AReg
        jmp     .L1                     ; jump to end if
.L0:                                    ; else

./output/212.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no212

_start:                                 
        mov     eax,[B0]                ; AReg = why
        cmp     eax,0                   ; compare eax to 0
        je      .L0                     ; if why is false then jump to end of if
        mov     eax,[I3]                ; AReg = 0
        mov     [I2],eax                ; z = AReg
        jmp     .L1                     ; jump to end if
.L0:                                    ; else
        mov     eax,[I4]                ; AReg = -3
        mov     [I2],eax                ; z = AReg
.L1:                                    ; end if

./output/213.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no213

_start:                                 
        mov     eax,[B0]                ; AReg = why
        cmp     eax,0                   ; compare eax to 0
        je      .L0                     ; if why is false then jump to end of if
        mov     eax,[I3]                ; AReg = 0
        mov     [I2],eax                ; z = AReg
        jmp     .L1                     ; jump to end if
.L0:                                    ; else
        mov     eax,[I4]                ; AReg = -3
        mov     [I2],eax                ; z = AReg
.L1:                                    ; end if
.L2:                                    ; while
        mov     eax,[B0]                ; AReg = why
        cmp     eax,0                   ; compare eax to 0
        je      .L3                     ; if why is false then jump to end while
        mov     eax,[I1]                ; AReg = y
        add     eax,[I5]                ; AReg = y + 2
        mov     [I0],eax                ; x = AReg
        cmp     eax,[I6]                ; compare x and 3
        je      .L4                     ; if x = 3 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L5                     ; unconditionally jump
.L4:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L5:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L6                     ; if T0 is false then jump to end of if
.L6:                                    ; end if
        jmp     .L2                     ; end while
.L3:                                    

./output/214.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no214

_start:                                 
        mov     eax,[I3]                ; AReg = 24
        mov     [I0],eax                ; x = AReg
        cmp     eax,[I4]                ; compare x and 0
        jg      .L0                     ; if x > 0 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L2                     ; if T0 is false then jump to end of if
        jmp     .L3                     ; jump to end if
.L2:                                    ; else

./output/215.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no215

_start:                                 
        mov     eax,[I3]                ; AReg = 24
        mov     [I0],eax                ; x = AReg
        cmp     eax,[I4]                ; compare x and 0
        jg      .L0                     ; if x > 0 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L2                     ; if T0 is false then jump to end of if
        mov     eax,[I4]                ; AReg = 0
        mov     [I2],eax                ; z = AReg
        jmp     .L3                     ; jump to end if
.L2:                                    ; else
.L3:                                    ; end if
        mov     eax,[I0]                ; AReg = x
        cmp     eax,[I5]                ; compare x and 3
        je      .L4                     ; if x = 3 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L5                     ; unconditionally jump
.L4:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L5:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L6                     ; if T0 is false then jump to end of if
.L6:                                    ; end if

./output/216.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no216

_start:                                 
        mov     eax,[I3]                ; AReg = 24
        mov     [I0],eax                ; x = AReg
        cmp     eax,[I4]                ; compare x and 0
        jg      .L0                     ; if x > 0 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L2                     ; if T0 is false then jump to end of if
        mov     eax,[I4]                ; AReg = 0
        mov     [I2],eax                ; z = AReg
        jmp     .L3                     ; jump to end if
.L2:                                    ; else
.L3:                                    ; end if
.L4:                                    ; while
        mov     eax,[I0]                ; AReg = x
        cmp     eax,[I1]                ; compare x and y
        jg      .L5                     ; if x > y then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L6                     ; unconditionally jump
.L5:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L6:                                    

./output/217.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no217

_start:                                 
        call    ReadInt                 ; read int; value placed in eax
        mov     [I0],eax                ; store eax at x
        call    ReadInt                 ; read int; value placed in eax
        mov     [I2],eax                ; store eax at a
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at y
        call    ReadInt                 ; read int; value placed in eax
        mov     [I3],eax                ; store eax at b
        mov     eax,[I6]                ; AReg = 0
        mov     [I4],eax                ; c = AReg
        mov     eax,[I0]                ; AReg = x
        cmp     eax,[I2]                ; compare x and a
        jg      .L0                     ; if x > a then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L2                     ; if T0 is false then jump to end of if
        mov     eax,[I1]                ; AReg = y
        cmp     eax,[I3]                ; compare y and b
        jl      .L3                     ; if y < b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L4                     ; unconditionally jump
.L3:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L4:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L5                     ; if T0 is false then jump to end of if
        mov     eax,[I2]                ; AReg = a
        add     eax,[I3]                ; AReg = a + b
        mov     [I4],eax                ; c = AReg
        mov     eax,[I1]                ; AReg = y
        add     eax,[I7]                ; AReg = y + 2
        mov     [I5],eax                ; d = AReg
.L5:                                    ; end if
        jmp     .L6                     ; jump to end if
.L2:                                    ; else
        mov     eax,[I8]                ; AReg = 1
        mov     [I4],eax                ; c = AReg
.L6:                                    ; end if
        mov     eax,[I1]                ; AReg = y
        add     eax,[I9]                ; AReg = y + 3
        mov     [I5],eax                ; d = AReg
        mov     eax,[I4]                ; load c in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I5]                ; load d in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                    
SECTION .data                           
I6      dd      0                       ; 0
I8      dd      1                       ; 1
I7      dd      2                       ; 2
I9      dd      3                       ; 3
FALSE   dd      0                       ; false
TRUE    dd      -1                      ; true

SECTION .bss                            
I2      resd    1                       ; a
I3      resd    1                       ; b
I4      resd    1                       ; c
I5      resd    1                       ; d
I0      resd    1                       ; x
I1      resd    1                       ; y

./output/218.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no218

_start:                                 
        call    ReadInt                 ; read int; value placed in eax
        mov     [I0],eax                ; store eax at a
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at b
        call    ReadInt                 ; read int; value placed in eax
        mov     [I2],eax                ; store eax at c
        mov     eax,[I0]                ; AReg = a
        cmp     eax,[I1]                ; compare a and b
        jl      .L0                     ; if a < b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L2                     ; if T0 is false then jump to end of if
        mov     eax,[I1]                ; AReg = b
        cmp     eax,[I2]                ; compare b and c
        jl      .L3                     ; if b < c then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L4                     ; unconditionally jump
.L3:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L4:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L5                     ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; load a in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I1]                ; load b in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I2]                ; load c in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        jmp     .L6                     ; jump to end if
.L5:                                    ; else
        mov     eax,[I0]                ; AReg = a
        cmp     eax,[I2]                ; compare a and c
        jl      .L7                     ; if a < c then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L8                     ; unconditionally jump
.L7:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L8:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L9                     ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; load a in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I2]                ; load c in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I1]                ; load b in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        jmp     .L10                    ; jump to end if
.L9:                                    ; else
        mov     eax,[I2]                ; load c in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I0]                ; load a in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I1]                ; load b in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
.L10:                                   ; end if
.L6:                                    ; end if
        jmp     .L11                    ; jump to end if
.L2:                                    ; else
        mov     eax,[I0]                ; AReg = a
        cmp     eax,[I2]                ; compare a and c
        jl      .L12                    ; if a < c then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L13                    ; unconditionally jump
.L12:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L13:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L14                    ; if T0 is false then jump to end of if
        mov     eax,[I1]                ; load b in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I0]                ; load a in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I2]                ; load c in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        jmp     .L15                    ; jump to end if
.L14:                                   ; else
        mov     eax,[I1]                ; AReg = b
        cmp     eax,[I2]                ; compare b and c
        jl      .L16                    ; if b < c then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L17                    ; unconditionally jump
.L16:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L17:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L18                    ; if T0 is false then jump to end of if
        mov     eax,[I1]                ; load b in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I2]                ; load c in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I0]                ; load a in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        jmp     .L19                    ; jump to end if
.L18:                                   ; else
        mov     eax,[I2]                ; load c in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I1]                ; load b in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I0]                ; load a in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
.L19:                                   ; end if
.L15:                                   ; end if
.L11:                                   ; end if
        Exit    {0}
                    
SECTION .data                           
FALSE   dd      0                       ; false
TRUE    dd      -1                      ; true

SECTION .bss                            
I0      resd    1                       ; a
I1      resd    1                       ; b
I2      resd    1                       ; c

./output/219.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no219

_start:                                 
        call    ReadInt                 ; read int; value placed in eax
        mov     [I0],eax                ; store eax at a
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at b
        call    ReadInt                 ; read int; value placed in eax
        mov     [I2],eax                ; store eax at c
        call    ReadInt                 ; read int; value placed in eax
        mov     [I3],eax                ; store eax at d
        call    ReadInt                 ; read int; value placed in eax
        mov     [I4],eax                ; store eax at e
        mov     eax,[I0]                ; load a in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I1]                ; load b in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I2]                ; load c in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I3]                ; load d in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I4]                ; load e in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                    
SECTION .data                           

SECTION .bss                            
I0      resd    1                       ; a
I1      resd    1                       ; b
I2      resd    1                       ; c
I3      resd    1                       ; d
I4      resd    1                       ; e

./output/220.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no220

_start:                                 
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at b
        call    ReadInt                 ; read int; value placed in eax
        mov     [I2],eax                ; store eax at c
        call    ReadInt                 ; read int; value placed in eax
        mov     [I3],eax                ; store eax at d
        call    ReadInt                 ; read int; value placed in eax
        mov     [I4],eax                ; store eax at e
        mov     eax,[I0]                ; AReg = a
        cmp     eax,[I1]                ; compare a and b
        jl      .L0                     ; if a < b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L2                     ; if T0 is false then jump to end of if
        mov     eax,[I1]                ; AReg = b
        add     eax,[I2]                ; AReg = b + c
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I2]                ; AReg = c
        add     eax,[I3]                ; AReg = c + d
        mov     [T1],eax                ; deassign AReg
        mov     eax,[I3]                ; AReg = d
        add     eax,[I4]                ; AReg = d + e
        add     eax,[T1]                ; AReg = T2 + T1
        add     eax,[T0]                ; AReg = T1 + T0
        mov     [I0],eax                ; a = AReg
        jmp     .L3                     ; jump to end if
.L2:                                    ; else
        mov     eax,[I0]                ; AReg = a
        add     eax,[I2]                ; AReg = a + c
        mov     [I1],eax                ; b = AReg
.L3:                                    ; end if
        mov     eax,[I0]                ; load a in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I1]                ; load b in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I2]                ; load c in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I3]                ; load d in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I4]                ; load e in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                    
SECTION .data                           
FALSE   dd      0                       ; false
TRUE    dd      -1                      ; true

SECTION .bss                            
T0      resd    1                       ; T0
T1      resd    1                       ; T1
I0      resd    1                       ; a
I1      resd    1                       ; b
I2      resd    1                       ; c
I3      resd    1                       ; d
I4      resd    1                       ; e

./output/221.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no221

_start:                                 
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at b
        call    ReadInt                 ; read int; value placed in eax
        mov     [I2],eax                ; store eax at c
        call    ReadInt                 ; read int; value placed in eax
        mov     [I3],eax                ; store eax at d
        call    ReadInt                 ; read int; value placed in eax
        mov     [I4],eax                ; store eax at e
        mov     eax,[I0]                ; AReg = a
        cmp     eax,[I1]                ; compare a and b
        jl      .L0                     ; if a < b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L2                     ; if T0 is false then jump to end of if
        mov     eax,[I1]                ; AReg = b
        add     eax,[I2]                ; AReg = b + c
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I2]                ; AReg = c
        add     eax,[I3]                ; AReg = c + d
        mov     [T1],eax                ; deassign AReg
        mov     eax,[I3]                ; AReg = d
        add     eax,[I4]                ; AReg = d + e
        add     eax,[T1]                ; AReg = T2 + T1
        add     eax,[T0]                ; AReg = T1 + T0
        mov     [I0],eax                ; a = AReg
        jmp     .L3                     ; jump to end if
.L2:                                    ; else
        mov     eax,[I0]                ; AReg = a
        add     eax,[I2]                ; AReg = a + c
        mov     [I1],eax                ; b = AReg
.L3:                                    ; end if
        mov     eax,[I0]                ; load a in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I1]                ; load b in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I2]                ; load c in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I3]                ; load d in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I4]                ; load e in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                    
SECTION .data                           
FALSE   dd      0                       ; false
TRUE    dd      -1                      ; true

SECTION .bss                            
T0      resd    1                       ; T0
T1      resd    1                       ; T1
I0      resd    1                       ; a
I1      resd    1                       ; b
I2      resd    1                       ; c
I3      resd    1                       ; d
I4      resd    1                       ; e

./output/222.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no222

_start:                                 
        call    ReadInt                 ; read int; value placed in eax
        mov     [I0],eax                ; store eax at a
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at b
        call    ReadInt                 ; read int; value placed in eax
        mov     [I2],eax                ; store eax at c
        call    ReadInt                 ; read int; value placed in eax
        mov     [I3],eax                ; store eax at d
        call    ReadInt                 ; read int; value placed in eax
        mov     [I4],eax                ; store eax at e
        mov     eax,[I0]                ; AReg = a
        cmp     eax,[I1]                ; compare a and b
        jl      .L0                     ; if a < b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                    
        mov     [B0],eax                ; f = AReg
        cmp     eax,0                   ; compare eax to 0
        je      .L2                     ; if f is false then jump to end of if
        mov     eax,[I1]                ; AReg = b
        add     eax,[I2]                ; AReg = b + c
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I2]                ; AReg = c
        add     eax,[I3]                ; AReg = c + d
        mov     [T1],eax                ; deassign AReg
        mov     eax,[I3]                ; AReg = d
        add     eax,[I4]                ; AReg = d + e
        add     eax,[T1]                ; AReg = T2 + T1
        add     eax,[T0]                ; AReg = T1 + T0
        mov     [I0],eax                ; a = AReg
        jmp     .L3                     ; jump to end if
.L2:                                    ; else
        mov     eax,[I0]                ; AReg = a
        add     eax,[I2]                ; AReg = a + c
        mov     [I1],eax                ; b = AReg
.L3:                                    ; end if
        mov     eax,[I0]                ; load a in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I1]                ; load b in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I2]                ; load c in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I3]                ; load d in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I4]                ; load e in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[B0]                ; load f in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                    
SECTION .data                           
FALSE   dd      0                       ; false
TRUE    dd      -1                      ; true

SECTION .bss                            
T0      resd    1                       ; T0
T1      resd    1                       ; T1
I0      resd    1                       ; a
I1      resd    1                       ; b
I2      resd    1                       ; c
I3      resd    1                       ; d
I4      resd    1                       ; e
B0      resd    1                       ; f

./output/223.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no223

_start:                                 
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at month
        call    ReadInt                 ; read int; value placed in eax
        mov     [I2],eax                ; store eax at year
        mov     eax,[I1]                ; AReg = month
        cmp     eax,[I3]                ; compare month and 1
        je      .L0                     ; if month = 1 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                    
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I1]                ; AReg = month
        cmp     eax,[I4]                ; compare month and 2
        je      .L2                     ; if month = 2 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L3                     ; unconditionally jump
.L2:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L3:                                    
        or      eax,[T0]                ; AReg = T1 or T0
        cmp     eax,0                   ; compare eax to 0
        je      .L4                     ; if T0 is false then jump to end of if
        mov     eax,[I1]                ; AReg = month
        add     eax,[I5]                ; AReg = month + 10
        mov     [I0],eax                ; a = AReg
        mov     eax,[I2]                ; AReg = year
        sub     eax,[I3]                ; AReg = year - 1
        mov     [I2],eax                ; year = AReg
        jmp     .L5                     ; jump to end if
.L4:                                    ; else
        mov     eax,[I1]                ; AReg = month
        sub     eax,[I4]                ; AReg = month - 2
        mov     [I0],eax                ; a = AReg
        mov     eax,[I2]                ; AReg = year
        add     eax,[I3]                ; AReg = year + 1
        mov     [I2],eax                ; year = AReg
.L5:                                    ; end if
        mov     eax,[I0]                ; load a in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I1]                ; load month in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I2]                ; load year in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                    
SECTION .data                           
I3      dd      1                       ; 1
I5      dd      10                      ; 10
I4      dd      2                       ; 2
FALSE   dd      0                       ; false
TRUE    dd      -1                      ; true

SECTION .bss                            
T0      resd    1                       ; T0
I0      resd    1                       ; a
I1      resd    1                       ; month
I2      resd    1                       ; year

./output/224.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no224

_start:                                 
        call    ReadInt                 ; read int; value placed in eax
        mov     [I0],eax                ; store eax at a
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at b
        mov     eax,[I0]                ; AReg = a
        cmp     eax,[I1]                ; compare a and b
        jl      .L0                     ; if a < b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                    
        mov     [B0],eax                ; f = AReg
        mov     eax,[I3]                ; AReg = 0
        mov     [I2],eax                ; c = AReg
        mov     eax,[B0]                ; AReg = f
        cmp     eax,0                   ; compare eax to 0
        je      .L2                     ; if f is false then jump to end of if
        mov     eax,[I0]                ; AReg = a
        mov     [I2],eax                ; c = AReg
        jmp     .L3                     ; jump to end if
.L2:                                    ; else
        mov     eax,[I1]                ; AReg = b
        mov     [I2],eax                ; c = AReg
.L3:                                    ; end if
        mov     eax,[I0]                ; load a in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I1]                ; load b in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I2]                ; load c in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                    
SECTION .data                           
I3      dd      0                       ; 0
FALSE   dd      0                       ; false
TRUE    dd      -1                      ; true

SECTION .bss                            
I0      resd    1                       ; a
I1      resd    1                       ; b
I2      resd    1                       ; c
B0      resd    1                       ; f

./output/225.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no225

_start:                                 
        call    ReadInt                 ; read int; value placed in eax
        mov     [I0],eax                ; store eax at a
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at b
        mov     eax,[I0]                ; AReg = a
        cmp     eax,[I3]                ; compare a and 0
        jl      .L0                     ; if a < 0 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L2                     ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = a
        imul    dword [I4]              ; AReg = a * -1
        mov     [I0],eax                ; a = AReg
.L2:                                    ; end if
        mov     eax,[I1]                ; AReg = b
        cmp     eax,[I3]                ; compare b and 0
        jl      .L3                     ; if b < 0 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L4                     ; unconditionally jump
.L3:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L4:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L5                     ; if T0 is false then jump to end of if
        mov     eax,[I1]                ; AReg = b
        imul    dword [I4]              ; AReg = b * -1
        mov     [I1],eax                ; b = AReg
.L5:                                    ; end if
        mov     eax,[I0]                ; AReg = a
        cmp     eax,[I1]                ; compare a and b
        jl      .L6                     ; if a < b then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L7                     ; unconditionally jump
.L6:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L7:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L8                     ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = a
        mov     [I2],eax                ; gcd = AReg
        jmp     .L9                     ; jump to end if
.L8:                                    ; else
        mov     eax,[I1]                ; AReg = b
        mov     [I2],eax                ; gcd = AReg
.L9:                                    ; end if
.L10:                                   ; while
        mov     eax,[I0]                ; AReg = a
        cdq                             ; sign extend dividend from eax to edx:eax
        idiv    dword [I2]              ; AReg = a div gcd
        xchg    eax,edx                 ; exchange quotient and remainder
        cmp     eax,[I3]                ; compare T0 and 0
        jne     .L11                    ; if T0 <> 0 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L12                    ; unconditionally jump
.L11:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L12:                                   
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I1]                ; AReg = b
        cdq                             ; sign extend dividend from eax to edx:eax
        idiv    dword [I2]              ; AReg = b div gcd
        xchg    eax,edx                 ; exchange quotient and remainder
        cmp     eax,[I3]                ; compare T1 and 0
        jne     .L13                    ; if T1 <> 0 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L14                    ; unconditionally jump
.L13:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L14:                                   
        or      eax,[T0]                ; AReg = T1 or T0
        cmp     eax,0                   ; compare eax to 0
        je      .L15                    ; if T0 is false then jump to end while
        mov     eax,[I2]                ; AReg = gcd
        sub     eax,[I5]                ; AReg = gcd - 1
        mov     [I2],eax                ; gcd = AReg
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        jmp     .L10                    ; end while
.L15:                                   
        mov     eax,[I0]                ; load a in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I1]                ; load b in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I2]                ; load gcd in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                    
SECTION .data                           
I4      dd      -1                      ; -1
I3      dd      0                       ; 0
I5      dd      1                       ; 1
FALSE   dd      0                       ; false
TRUE    dd      -1                      ; true

SECTION .bss                            
T0      resd    1                       ; T0
I0      resd    1                       ; a
I1      resd    1                       ; b
I2      resd    1                       ; gcd

./output/226.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no226

_start:                                 
        mov     eax,[I1]                ; AReg = 0
        mov     [I0],eax                ; a = AReg
        cmp     eax,[I2]                ; compare a and 10
        jl      .L0                     ; if a < 10 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                    
        mov     [B0],eax                ; f = AReg
.L2:                                    ; while
        mov     eax,[B0]                ; AReg = f
        cmp     eax,0                   ; compare eax to 0
        je      .L3                     ; if f is false then jump to end while
        mov     eax,[I0]                ; AReg = a
        add     eax,[I3]                ; AReg = a + 1
        mov     [I0],eax                ; a = AReg
        cmp     eax,[I2]                ; compare a and 10
        jl      .L4                     ; if a < 10 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L5                     ; unconditionally jump
.L4:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L5:                                    
        mov     [B0],eax                ; f = AReg
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I0]                ; load a in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        jmp     .L2                     ; end while
.L3:                                    
        mov     eax,[I0]                ; load a in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[B0]                ; load f in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                    
SECTION .data                           
I1      dd      0                       ; 0
I3      dd      1                       ; 1
I2      dd      10                      ; 10
FALSE   dd      0                       ; false
TRUE    dd      -1                      ; true

SECTION .bss                            
I0      resd    1                       ; a
B0      resd    1                       ; f

./output/227.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no227

_start:                                 
        mov     eax,[I1]                ; AReg = 0
        mov     [I0],eax                ; a = AReg
        mov     eax,[TRUE]              ; AReg = true
        cmp     eax,0                   ; compare eax to 0
        je      .L0                     ; if true is false then jump to end of if
        mov     eax,[I2]                ; AReg = 1
        mov     [I0],eax                ; a = AReg
.L0:                                    ; end if
        mov     eax,[I0]                ; load a in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                    
SECTION .data                           
I1      dd      0                       ; 0
I2      dd      1                       ; 1
TRUE    dd      -1                      ; true

SECTION .bss                            
I0      resd    1                       ; a

./output/228.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no228

_start:                                 
        mov     eax,[I1]                ; AReg = 0
        mov     [I0],eax                ; a = AReg
        mov     eax,[FALSE]             ; AReg = false
        cmp     eax,0                   ; compare eax to 0
        je      .L0                     ; if false is false then jump to end of if
        jmp     .L1                     ; jump to end if
.L0:                                    ; else
        mov     eax,[I2]                ; AReg = 1
        mov     [I0],eax                ; a = AReg
.L1:                                    ; end if
        mov     eax,[I0]                ; load a in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                    
SECTION .data                           
I1      dd      0                       ; 0
I2      dd      1                       ; 1
FALSE   dd      0                       ; false

SECTION .bss                            
I0      resd    1                       ; a

./output/229.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no229

_start:                                 
        mov     eax,[I1]                ; AReg = 0
        mov     [I0],eax                ; a = AReg
.L0:                                    ; while

./output/230.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no230

_start:                                 
.L0:                                    ; while
        mov     eax,[TRUE]              ; AReg = true
        cmp     eax,0                   ; compare eax to 0
        je      .L1                     ; if true is false then jump to end while
        jmp     .L0                     ; end while
.L1:                                    
        mov     eax,[I0]                ; load month in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                    
SECTION .data                           
I0      dd      12                      ; month
TRUE    dd      -1                      ; true

SECTION .bss                            

./output/231.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no231

_start:                                 
.L0:                                    ; while
        mov     eax,[FALSE]             ; AReg = false
        cmp     eax,0                   ; compare eax to 0
        je      .L1                     ; if false is false then jump to end while
        jmp     .L0                     ; end while
.L1:                                    
        mov     eax,[I0]                ; load month in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                    
SECTION .data                           
FALSE   dd      0                       ; false
I0      dd      12                      ; month

SECTION .bss                            

./output/232.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no232

_start:                                 
        mov     eax,[I2]                ; AReg = 0
        mov     [I0],eax                ; a = AReg
.L0:                                    ; repeat
        mov     eax,[I0]                ; AReg = a
        add     eax,[I3]                ; AReg = a + 1
        mov     [I0],eax                ; a = AReg
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        cmp     eax,[I4]                ; compare a and 10
        je      .L1                     ; if a = 10 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L2                     ; unconditionally jump
.L1:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L2:                                    
        mov     [B0],eax                ; f = AReg
        mov     eax,[I0]                ; AReg = a
        mov     [I1],eax                ; b = AReg
        mov     eax,[B0]                ; AReg = B0
        cmp     eax,0                   ; compare eax to 0
        je      .L0                     ; until f is true
        Exit    {0}
                    
SECTION .data                           
I2      dd      0                       ; 0
I3      dd      1                       ; 1
I4      dd      10                      ; 10
FALSE   dd      0                       ; false
TRUE    dd      -1                      ; true

SECTION .bss                            
I0      resd    1                       ; a
I1      resd    1                       ; b
B0      resd    1                       ; f

./output/233.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no233

_start:                                 
.L0:                                    ; repeat
        mov     eax,[FALSE]             ; AReg = FALSE
        cmp     eax,0                   ; compare eax to 0
        je      .L0                     ; until false is true
        Exit    {0}
                    
SECTION .data                           
FALSE   dd      0                       ; false

SECTION .bss                            

./output/234.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no234

_start:                                 
.L0:                                    ; repeat
        mov     eax,[TRUE]              ; AReg = TRUE
        cmp     eax,0                   ; compare eax to 0
        je      .L0                     ; until true is true
        Exit    {0}
                    
SECTION .data                           
TRUE    dd      -1                      ; true

SECTION .bss                            

./output/235.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no235

_start:                                 
        mov     eax,[I1]                ; AReg = 0
        mov     [I0],eax                ; t = AReg
.L0:                                    ; repeat
        mov     eax,[I2]                ; AReg = 1
        mov     [I0],eax                ; t = AReg
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out

./output/236.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no236

_start:                                 
        Exit    {0}
                    
SECTION .data                           

SECTION .bss                            

./output/237.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no237

_start:                                 
        call    ReadInt                 ; read int; value placed in eax
        mov     [I0],eax                ; store eax at var000
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at var001
        call    ReadInt                 ; read int; value placed in eax
        mov     [I2],eax                ; store eax at var002
        call    ReadInt                 ; read int; value placed in eax
        mov     [I3],eax                ; store eax at var003
        call    ReadInt                 ; read int; value placed in eax
        mov     [I4],eax                ; store eax at var004
        call    ReadInt                 ; read int; value placed in eax
        mov     [I5],eax                ; store eax at var005
        call    ReadInt                 ; read int; value placed in eax
        mov     [I6],eax                ; store eax at var006
        call    ReadInt                 ; read int; value placed in eax
        mov     [I7],eax                ; store eax at var007
        call    ReadInt                 ; read int; value placed in eax
        mov     [I8],eax                ; store eax at var008
        call    ReadInt                 ; read int; value placed in eax
        mov     [I9],eax                ; store eax at var009
        call    ReadInt                 ; read int; value placed in eax
        mov     [I10],eax               ; store eax at var010
        call    ReadInt                 ; read int; value placed in eax
        mov     [I11],eax               ; store eax at var011
        call    ReadInt                 ; read int; value placed in eax
        mov     [I12],eax               ; store eax at var012
        call    ReadInt                 ; read int; value placed in eax
        mov     [I13],eax               ; store eax at var013
        call    ReadInt                 ; read int; value placed in eax
        mov     [I14],eax               ; store eax at var014
        call    ReadInt                 ; read int; value placed in eax
        mov     [I15],eax               ; store eax at var015
        call    ReadInt                 ; read int; value placed in eax
        mov     [I16],eax               ; store eax at var016
        call    ReadInt                 ; read int; value placed in eax
        mov     [I17],eax               ; store eax at var017
        call    ReadInt                 ; read int; value placed in eax
        mov     [I18],eax               ; store eax at var018
        call    ReadInt                 ; read int; value placed in eax
        mov     [I19],eax               ; store eax at var019
        call    ReadInt                 ; read int; value placed in eax
        mov     [I20],eax               ; store eax at var020
        call    ReadInt                 ; read int; value placed in eax
        mov     [I21],eax               ; store eax at var021
        call    ReadInt                 ; read int; value placed in eax
        mov     [I22],eax               ; store eax at var022
        call    ReadInt                 ; read int; value placed in eax
        mov     [I23],eax               ; store eax at var023
        call    ReadInt                 ; read int; value placed in eax
        mov     [I24],eax               ; store eax at var024
        call    ReadInt                 ; read int; value placed in eax
        mov     [I25],eax               ; store eax at var025
        call    ReadInt                 ; read int; value placed in eax
        mov     [I26],eax               ; store eax at var026
        call    ReadInt                 ; read int; value placed in eax
        mov     [I27],eax               ; store eax at var027
        call    ReadInt                 ; read int; value placed in eax
        mov     [I28],eax               ; store eax at var028
        call    ReadInt                 ; read int; value placed in eax
        mov     [I29],eax               ; store eax at var029
        call    ReadInt                 ; read int; value placed in eax
        mov     [I30],eax               ; store eax at var030
        call    ReadInt                 ; read int; value placed in eax
        mov     [I31],eax               ; store eax at var031
        call    ReadInt                 ; read int; value placed in eax
        mov     [I32],eax               ; store eax at var032
        call    ReadInt                 ; read int; value placed in eax
        mov     [I33],eax               ; store eax at var033
        call    ReadInt                 ; read int; value placed in eax
        mov     [I34],eax               ; store eax at var034
        call    ReadInt                 ; read int; value placed in eax
        mov     [I35],eax               ; store eax at var035
        call    ReadInt                 ; read int; value placed in eax
        mov     [I36],eax               ; store eax at var036
        call    ReadInt                 ; read int; value placed in eax
        mov     [I37],eax               ; store eax at var037
        call    ReadInt                 ; read int; value placed in eax
        mov     [I38],eax               ; store eax at var038
        call    ReadInt                 ; read int; value placed in eax
        mov     [I39],eax               ; store eax at var039
        call    ReadInt                 ; read int; value placed in eax
        mov     [I40],eax               ; store eax at var040
        call    ReadInt                 ; read int; value placed in eax
        mov     [I41],eax               ; store eax at var041
        call    ReadInt                 ; read int; value placed in eax
        mov     [I42],eax               ; store eax at var042
        call    ReadInt                 ; read int; value placed in eax
        mov     [I43],eax               ; store eax at var043
        call    ReadInt                 ; read int; value placed in eax
        mov     [I44],eax               ; store eax at var044
        call    ReadInt                 ; read int; value placed in eax
        mov     [I45],eax               ; store eax at var045
        call    ReadInt                 ; read int; value placed in eax
        mov     [I46],eax               ; store eax at var046
        call    ReadInt                 ; read int; value placed in eax
        mov     [I47],eax               ; store eax at var047
        call    ReadInt                 ; read int; value placed in eax
        mov     [I48],eax               ; store eax at var048
        call    ReadInt                 ; read int; value placed in eax
        mov     [I49],eax               ; store eax at var049
        call    ReadInt                 ; read int; value placed in eax
        mov     [I50],eax               ; store eax at var050
        call    ReadInt                 ; read int; value placed in eax
        mov     [I51],eax               ; store eax at var051
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I1]                ; compare var000 and var001
        jl      .L0                     ; if var000 < var001 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L2                     ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I2]                ; compare var000 and var002
        jl      .L3                     ; if var000 < var002 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L4                     ; unconditionally jump
.L3:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L4:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L5                     ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I3]                ; compare var000 and var003
        jl      .L6                     ; if var000 < var003 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L7                     ; unconditionally jump
.L6:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L7:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L8                     ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I4]                ; compare var000 and var004
        jl      .L9                     ; if var000 < var004 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L10                    ; unconditionally jump
.L9:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L10:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L11                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I5]                ; compare var000 and var005
        jl      .L12                    ; if var000 < var005 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L13                    ; unconditionally jump
.L12:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L13:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L14                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I6]                ; compare var000 and var006
        jl      .L15                    ; if var000 < var006 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L16                    ; unconditionally jump
.L15:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L16:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L17                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I7]                ; compare var000 and var007
        jl      .L18                    ; if var000 < var007 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L19                    ; unconditionally jump
.L18:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L19:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L20                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I8]                ; compare var000 and var008
        jl      .L21                    ; if var000 < var008 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L22                    ; unconditionally jump
.L21:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L22:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L23                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I9]                ; compare var000 and var009
        jl      .L24                    ; if var000 < var009 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L25                    ; unconditionally jump
.L24:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L25:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L26                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I10]               ; compare var000 and var010
        jl      .L27                    ; if var000 < var010 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L28                    ; unconditionally jump
.L27:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L28:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L29                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I11]               ; compare var000 and var011
        jl      .L30                    ; if var000 < var011 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L31                    ; unconditionally jump
.L30:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L31:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L32                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I12]               ; compare var000 and var012
        jl      .L33                    ; if var000 < var012 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L34                    ; unconditionally jump
.L33:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L34:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L35                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I13]               ; compare var000 and var013
        jl      .L36                    ; if var000 < var013 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L37                    ; unconditionally jump
.L36:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L37:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L38                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I14]               ; compare var000 and var014
        jl      .L39                    ; if var000 < var014 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L40                    ; unconditionally jump
.L39:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L40:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L41                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I15]               ; compare var000 and var015
        jl      .L42                    ; if var000 < var015 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L43                    ; unconditionally jump
.L42:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L43:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L44                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I16]               ; compare var000 and var016
        jl      .L45                    ; if var000 < var016 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L46                    ; unconditionally jump
.L45:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L46:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L47                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I17]               ; compare var000 and var017
        jl      .L48                    ; if var000 < var017 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L49                    ; unconditionally jump
.L48:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L49:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L50                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I18]               ; compare var000 and var018
        jl      .L51                    ; if var000 < var018 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L52                    ; unconditionally jump
.L51:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L52:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L53                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I19]               ; compare var000 and var019
        jl      .L54                    ; if var000 < var019 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L55                    ; unconditionally jump
.L54:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L55:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L56                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I20]               ; compare var000 and var020
        jl      .L57                    ; if var000 < var020 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L58                    ; unconditionally jump
.L57:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L58:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L59                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I21]               ; compare var000 and var021
        jl      .L60                    ; if var000 < var021 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L61                    ; unconditionally jump
.L60:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L61:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L62                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I22]               ; compare var000 and var022
        jl      .L63                    ; if var000 < var022 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L64                    ; unconditionally jump
.L63:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L64:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L65                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I23]               ; compare var000 and var023
        jl      .L66                    ; if var000 < var023 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L67                    ; unconditionally jump
.L66:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L67:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L68                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I24]               ; compare var000 and var024
        jl      .L69                    ; if var000 < var024 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L70                    ; unconditionally jump
.L69:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L70:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L71                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I25]               ; compare var000 and var025
        jl      .L72                    ; if var000 < var025 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L73                    ; unconditionally jump
.L72:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L73:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L74                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I26]               ; compare var000 and var026
        jl      .L75                    ; if var000 < var026 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L76                    ; unconditionally jump
.L75:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L76:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L77                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I27]               ; compare var000 and var027
        jl      .L78                    ; if var000 < var027 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L79                    ; unconditionally jump
.L78:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L79:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L80                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I28]               ; compare var000 and var028
        jl      .L81                    ; if var000 < var028 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L82                    ; unconditionally jump
.L81:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L82:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L83                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I29]               ; compare var000 and var029
        jl      .L84                    ; if var000 < var029 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L85                    ; unconditionally jump
.L84:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L85:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L86                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I30]               ; compare var000 and var030
        jl      .L87                    ; if var000 < var030 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L88                    ; unconditionally jump
.L87:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L88:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L89                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I31]               ; compare var000 and var031
        jl      .L90                    ; if var000 < var031 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L91                    ; unconditionally jump
.L90:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L91:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L92                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I32]               ; compare var000 and var032
        jl      .L93                    ; if var000 < var032 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L94                    ; unconditionally jump
.L93:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L94:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L95                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I33]               ; compare var000 and var033
        jl      .L96                    ; if var000 < var033 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L97                    ; unconditionally jump
.L96:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L97:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L98                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I34]               ; compare var000 and var034
        jl      .L99                    ; if var000 < var034 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L100                   ; unconditionally jump
.L99:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L100:                                  
        cmp     eax,0                   ; compare eax to 0
        je      .L101                   ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I35]               ; compare var000 and var035
        jl      .L102                   ; if var000 < var035 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L103                   ; unconditionally jump
.L102:                                  
        mov     eax,[TRUE]              ; set eax to TRUE
.L103:                                  
        cmp     eax,0                   ; compare eax to 0
        je      .L104                   ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I36]               ; compare var000 and var036
        jl      .L105                   ; if var000 < var036 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L106                   ; unconditionally jump
.L105:                                  
        mov     eax,[TRUE]              ; set eax to TRUE
.L106:                                  
        cmp     eax,0                   ; compare eax to 0
        je      .L107                   ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I37]               ; compare var000 and var037
        jl      .L108                   ; if var000 < var037 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L109                   ; unconditionally jump
.L108:                                  
        mov     eax,[TRUE]              ; set eax to TRUE
.L109:                                  
        cmp     eax,0                   ; compare eax to 0
        je      .L110                   ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I38]               ; compare var000 and var038
        jl      .L111                   ; if var000 < var038 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L112                   ; unconditionally jump
.L111:                                  
        mov     eax,[TRUE]              ; set eax to TRUE
.L112:                                  
        cmp     eax,0                   ; compare eax to 0
        je      .L113                   ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I39]               ; compare var000 and var039
        jl      .L114                   ; if var000 < var039 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L115                   ; unconditionally jump
.L114:                                  
        mov     eax,[TRUE]              ; set eax to TRUE
.L115:                                  
        cmp     eax,0                   ; compare eax to 0
        je      .L116                   ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I40]               ; compare var000 and var040
        jl      .L117                   ; if var000 < var040 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L118                   ; unconditionally jump
.L117:                                  
        mov     eax,[TRUE]              ; set eax to TRUE
.L118:                                  
        cmp     eax,0                   ; compare eax to 0
        je      .L119                   ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I41]               ; compare var000 and var041
        jl      .L120                   ; if var000 < var041 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L121                   ; unconditionally jump
.L120:                                  
        mov     eax,[TRUE]              ; set eax to TRUE
.L121:                                  
        cmp     eax,0                   ; compare eax to 0
        je      .L122                   ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I42]               ; compare var000 and var042
        jl      .L123                   ; if var000 < var042 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L124                   ; unconditionally jump
.L123:                                  
        mov     eax,[TRUE]              ; set eax to TRUE
.L124:                                  
        cmp     eax,0                   ; compare eax to 0
        je      .L125                   ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I43]               ; compare var000 and var043
        jl      .L126                   ; if var000 < var043 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L127                   ; unconditionally jump
.L126:                                  
        mov     eax,[TRUE]              ; set eax to TRUE
.L127:                                  
        cmp     eax,0                   ; compare eax to 0
        je      .L128                   ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I44]               ; compare var000 and var044
        jl      .L129                   ; if var000 < var044 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L130                   ; unconditionally jump
.L129:                                  
        mov     eax,[TRUE]              ; set eax to TRUE
.L130:                                  
        cmp     eax,0                   ; compare eax to 0
        je      .L131                   ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I45]               ; compare var000 and var045
        jl      .L132                   ; if var000 < var045 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L133                   ; unconditionally jump
.L132:                                  
        mov     eax,[TRUE]              ; set eax to TRUE
.L133:                                  
        cmp     eax,0                   ; compare eax to 0
        je      .L134                   ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I46]               ; compare var000 and var046
        jl      .L135                   ; if var000 < var046 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L136                   ; unconditionally jump
.L135:                                  
        mov     eax,[TRUE]              ; set eax to TRUE
.L136:                                  
        cmp     eax,0                   ; compare eax to 0
        je      .L137                   ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I47]               ; compare var000 and var047
        jl      .L138                   ; if var000 < var047 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L139                   ; unconditionally jump
.L138:                                  
        mov     eax,[TRUE]              ; set eax to TRUE
.L139:                                  
        cmp     eax,0                   ; compare eax to 0
        je      .L140                   ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I48]               ; compare var000 and var048
        jl      .L141                   ; if var000 < var048 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L142                   ; unconditionally jump
.L141:                                  
        mov     eax,[TRUE]              ; set eax to TRUE
.L142:                                  
        cmp     eax,0                   ; compare eax to 0
        je      .L143                   ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I49]               ; compare var000 and var049
        jl      .L144                   ; if var000 < var049 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L145                   ; unconditionally jump
.L144:                                  
        mov     eax,[TRUE]              ; set eax to TRUE
.L145:                                  
        cmp     eax,0                   ; compare eax to 0
        je      .L146                   ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I50]               ; compare var000 and var050
        jl      .L147                   ; if var000 < var050 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L148                   ; unconditionally jump
.L147:                                  
        mov     eax,[TRUE]              ; set eax to TRUE
.L148:                                  
        cmp     eax,0                   ; compare eax to 0
        je      .L149                   ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I51]               ; compare var000 and var051
        jl      .L150                   ; if var000 < var051 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L151                   ; unconditionally jump
.L150:                                  
        mov     eax,[TRUE]              ; set eax to TRUE
.L151:                                  
        cmp     eax,0                   ; compare eax to 0
        je      .L152                   ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        mov     [I52],eax               ; small = AReg
.L152:                                  ; end if
.L149:                                  ; end if
.L146:                                  ; end if
.L143:                                  ; end if
.L140:                                  ; end if
.L137:                                  ; end if
.L134:                                  ; end if
.L131:                                  ; end if
.L128:                                  ; end if
.L125:                                  ; end if
.L122:                                  ; end if
.L119:                                  ; end if
.L116:                                  ; end if
.L113:                                  ; end if
.L110:                                  ; end if
.L107:                                  ; end if
.L104:                                  ; end if
.L101:                                  ; end if
.L98:                                   ; end if
.L95:                                   ; end if
.L92:                                   ; end if
.L89:                                   ; end if
.L86:                                   ; end if
.L83:                                   ; end if
.L80:                                   ; end if
.L77:                                   ; end if
.L74:                                   ; end if
.L71:                                   ; end if
.L68:                                   ; end if
.L65:                                   ; end if
.L62:                                   ; end if
.L59:                                   ; end if
.L56:                                   ; end if
.L53:                                   ; end if
.L50:                                   ; end if
.L47:                                   ; end if
.L44:                                   ; end if
.L41:                                   ; end if
.L38:                                   ; end if
.L35:                                   ; end if
.L32:                                   ; end if
.L29:                                   ; end if
.L26:                                   ; end if
.L23:                                   ; end if
.L20:                                   ; end if
.L17:                                   ; end if
.L14:                                   ; end if
.L11:                                   ; end if
.L8:                                    ; end if
.L5:                                    ; end if
.L2:                                    ; end if
        mov     eax,[I52]               ; load small in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                    
SECTION .data                           
FALSE   dd      0                       ; false
TRUE    dd      -1                      ; true

SECTION .bss                            
I52     resd    1                       ; small
I0      resd    1                       ; var000
I1      resd    1                       ; var001
I2      resd    1                       ; var002
I3      resd    1                       ; var003
I4      resd    1                       ; var004
I5      resd    1                       ; var005
I6      resd    1                       ; var006
I7      resd    1                       ; var007
I8      resd    1                       ; var008
I9      resd    1                       ; var009
I10     resd    1                       ; var010
I11     resd    1                       ; var011
I12     resd    1                       ; var012
I13     resd    1                       ; var013
I14     resd    1                       ; var014
I15     resd    1                       ; var015
I16     resd    1                       ; var016
I17     resd    1                       ; var017
I18     resd    1                       ; var018
I19     resd    1                       ; var019
I20     resd    1                       ; var020
I21     resd    1                       ; var021
I22     resd    1                       ; var022
I23     resd    1                       ; var023
I24     resd    1                       ; var024
I25     resd    1                       ; var025
I26     resd    1                       ; var026
I27     resd    1                       ; var027
I28     resd    1                       ; var028
I29     resd    1                       ; var029
I30     resd    1                       ; var030
I31     resd    1                       ; var031
I32     resd    1                       ; var032
I33     resd    1                       ; var033
I34     resd    1                       ; var034
I35     resd    1                       ; var035
I36     resd    1                       ; var036
I37     resd    1                       ; var037
I38     resd    1                       ; var038
I39     resd    1                       ; var039
I40     resd    1                       ; var040
I41     resd    1                       ; var041
I42     resd    1                       ; var042
I43     resd    1                       ; var043
I44     resd    1                       ; var044
I45     resd    1                       ; var045
I46     resd    1                       ; var046
I47     resd    1                       ; var047
I48     resd    1                       ; var048
I49     resd    1                       ; var049
I50     resd    1                       ; var050
I51     resd    1                       ; var051

./output/238.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no238

_start:                                 
        call    ReadInt                 ; read int; value placed in eax
        mov     [I0],eax                ; store eax at var000
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at var001
        call    ReadInt                 ; read int; value placed in eax
        mov     [I2],eax                ; store eax at var002
        call    ReadInt                 ; read int; value placed in eax
        mov     [I3],eax                ; store eax at var003
        call    ReadInt                 ; read int; value placed in eax
        mov     [I4],eax                ; store eax at var004
        call    ReadInt                 ; read int; value placed in eax
        mov     [I5],eax                ; store eax at var005
        call    ReadInt                 ; read int; value placed in eax
        mov     [I6],eax                ; store eax at var006
        call    ReadInt                 ; read int; value placed in eax
        mov     [I7],eax                ; store eax at var007
        call    ReadInt                 ; read int; value placed in eax
        mov     [I8],eax                ; store eax at var008
        call    ReadInt                 ; read int; value placed in eax
        mov     [I9],eax                ; store eax at var009
        call    ReadInt                 ; read int; value placed in eax
        mov     [I10],eax               ; store eax at var010
        call    ReadInt                 ; read int; value placed in eax
        mov     [I11],eax               ; store eax at var011
        call    ReadInt                 ; read int; value placed in eax
        mov     [I12],eax               ; store eax at var012
        call    ReadInt                 ; read int; value placed in eax
        mov     [I13],eax               ; store eax at var013
        call    ReadInt                 ; read int; value placed in eax
        mov     [I14],eax               ; store eax at var014
        call    ReadInt                 ; read int; value placed in eax
        mov     [I15],eax               ; store eax at var015
        call    ReadInt                 ; read int; value placed in eax
        mov     [I16],eax               ; store eax at var016
        call    ReadInt                 ; read int; value placed in eax
        mov     [I17],eax               ; store eax at var017
        call    ReadInt                 ; read int; value placed in eax
        mov     [I18],eax               ; store eax at var018
        call    ReadInt                 ; read int; value placed in eax
        mov     [I19],eax               ; store eax at var019
        call    ReadInt                 ; read int; value placed in eax
        mov     [I20],eax               ; store eax at var020
        call    ReadInt                 ; read int; value placed in eax
        mov     [I21],eax               ; store eax at var021
        call    ReadInt                 ; read int; value placed in eax
        mov     [I22],eax               ; store eax at var022
        call    ReadInt                 ; read int; value placed in eax
        mov     [I23],eax               ; store eax at var023
        call    ReadInt                 ; read int; value placed in eax
        mov     [I24],eax               ; store eax at var024
        call    ReadInt                 ; read int; value placed in eax
        mov     [I25],eax               ; store eax at var025
        call    ReadInt                 ; read int; value placed in eax
        mov     [I26],eax               ; store eax at var026
        call    ReadInt                 ; read int; value placed in eax
        mov     [I27],eax               ; store eax at var027
        call    ReadInt                 ; read int; value placed in eax
        mov     [I28],eax               ; store eax at var028
        call    ReadInt                 ; read int; value placed in eax
        mov     [I29],eax               ; store eax at var029
        call    ReadInt                 ; read int; value placed in eax
        mov     [I30],eax               ; store eax at var030
        call    ReadInt                 ; read int; value placed in eax
        mov     [I31],eax               ; store eax at var031
        call    ReadInt                 ; read int; value placed in eax
        mov     [I32],eax               ; store eax at var032
        call    ReadInt                 ; read int; value placed in eax
        mov     [I33],eax               ; store eax at var033
        call    ReadInt                 ; read int; value placed in eax
        mov     [I34],eax               ; store eax at var034
        call    ReadInt                 ; read int; value placed in eax
        mov     [I35],eax               ; store eax at var035
        call    ReadInt                 ; read int; value placed in eax
        mov     [I36],eax               ; store eax at var036
        call    ReadInt                 ; read int; value placed in eax
        mov     [I37],eax               ; store eax at var037
        call    ReadInt                 ; read int; value placed in eax
        mov     [I38],eax               ; store eax at var038
        call    ReadInt                 ; read int; value placed in eax
        mov     [I39],eax               ; store eax at var039
        call    ReadInt                 ; read int; value placed in eax
        mov     [I40],eax               ; store eax at var040
        call    ReadInt                 ; read int; value placed in eax
        mov     [I41],eax               ; store eax at var041
        call    ReadInt                 ; read int; value placed in eax
        mov     [I42],eax               ; store eax at var042
        call    ReadInt                 ; read int; value placed in eax
        mov     [I43],eax               ; store eax at var043
        call    ReadInt                 ; read int; value placed in eax
        mov     [I44],eax               ; store eax at var044
        call    ReadInt                 ; read int; value placed in eax
        mov     [I45],eax               ; store eax at var045
        call    ReadInt                 ; read int; value placed in eax
        mov     [I46],eax               ; store eax at var046
        call    ReadInt                 ; read int; value placed in eax
        mov     [I47],eax               ; store eax at var047
        call    ReadInt                 ; read int; value placed in eax
        mov     [I48],eax               ; store eax at var048
        call    ReadInt                 ; read int; value placed in eax
        mov     [I49],eax               ; store eax at var049
        call    ReadInt                 ; read int; value placed in eax
        mov     [I50],eax               ; store eax at var050
        call    ReadInt                 ; read int; value placed in eax
        mov     [I51],eax               ; store eax at var051
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I1]                ; compare var000 and var001
        jl      .L0                     ; if var000 < var001 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L2                     ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I2]                ; compare var000 and var002
        jl      .L3                     ; if var000 < var002 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L4                     ; unconditionally jump
.L3:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L4:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L5                     ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I3]                ; compare var000 and var003
        jl      .L6                     ; if var000 < var003 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L7                     ; unconditionally jump
.L6:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L7:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L8                     ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I4]                ; compare var000 and var004
        jl      .L9                     ; if var000 < var004 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L10                    ; unconditionally jump
.L9:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L10:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L11                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I5]                ; compare var000 and var005
        jl      .L12                    ; if var000 < var005 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L13                    ; unconditionally jump
.L12:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L13:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L14                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I6]                ; compare var000 and var006
        jl      .L15                    ; if var000 < var006 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L16                    ; unconditionally jump
.L15:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L16:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L17                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I7]                ; compare var000 and var007
        jl      .L18                    ; if var000 < var007 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L19                    ; unconditionally jump
.L18:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L19:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L20                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I8]                ; compare var000 and var008
        jl      .L21                    ; if var000 < var008 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L22                    ; unconditionally jump
.L21:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L22:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L23                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I9]                ; compare var000 and var009
        jl      .L24                    ; if var000 < var009 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L25                    ; unconditionally jump
.L24:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L25:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L26                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I10]               ; compare var000 and var010
        jl      .L27                    ; if var000 < var010 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L28                    ; unconditionally jump
.L27:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L28:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L29                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I11]               ; compare var000 and var011
        jl      .L30                    ; if var000 < var011 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L31                    ; unconditionally jump
.L30:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L31:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L32                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I12]               ; compare var000 and var012
        jl      .L33                    ; if var000 < var012 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L34                    ; unconditionally jump
.L33:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L34:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L35                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I13]               ; compare var000 and var013
        jl      .L36                    ; if var000 < var013 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L37                    ; unconditionally jump
.L36:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L37:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L38                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I14]               ; compare var000 and var014
        jl      .L39                    ; if var000 < var014 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L40                    ; unconditionally jump
.L39:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L40:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L41                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I15]               ; compare var000 and var015
        jl      .L42                    ; if var000 < var015 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L43                    ; unconditionally jump
.L42:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L43:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L44                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I16]               ; compare var000 and var016
        jl      .L45                    ; if var000 < var016 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L46                    ; unconditionally jump
.L45:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L46:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L47                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I17]               ; compare var000 and var017
        jl      .L48                    ; if var000 < var017 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L49                    ; unconditionally jump
.L48:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L49:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L50                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I18]               ; compare var000 and var018
        jl      .L51                    ; if var000 < var018 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L52                    ; unconditionally jump
.L51:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L52:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L53                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I19]               ; compare var000 and var019
        jl      .L54                    ; if var000 < var019 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L55                    ; unconditionally jump
.L54:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L55:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L56                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I20]               ; compare var000 and var020
        jl      .L57                    ; if var000 < var020 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L58                    ; unconditionally jump
.L57:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L58:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L59                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I21]               ; compare var000 and var021
        jl      .L60                    ; if var000 < var021 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L61                    ; unconditionally jump
.L60:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L61:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L62                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I22]               ; compare var000 and var022
        jl      .L63                    ; if var000 < var022 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L64                    ; unconditionally jump
.L63:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L64:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L65                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I23]               ; compare var000 and var023
        jl      .L66                    ; if var000 < var023 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L67                    ; unconditionally jump
.L66:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L67:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L68                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I24]               ; compare var000 and var024
        jl      .L69                    ; if var000 < var024 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L70                    ; unconditionally jump
.L69:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L70:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L71                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I25]               ; compare var000 and var025
        jl      .L72                    ; if var000 < var025 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L73                    ; unconditionally jump
.L72:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L73:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L74                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I26]               ; compare var000 and var026
        jl      .L75                    ; if var000 < var026 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L76                    ; unconditionally jump
.L75:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L76:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L77                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I27]               ; compare var000 and var027
        jl      .L78                    ; if var000 < var027 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L79                    ; unconditionally jump
.L78:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L79:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L80                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I28]               ; compare var000 and var028
        jl      .L81                    ; if var000 < var028 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L82                    ; unconditionally jump
.L81:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L82:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L83                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I29]               ; compare var000 and var029
        jl      .L84                    ; if var000 < var029 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L85                    ; unconditionally jump
.L84:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L85:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L86                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I30]               ; compare var000 and var030
        jl      .L87                    ; if var000 < var030 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L88                    ; unconditionally jump
.L87:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L88:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L89                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I31]               ; compare var000 and var031
        jl      .L90                    ; if var000 < var031 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L91                    ; unconditionally jump
.L90:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L91:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L92                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I32]               ; compare var000 and var032
        jl      .L93                    ; if var000 < var032 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L94                    ; unconditionally jump
.L93:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L94:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L95                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I33]               ; compare var000 and var033
        jl      .L96                    ; if var000 < var033 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L97                    ; unconditionally jump
.L96:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L97:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L98                    ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I34]               ; compare var000 and var034
        jl      .L99                    ; if var000 < var034 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L100                   ; unconditionally jump
.L99:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L100:                                  
        cmp     eax,0                   ; compare eax to 0
        je      .L101                   ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I35]               ; compare var000 and var035
        jl      .L102                   ; if var000 < var035 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L103                   ; unconditionally jump
.L102:                                  
        mov     eax,[TRUE]              ; set eax to TRUE
.L103:                                  
        cmp     eax,0                   ; compare eax to 0
        je      .L104                   ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I36]               ; compare var000 and var036
        jl      .L105                   ; if var000 < var036 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L106                   ; unconditionally jump
.L105:                                  
        mov     eax,[TRUE]              ; set eax to TRUE
.L106:                                  
        cmp     eax,0                   ; compare eax to 0
        je      .L107                   ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I37]               ; compare var000 and var037
        jl      .L108                   ; if var000 < var037 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L109                   ; unconditionally jump
.L108:                                  
        mov     eax,[TRUE]              ; set eax to TRUE
.L109:                                  
        cmp     eax,0                   ; compare eax to 0
        je      .L110                   ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I38]               ; compare var000 and var038
        jl      .L111                   ; if var000 < var038 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L112                   ; unconditionally jump
.L111:                                  
        mov     eax,[TRUE]              ; set eax to TRUE
.L112:                                  
        cmp     eax,0                   ; compare eax to 0
        je      .L113                   ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I39]               ; compare var000 and var039
        jl      .L114                   ; if var000 < var039 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L115                   ; unconditionally jump
.L114:                                  
        mov     eax,[TRUE]              ; set eax to TRUE
.L115:                                  
        cmp     eax,0                   ; compare eax to 0
        je      .L116                   ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I40]               ; compare var000 and var040
        jl      .L117                   ; if var000 < var040 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L118                   ; unconditionally jump
.L117:                                  
        mov     eax,[TRUE]              ; set eax to TRUE
.L118:                                  
        cmp     eax,0                   ; compare eax to 0
        je      .L119                   ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I41]               ; compare var000 and var041
        jl      .L120                   ; if var000 < var041 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L121                   ; unconditionally jump
.L120:                                  
        mov     eax,[TRUE]              ; set eax to TRUE
.L121:                                  
        cmp     eax,0                   ; compare eax to 0
        je      .L122                   ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I42]               ; compare var000 and var042
        jl      .L123                   ; if var000 < var042 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L124                   ; unconditionally jump
.L123:                                  
        mov     eax,[TRUE]              ; set eax to TRUE
.L124:                                  
        cmp     eax,0                   ; compare eax to 0
        je      .L125                   ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I43]               ; compare var000 and var043
        jl      .L126                   ; if var000 < var043 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L127                   ; unconditionally jump
.L126:                                  
        mov     eax,[TRUE]              ; set eax to TRUE
.L127:                                  
        cmp     eax,0                   ; compare eax to 0
        je      .L128                   ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I44]               ; compare var000 and var044
        jl      .L129                   ; if var000 < var044 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L130                   ; unconditionally jump
.L129:                                  
        mov     eax,[TRUE]              ; set eax to TRUE
.L130:                                  
        cmp     eax,0                   ; compare eax to 0
        je      .L131                   ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I45]               ; compare var000 and var045
        jl      .L132                   ; if var000 < var045 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L133                   ; unconditionally jump
.L132:                                  
        mov     eax,[TRUE]              ; set eax to TRUE
.L133:                                  
        cmp     eax,0                   ; compare eax to 0
        je      .L134                   ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I46]               ; compare var000 and var046
        jl      .L135                   ; if var000 < var046 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L136                   ; unconditionally jump
.L135:                                  
        mov     eax,[TRUE]              ; set eax to TRUE
.L136:                                  
        cmp     eax,0                   ; compare eax to 0
        je      .L137                   ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I47]               ; compare var000 and var047
        jl      .L138                   ; if var000 < var047 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L139                   ; unconditionally jump
.L138:                                  
        mov     eax,[TRUE]              ; set eax to TRUE
.L139:                                  
        cmp     eax,0                   ; compare eax to 0
        je      .L140                   ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I48]               ; compare var000 and var048
        jl      .L141                   ; if var000 < var048 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L142                   ; unconditionally jump
.L141:                                  
        mov     eax,[TRUE]              ; set eax to TRUE
.L142:                                  
        cmp     eax,0                   ; compare eax to 0
        je      .L143                   ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I49]               ; compare var000 and var049
        jl      .L144                   ; if var000 < var049 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L145                   ; unconditionally jump
.L144:                                  
        mov     eax,[TRUE]              ; set eax to TRUE
.L145:                                  
        cmp     eax,0                   ; compare eax to 0
        je      .L146                   ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I50]               ; compare var000 and var050
        jl      .L147                   ; if var000 < var050 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L148                   ; unconditionally jump
.L147:                                  
        mov     eax,[TRUE]              ; set eax to TRUE
.L148:                                  
        cmp     eax,0                   ; compare eax to 0
        je      .L149                   ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        cmp     eax,[I51]               ; compare var000 and var051
        jl      .L150                   ; if var000 < var051 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L151                   ; unconditionally jump
.L150:                                  
        mov     eax,[TRUE]              ; set eax to TRUE
.L151:                                  
        cmp     eax,0                   ; compare eax to 0
        je      .L152                   ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = var000
        mov     [I52],eax               ; small = AReg
.L152:                                  ; end if
.L149:                                  ; end if
.L146:                                  ; end if
.L143:                                  ; end if
.L140:                                  ; end if
.L137:                                  ; end if
.L134:                                  ; end if
.L131:                                  ; end if
.L128:                                  ; end if
.L125:                                  ; end if
.L122:                                  ; end if
.L119:                                  ; end if
.L116:                                  ; end if
.L113:                                  ; end if
.L110:                                  ; end if
.L107:                                  ; end if
.L104:                                  ; end if
.L101:                                  ; end if
.L98:                                   ; end if
.L95:                                   ; end if
.L92:                                   ; end if
.L89:                                   ; end if
.L86:                                   ; end if
.L83:                                   ; end if
.L80:                                   ; end if
.L77:                                   ; end if
.L74:                                   ; end if
.L71:                                   ; end if
.L68:                                   ; end if
.L65:                                   ; end if
.L62:                                   ; end if
.L59:                                   ; end if
.L56:                                   ; end if
.L53:                                   ; end if
.L50:                                   ; end if
.L47:                                   ; end if
.L44:                                   ; end if
.L41:                                   ; end if
.L38:                                   ; end if
.L35:                                   ; end if
.L32:                                   ; end if
.L29:                                   ; end if
.L26:                                   ; end if
.L23:                                   ; end if
.L20:                                   ; end if
.L17:                                   ; end if
.L14:                                   ; end if
.L11:                                   ; end if
.L8:                                    ; end if
.L5:                                    ; end if
.L2:                                    ; end if
        mov     eax,[I52]               ; load small in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                    
SECTION .data                           
FALSE   dd      0                       ; false
TRUE    dd      -1                      ; true

SECTION .bss                            
I52     resd    1                       ; small
I0      resd    1                       ; var000
I1      resd    1                       ; var001
I2      resd    1                       ; var002
I3      resd    1                       ; var003
I4      resd    1                       ; var004
I5      resd    1                       ; var005
I6      resd    1                       ; var006
I7      resd    1                       ; var007
I8      resd    1                       ; var008
I9      resd    1                       ; var009
I10     resd    1                       ; var010
I11     resd    1                       ; var011
I12     resd    1                       ; var012
I13     resd    1                       ; var013
I14     resd    1                       ; var014
I15     resd    1                       ; var015
I16     resd    1                       ; var016
I17     resd    1                       ; var017
I18     resd    1                       ; var018
I19     resd    1                       ; var019
I20     resd    1                       ; var020
I21     resd    1                       ; var021
I22     resd    1                       ; var022
I23     resd    1                       ; var023
I24     resd    1                       ; var024
I25     resd    1                       ; var025
I26     resd    1                       ; var026
I27     resd    1                       ; var027
I28     resd    1                       ; var028
I29     resd    1                       ; var029
I30     resd    1                       ; var030
I31     resd    1                       ; var031
I32     resd    1                       ; var032
I33     resd    1                       ; var033
I34     resd    1                       ; var034
I35     resd    1                       ; var035
I36     resd    1                       ; var036
I37     resd    1                       ; var037
I38     resd    1                       ; var038
I39     resd    1                       ; var039
I40     resd    1                       ; var040
I41     resd    1                       ; var041
I42     resd    1                       ; var042
I43     resd    1                       ; var043
I44     resd    1                       ; var044
I45     resd    1                       ; var045
I46     resd    1                       ; var046
I47     resd    1                       ; var047
I48     resd    1                       ; var048
I49     resd    1                       ; var049
I50     resd    1                       ; var050
I51     resd    1                       ; var051

./output/239.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no239

_start:                                 
        mov     eax,[I16]               ; AReg = 0
        mov     [I15],eax               ; counter = AReg
.L0:                                    ; repeat
        call    ReadInt                 ; read int; value placed in eax
        mov     [I0],eax                ; store eax at x
        cdq                             ; sign extend dividend from eax to edx:eax
        idiv    dword [I17]             ; AReg = x div 19
        xchg    eax,edx                 ; exchange quotient and remainder
        mov     [I1],eax                ; a = AReg
        mov     eax,[I0]                ; AReg = x
        cdq                             ; sign extend dividend from eax to edx:eax
        idiv    dword [I18]             ; AReg = x div 100
        mov     [I2],eax                ; b = AReg
        mov     eax,[I0]                ; AReg = x
        cdq                             ; sign extend dividend from eax to edx:eax
        idiv    dword [I18]             ; AReg = x div 100
        xchg    eax,edx                 ; exchange quotient and remainder
        mov     [I3],eax                ; c = AReg
        mov     eax,[I2]                ; AReg = b
        cdq                             ; sign extend dividend from eax to edx:eax
        idiv    dword [I19]             ; AReg = b div 4
        mov     [I4],eax                ; d = AReg
        mov     eax,[I2]                ; AReg = b
        cdq                             ; sign extend dividend from eax to edx:eax
        idiv    dword [I19]             ; AReg = b div 4
        xchg    eax,edx                 ; exchange quotient and remainder
        mov     [I5],eax                ; e = AReg
        mov     eax,[I2]                ; AReg = b
        add     eax,[I20]               ; AReg = b + 8
        cdq                             ; sign extend dividend from eax to edx:eax
        idiv    dword [I21]             ; AReg = T0 div 25
        mov     [I6],eax                ; f = AReg
        mov     eax,[I2]                ; AReg = b
        sub     eax,[I6]                ; AReg = b - f
        add     eax,[I22]               ; AReg = T0 + 1
        cdq                             ; sign extend dividend from eax to edx:eax
        idiv    dword [I23]             ; AReg = T0 div 3
        mov     [I7],eax                ; g = AReg
        mov     eax,[I17]               ; AReg = 19
        imul    dword [I1]              ; AReg = 19 * a
        add     eax,[I2]                ; AReg = T0 + b
        sub     eax,[I4]                ; AReg = T0 - d
        sub     eax,[I7]                ; AReg = T0 - g
        add     eax,[I24]               ; AReg = T0 + 15
        cdq                             ; sign extend dividend from eax to edx:eax
        idiv    dword [I25]             ; AReg = T0 div 30
        xchg    eax,edx                 ; exchange quotient and remainder
        mov     [I8],eax                ; h = AReg
        mov     eax,[I3]                ; AReg = c
        cdq                             ; sign extend dividend from eax to edx:eax
        idiv    dword [I19]             ; AReg = c div 4
        mov     [I9],eax                ; i = AReg
        mov     eax,[I3]                ; AReg = c
        cdq                             ; sign extend dividend from eax to edx:eax
        idiv    dword [I19]             ; AReg = c div 4
        xchg    eax,edx                 ; exchange quotient and remainder
        mov     [I10],eax               ; k = AReg
        mov     eax,[I27]               ; AReg = 2
        imul    dword [I5]              ; AReg = 2 * e
        add     eax,[I26]               ; AReg = T0 + 32
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I27]               ; AReg = 2
        imul    dword [I9]              ; AReg = 2 * i
        add     eax,[T0]                ; AReg = T1 + T0
        sub     eax,[I8]                ; AReg = T0 - h
        sub     eax,[I10]               ; AReg = T0 - k
        cdq                             ; sign extend dividend from eax to edx:eax
        idiv    dword [I28]             ; AReg = T0 div 7
        xchg    eax,edx                 ; exchange quotient and remainder
        mov     [I11],eax               ; l = AReg
        mov     eax,[I29]               ; AReg = 11
        imul    dword [I8]              ; AReg = 11 * h
        add     eax,[I1]                ; AReg = T0 + a
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I30]               ; AReg = 22
        imul    dword [I11]             ; AReg = 22 * l
        add     eax,[T0]                ; AReg = T1 + T0
        cdq                             ; sign extend dividend from eax to edx:eax
        idiv    dword [I31]             ; AReg = T0 div 451
        mov     [I12],eax               ; m = AReg
        mov     eax,[I8]                ; AReg = h
        add     eax,[I11]               ; AReg = h + l
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I28]               ; AReg = 7
        imul    dword [I12]             ; AReg = 7 * m
        mov     [T1],eax                ; deassign AReg
        mov     eax,[T0]                ; AReg = T0
        sub     eax,[T1]                ; AReg = T0 - T1
        add     eax,[I32]               ; AReg = T0 + 114
        cdq                             ; sign extend dividend from eax to edx:eax
        idiv    dword [I33]             ; AReg = T0 div 31
        mov     [I13],eax               ; n = AReg
        mov     eax,[I8]                ; AReg = h
        add     eax,[I11]               ; AReg = h + l
        mov     [T0],eax                ; deassign AReg
        mov     eax,[I28]               ; AReg = 7
        imul    dword [I12]             ; AReg = 7 * m
        mov     [T1],eax                ; deassign AReg
        mov     eax,[T0]                ; AReg = T0
        sub     eax,[T1]                ; AReg = T0 - T1
        add     eax,[I32]               ; AReg = T0 + 114
        cdq                             ; sign extend dividend from eax to edx:eax
        idiv    dword [I33]             ; AReg = T0 div 31
        xchg    eax,edx                 ; exchange quotient and remainder
        mov     [I14],eax               ; p = AReg
        mov     eax,[I13]               ; load n in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I14]               ; AReg = p
        add     eax,[I22]               ; AReg = p + 1
        mov     [I14],eax               ; p = AReg
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I0]                ; load x in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I15]               ; AReg = counter
        add     eax,[I22]               ; AReg = counter + 1
        mov     [I15],eax               ; counter = AReg
        cmp     eax,[I34]               ; compare counter and 40
        je      .L1                     ; if counter = 40 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L2                     ; unconditionally jump
.L1:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L2:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L0                     ; until T0 is true
        Exit    {0}
                    
SECTION .data                           
I16     dd      0                       ; 0
I22     dd      1                       ; 1
I18     dd      100                     ; 100
I29     dd      11                      ; 11
I32     dd      114                     ; 114
I24     dd      15                      ; 15
I17     dd      19                      ; 19
I27     dd      2                       ; 2
I30     dd      22                      ; 22
I21     dd      25                      ; 25
I23     dd      3                       ; 3
I25     dd      30                      ; 30
I33     dd      31                      ; 31
I26     dd      32                      ; 32
I19     dd      4                       ; 4
I34     dd      40                      ; 40
I31     dd      451                     ; 451
I28     dd      7                       ; 7
I20     dd      8                       ; 8
FALSE   dd      0                       ; false
TRUE    dd      -1                      ; true

SECTION .bss                            
T0      resd    1                       ; T0
T1      resd    1                       ; T1
I1      resd    1                       ; a
I2      resd    1                       ; b
I3      resd    1                       ; c
I15     resd    1                       ; counter
I4      resd    1                       ; d
I5      resd    1                       ; e
I6      resd    1                       ; f
I7      resd    1                       ; g
I8      resd    1                       ; h
I9      resd    1                       ; i
I10     resd    1                       ; k
I11     resd    1                       ; l
I12     resd    1                       ; m
I13     resd    1                       ; n
I14     resd    1                       ; p
I0      resd    1                       ; x

./output/240.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no240

_start:                                 
        call    ReadInt                 ; read int; value placed in eax
        mov     [I0],eax                ; store eax at h
.L0:                                    ; while
        mov     eax,[I0]                ; AReg = h
        cmp     eax,[I5]                ; compare h and 0
        jg      .L1                     ; if h > 0 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L2                     ; unconditionally jump
.L1:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L2:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L3                     ; if T0 is false then jump to end while
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at u
        call    ReadInt                 ; read int; value placed in eax
        mov     [I2],eax                ; store eax at v
        mov     eax,[I1]                ; load u in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I2]                ; load v in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I1]                ; AReg = u
        cmp     eax,[I5]                ; compare u and 0
        jl      .L4                     ; if u < 0 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L5                     ; unconditionally jump
.L4:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L5:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L6                     ; if T0 is false then jump to end of if
        mov     eax,[I1]                ; AReg = u
        imul    dword [I6]              ; AReg = u * -1
        mov     [I1],eax                ; u = AReg
.L6:                                    ; end if
        mov     eax,[I2]                ; AReg = v
        cmp     eax,[I5]                ; compare v and 0
        jl      .L7                     ; if v < 0 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L8                     ; unconditionally jump
.L7:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L8:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L9                     ; if T0 is false then jump to end of if
        mov     eax,[I2]                ; AReg = v
        imul    dword [I6]              ; AReg = v * -1
        mov     [I2],eax                ; v = AReg
.L9:                                    ; end if
        mov     eax,[I1]                ; AReg = u
        cmp     eax,[I5]                ; compare u and 0
        je      .L10                    ; if u = 0 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L11                    ; unconditionally jump
.L10:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L11:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L12                    ; if T0 is false then jump to end of if
        mov     eax,[I2]                ; AReg = v
        mov     [I3],eax                ; gcd = AReg
        jmp     .L13                    ; jump to end if
.L12:                                   ; else
        mov     eax,[I2]                ; AReg = v
        cmp     eax,[I5]                ; compare v and 0
        je      .L14                    ; if v = 0 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L15                    ; unconditionally jump
.L14:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L15:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L16                    ; if T0 is false then jump to end of if
        mov     eax,[I1]                ; AReg = u
        mov     [I3],eax                ; gcd = AReg
        jmp     .L17                    ; jump to end if
.L16:                                   ; else
.L18:                                   ; repeat
        mov     eax,[I1]                ; AReg = u
        cdq                             ; sign extend dividend from eax to edx:eax
        idiv    dword [I2]              ; AReg = u div v
        xchg    eax,edx                 ; exchange quotient and remainder
        mov     [I4],eax                ; rem = AReg
        mov     eax,[I2]                ; AReg = v
        mov     [I1],eax                ; u = AReg
        mov     eax,[I4]                ; AReg = rem
        mov     [I2],eax                ; v = AReg
        mov     eax,[I4]                ; AReg = rem
        cmp     eax,[I5]                ; compare rem and 0
        je      .L19                    ; if rem = 0 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L20                    ; unconditionally jump
.L19:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L20:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L18                    ; until T0 is true
        mov     eax,[I1]                ; AReg = u
        mov     [I3],eax                ; gcd = AReg
.L17:                                   ; end if
.L13:                                   ; end if
        mov     eax,[I3]                ; load gcd in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I0]                ; AReg = h
        sub     eax,[I7]                ; AReg = h - 1
        mov     [I0],eax                ; h = AReg
        jmp     .L0                     ; end while
.L3:                                    
        Exit    {0}
                    
SECTION .data                           
I6      dd      -1                      ; -1
I5      dd      0                       ; 0
I7      dd      1                       ; 1
FALSE   dd      0                       ; false
TRUE    dd      -1                      ; true

SECTION .bss                            
I3      resd    1                       ; gcd
I0      resd    1                       ; h
I4      resd    1                       ; rem
I1      resd    1                       ; u
I2      resd    1                       ; v

./output/241.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no241

_start:                                 
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at first
        call    ReadInt                 ; read int; value placed in eax
        mov     [I2],eax                ; store eax at second
        mov     eax,[I4]                ; AReg = 0
        mov     [I3],eax                ; ct = AReg
.L0:                                    ; while
        mov     eax,[I3]                ; AReg = ct
        cmp     eax,[I5]                ; compare ct and 47
        jl      .L1                     ; if ct < 47 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L2                     ; unconditionally jump
.L1:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L2:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L3                     ; if T0 is false then jump to end while
        mov     eax,[I1]                ; load first in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        add     eax,[I2]                ; AReg = first + second
        mov     [I2],eax                ; second = AReg
        sub     eax,[I1]                ; AReg = second - first
        mov     [I1],eax                ; first = AReg
        mov     eax,[I3]                ; AReg = ct
        add     eax,[I6]                ; AReg = ct + 1
        mov     [I3],eax                ; ct = AReg
        jmp     .L0                     ; end while
.L3:                                    
        Exit    {0}
                    
SECTION .data                           
I4      dd      0                       ; 0
I6      dd      1                       ; 1
I5      dd      47                      ; 47
FALSE   dd      0                       ; false
I0      dd      2147483647              ; largest
TRUE    dd      -1                      ; true

SECTION .bss                            
I3      resd    1                       ; ct
I1      resd    1                       ; first
I2      resd    1                       ; second

./output/242.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no242

_start:                                 
        call    ReadInt                 ; read int; value placed in eax
        mov     [I0],eax                ; store eax at m
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at n
        mov     eax,[I0]                ; load m in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I1]                ; load n in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I0]                ; AReg = m
        cmp     eax,[I3]                ; compare m and 0
        jl      .L0                     ; if m < 0 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L2                     ; if T0 is false then jump to end of if
        mov     eax,[I4]                ; AReg = -1
        imul    dword [I0]              ; AReg = -1 * m
        mov     [I0],eax                ; m = AReg
.L2:                                    ; end if
        mov     eax,[I1]                ; AReg = n
        cmp     eax,[I3]                ; compare n and 0
        jl      .L3                     ; if n < 0 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L4                     ; unconditionally jump
.L3:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L4:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L5                     ; if T0 is false then jump to end of if
        mov     eax,[I1]                ; AReg = n
        neg     eax                     ; AReg = -AReg
        mov     [I1],eax                ; n = AReg
.L5:                                    ; end if
        mov     eax,[I0]                ; AReg = m
        cdq                             ; sign extend dividend from eax to edx:eax
        idiv    dword [I1]              ; AReg = m div n
        xchg    eax,edx                 ; exchange quotient and remainder
        mov     [I2],eax                ; rem = AReg
.L6:                                    ; while
        mov     eax,[I2]                ; AReg = rem
        cmp     eax,[I3]                ; compare rem and 0
        je      .L7                     ; if rem = 0 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L8                     ; unconditionally jump
.L7:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L8:                                    
        not     eax                     ; AReg = !AReg
        cmp     eax,0                   ; compare eax to 0
        je      .L9                     ; if T0 is false then jump to end while
        mov     eax,[I1]                ; AReg = n
        mov     [I0],eax                ; m = AReg
        mov     eax,[I2]                ; AReg = rem
        mov     [I1],eax                ; n = AReg
        mov     eax,[I0]                ; AReg = m
        cdq                             ; sign extend dividend from eax to edx:eax
        idiv    dword [I1]              ; AReg = m div n
        xchg    eax,edx                 ; exchange quotient and remainder
        mov     [I2],eax                ; rem = AReg
        jmp     .L6                     ; end while
.L9:                                    
        mov     eax,[I1]                ; load n in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                    
SECTION .data                           
I4      dd      -1                      ; -1
I3      dd      0                       ; 0
FALSE   dd      0                       ; false
TRUE    dd      -1                      ; true

SECTION .bss                            
I0      resd    1                       ; m
I1      resd    1                       ; n
I2      resd    1                       ; rem

./output/243.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no243

_start:                                 
        call    ReadInt                 ; read int; value placed in eax
        mov     [I0],eax                ; store eax at m
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at n
        mov     eax,[I0]                ; load m in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I1]                ; load n in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I0]                ; AReg = m
        cmp     eax,[I3]                ; compare m and 0
        jl      .L0                     ; if m < 0 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L2                     ; if T0 is false then jump to end of if
        mov     eax,[I4]                ; AReg = -1
        imul    dword [I0]              ; AReg = -1 * m
        mov     [I0],eax                ; m = AReg
.L2:                                    ; end if
        mov     eax,[I1]                ; AReg = n
        cmp     eax,[I3]                ; compare n and 0
        jl      .L3                     ; if n < 0 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L4                     ; unconditionally jump
.L3:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L4:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L5                     ; if T0 is false then jump to end of if
        mov     eax,[I1]                ; AReg = n
        neg     eax                     ; AReg = -AReg
        mov     [I1],eax                ; n = AReg
.L5:                                    ; end if
        mov     eax,[I0]                ; AReg = m
        cdq                             ; sign extend dividend from eax to edx:eax
        idiv    dword [I1]              ; AReg = m div n
        xchg    eax,edx                 ; exchange quotient and remainder
        mov     [I2],eax                ; rem = AReg
        cmp     eax,[I3]                ; compare rem and 0
        je      .L6                     ; if rem = 0 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L7                     ; unconditionally jump
.L6:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L7:                                    
        mov     [B0],eax                ; done = AReg
.L8:                                    ; while
        mov     eax,[B0]                ; AReg = done
        not     eax                     ; AReg = !AReg
        cmp     eax,0                   ; compare eax to 0
        je      .L9                     ; if T0 is false then jump to end while
        mov     eax,[I1]                ; AReg = n
        mov     [I0],eax                ; m = AReg
        mov     eax,[I2]                ; AReg = rem
        mov     [I1],eax                ; n = AReg
        mov     eax,[I0]                ; AReg = m
        cdq                             ; sign extend dividend from eax to edx:eax
        idiv    dword [I1]              ; AReg = m div n
        xchg    eax,edx                 ; exchange quotient and remainder
        mov     [I2],eax                ; rem = AReg
        cmp     eax,[I3]                ; compare rem and 0
        je      .L10                    ; if rem = 0 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L11                    ; unconditionally jump
.L10:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L11:                                   
        mov     [B0],eax                ; done = AReg
        jmp     .L8                     ; end while
.L9:                                    
        mov     eax,[I1]                ; load n in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                    
SECTION .data                           
I4      dd      -1                      ; -1
I3      dd      0                       ; 0
FALSE   dd      0                       ; false
TRUE    dd      -1                      ; true

SECTION .bss                            
B0      resd    1                       ; done
I0      resd    1                       ; m
I1      resd    1                       ; n
I2      resd    1                       ; rem

./output/244.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no244

_start:                                 
        call    ReadInt                 ; read int; value placed in eax
        mov     [I0],eax                ; store eax at m
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at n
        mov     eax,[I0]                ; load m in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I1]                ; load n in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I0]                ; AReg = m
        cmp     eax,[I3]                ; compare m and 0
        jl      .L0                     ; if m < 0 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L2                     ; if T0 is false then jump to end of if
        mov     eax,[I4]                ; AReg = -1
        imul    dword [I0]              ; AReg = -1 * m
        mov     [I0],eax                ; m = AReg
.L2:                                    ; end if
        mov     eax,[I1]                ; AReg = n
        cmp     eax,[I3]                ; compare n and 0
        jl      .L3                     ; if n < 0 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L4                     ; unconditionally jump
.L3:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L4:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L5                     ; if T0 is false then jump to end of if
        mov     eax,[I1]                ; AReg = n
        neg     eax                     ; AReg = -AReg
        mov     [I1],eax                ; n = AReg
.L5:                                    ; end if
.L6:                                    ; repeat
        mov     eax,[I0]                ; AReg = m
        cdq                             ; sign extend dividend from eax to edx:eax
        idiv    dword [I1]              ; AReg = m div n
        xchg    eax,edx                 ; exchange quotient and remainder
        mov     [I2],eax                ; rem = AReg
        mov     eax,[I1]                ; AReg = n
        mov     [I0],eax                ; m = AReg
        mov     eax,[I2]                ; AReg = rem
        mov     [I1],eax                ; n = AReg
        mov     eax,[I2]                ; AReg = rem
        cmp     eax,[I3]                ; compare rem and 0
        je      .L7                     ; if rem = 0 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L8                     ; unconditionally jump
.L7:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L8:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L6                     ; until T0 is true
        mov     eax,[I0]                ; load m in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                    
SECTION .data                           
I4      dd      -1                      ; -1
I3      dd      0                       ; 0
FALSE   dd      0                       ; false
TRUE    dd      -1                      ; true

SECTION .bss                            
B0      resd    1                       ; done
I0      resd    1                       ; m
I1      resd    1                       ; n
I2      resd    1                       ; rem

./output/245.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no245

_start:                                 
        call    ReadInt                 ; read int; value placed in eax
        mov     [I0],eax                ; store eax at m
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at n
        mov     eax,[I0]                ; load m in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I1]                ; load n in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I0]                ; AReg = m
        cmp     eax,[I3]                ; compare m and 0
        jl      .L0                     ; if m < 0 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L2                     ; if T0 is false then jump to end of if
        mov     eax,[I4]                ; AReg = -1
        imul    dword [I0]              ; AReg = -1 * m
        mov     [I0],eax                ; m = AReg
.L2:                                    ; end if
        mov     eax,[I1]                ; AReg = n
        cmp     eax,[I3]                ; compare n and 0
        jl      .L3                     ; if n < 0 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L4                     ; unconditionally jump
.L3:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L4:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L5                     ; if T0 is false then jump to end of if
        mov     eax,[I1]                ; AReg = n
        neg     eax                     ; AReg = -AReg
        mov     [I1],eax                ; n = AReg
.L5:                                    ; end if
.L6:                                    ; repeat
        mov     eax,[I0]                ; AReg = m
        cdq                             ; sign extend dividend from eax to edx:eax
        idiv    dword [I1]              ; AReg = m div n
        xchg    eax,edx                 ; exchange quotient and remainder
        mov     [I2],eax                ; rem = AReg
        cmp     eax,[I3]                ; compare rem and 0
        je      .L7                     ; if rem = 0 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L8                     ; unconditionally jump
.L7:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L8:                                    
        mov     [B0],eax                ; done = AReg
        not     eax                     ; AReg = !AReg
        cmp     eax,0                   ; compare eax to 0
        je      .L9                     ; if T0 is false then jump to end of if
        mov     eax,[I1]                ; AReg = n
        mov     [I0],eax                ; m = AReg
        mov     eax,[I2]                ; AReg = rem
        mov     [I1],eax                ; n = AReg
.L9:                                    ; end if
        mov     eax,[B0]                ; AReg = B0
        cmp     eax,0                   ; compare eax to 0
        je      .L6                     ; until done is true
        mov     eax,[I1]                ; load n in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                    
SECTION .data                           
I4      dd      -1                      ; -1
I3      dd      0                       ; 0
FALSE   dd      0                       ; false
TRUE    dd      -1                      ; true

SECTION .bss                            
B0      resd    1                       ; done
I0      resd    1                       ; m
I1      resd    1                       ; n
I2      resd    1                       ; rem

./output/246.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no246

_start:                                 
        call    ReadInt                 ; read int; value placed in eax
        mov     [I0],eax                ; store eax at m
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at n
        mov     eax,[I0]                ; load m in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I1]                ; load n in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I0]                ; AReg = m
        cmp     eax,[I1]                ; compare m and n
        jl      .L0                     ; if m < n then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L2                     ; if T0 is false then jump to end of if
        mov     eax,[I3]                ; AReg = -1
        mov     [I2],eax                ; cmp = AReg
        jmp     .L3                     ; jump to end if
.L2:                                    ; else
        mov     eax,[I0]                ; AReg = m
        cmp     eax,[I1]                ; compare m and n
        je      .L4                     ; if m = n then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L5                     ; unconditionally jump
.L4:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L5:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L6                     ; if T0 is false then jump to end of if
        mov     eax,[I4]                ; AReg = 0
        mov     [I2],eax                ; cmp = AReg
        jmp     .L7                     ; jump to end if
.L6:                                    ; else
        mov     eax,[I5]                ; AReg = 1
        mov     [I2],eax                ; cmp = AReg
.L7:                                    ; end if
.L3:                                    ; end if
        mov     eax,[I2]                ; load cmp in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                    
SECTION .data                           
I3      dd      -1                      ; -1
I4      dd      0                       ; 0
I5      dd      1                       ; 1
FALSE   dd      0                       ; false
TRUE    dd      -1                      ; true

SECTION .bss                            
I2      resd    1                       ; cmp
I0      resd    1                       ; m
I1      resd    1                       ; n

./output/247.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no247

_start:                                 
        call    ReadInt                 ; read int; value placed in eax
        mov     [I0],eax                ; store eax at m
        call    ReadInt                 ; read int; value placed in eax
        mov     [I1],eax                ; store eax at n
        mov     eax,[I0]                ; load m in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I1]                ; load n in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I3]                ; AReg = 0
        mov     [I2],eax                ; cmp = AReg
        mov     eax,[I0]                ; AReg = m
        cmp     eax,[I1]                ; compare m and n
        jle     .L0                     ; if m <= n then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L2                     ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = m
        cmp     eax,[I1]                ; compare m and n
        je      .L3                     ; if m = n then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L4                     ; unconditionally jump
.L3:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L4:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L5                     ; if T0 is false then jump to end of if
        mov     eax,[I4]                ; AReg = 1
        mov     [I2],eax                ; cmp = AReg
        jmp     .L6                     ; jump to end if
.L5:                                    ; else
        mov     eax,[I5]                ; AReg = 2
        mov     [I2],eax                ; cmp = AReg
.L6:                                    ; end if
.L2:                                    ; end if
        mov     eax,[I2]                ; load cmp in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I3]                ; AReg = 0
        mov     [I2],eax                ; cmp = AReg
        mov     eax,[I0]                ; AReg = m
        cmp     eax,[I1]                ; compare m and n
        jle     .L7                     ; if m <= n then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L8                     ; unconditionally jump
.L7:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L8:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L9                     ; if T0 is false then jump to end of if
        mov     eax,[I0]                ; AReg = m
        cmp     eax,[I1]                ; compare m and n
        je      .L10                    ; if m = n then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L11                    ; unconditionally jump
.L10:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L11:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L12                    ; if T0 is false then jump to end of if
        mov     eax,[I4]                ; AReg = 1
        mov     [I2],eax                ; cmp = AReg
.L12:                                   ; end if
        jmp     .L13                    ; jump to end if
.L9:                                    ; else
        mov     eax,[I5]                ; AReg = 2
        mov     [I2],eax                ; cmp = AReg
.L13:                                   ; end if
        mov     eax,[I2]                ; load cmp in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                    
SECTION .data                           
I3      dd      0                       ; 0
I4      dd      1                       ; 1
I5      dd      2                       ; 2
FALSE   dd      0                       ; false
TRUE    dd      -1                      ; true

SECTION .bss                            
I2      resd    1                       ; cmp
I0      resd    1                       ; m
I1      resd    1                       ; n

./output/248.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no248

_start:                                 
        call    ReadInt                 ; read int; value placed in eax
        mov     [I3],eax                ; store eax at x
        call    ReadInt                 ; read int; value placed in eax
        mov     [I4],eax                ; store eax at y
        mov     eax,[I3]                ; load x in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I4]                ; load y in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I5]                ; AReg = 0
        mov     [I2],eax                ; cmp = AReg
        mov     eax,[I3]                ; AReg = x
        mov     [I0],eax                ; m = AReg
        mov     eax,[I4]                ; AReg = y
        mov     [I1],eax                ; n = AReg
        mov     eax,[I0]                ; AReg = m
        cmp     eax,[I1]                ; compare m and n
        jl      .L0                     ; if m < n then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L1                     ; unconditionally jump
.L0:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L1:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L2                     ; if T0 is false then jump to end of if
        mov     eax,[I2]                ; AReg = cmp
        add     eax,[I6]                ; AReg = cmp + 1
        mov     [I2],eax                ; cmp = AReg
.L2:                                    ; end if
        mov     eax,[I2]                ; AReg = cmp
        add     eax,[I7]                ; AReg = cmp + 2
        mov     [I2],eax                ; cmp = AReg
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I5]                ; AReg = 0
        mov     [I2],eax                ; cmp = AReg
        mov     eax,[I3]                ; AReg = x
        mov     [I0],eax                ; m = AReg
        mov     eax,[I4]                ; AReg = y
        mov     [I1],eax                ; n = AReg
.L3:                                    ; while
        mov     eax,[I0]                ; AReg = m
        cmp     eax,[I1]                ; compare m and n
        jl      .L4                     ; if m < n then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L5                     ; unconditionally jump
.L4:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L5:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L6                     ; if T0 is false then jump to end while
        mov     eax,[I0]                ; AReg = m
        add     eax,[I6]                ; AReg = m + 1
        mov     [I0],eax                ; m = AReg
        cmp     eax,[I1]                ; compare m and n
        jl      .L7                     ; if m < n then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L8                     ; unconditionally jump
.L7:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L8:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L9                     ; if T0 is false then jump to end of if
        mov     eax,[I2]                ; AReg = cmp
        add     eax,[I6]                ; AReg = cmp + 1
        mov     [I2],eax                ; cmp = AReg
.L9:                                    ; end if
        jmp     .L3                     ; end while
.L6:                                    
        mov     eax,[I2]                ; load cmp in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I5]                ; AReg = 0
        mov     [I2],eax                ; cmp = AReg
        mov     eax,[I3]                ; AReg = x
        mov     [I0],eax                ; m = AReg
        mov     eax,[I4]                ; AReg = y
        mov     [I1],eax                ; n = AReg
        mov     eax,[I0]                ; AReg = m
        cmp     eax,[I1]                ; compare m and n
        jl      .L10                    ; if m < n then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L11                    ; unconditionally jump
.L10:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L11:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L12                    ; if T0 is false then jump to end of if
        mov     eax,[I6]                ; AReg = 1
        mov     [I2],eax                ; cmp = AReg
.L12:                                   ; end if
        mov     eax,[I2]                ; load cmp in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I5]                ; AReg = 0
        mov     [I2],eax                ; cmp = AReg
        mov     eax,[I3]                ; AReg = x
        mov     [I0],eax                ; m = AReg
        mov     eax,[I4]                ; AReg = y
        mov     [I1],eax                ; n = AReg
        mov     eax,[I0]                ; AReg = m
        cmp     eax,[I1]                ; compare m and n
        jl      .L13                    ; if m < n then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L14                    ; unconditionally jump
.L13:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L14:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L15                    ; if T0 is false then jump to end of if
        mov     eax,[I6]                ; AReg = 1
        mov     [I2],eax                ; cmp = AReg
.L15:                                   ; end if
        mov     eax,[I2]                ; load cmp in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I5]                ; AReg = 0
        mov     [I2],eax                ; cmp = AReg
        mov     eax,[I3]                ; AReg = x
        mov     [I0],eax                ; m = AReg
        mov     eax,[I4]                ; AReg = y
        mov     [I1],eax                ; n = AReg
        mov     eax,[I0]                ; AReg = m
        cmp     eax,[I1]                ; compare m and n
        jl      .L16                    ; if m < n then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L17                    ; unconditionally jump
.L16:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L17:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L18                    ; if T0 is false then jump to end of if
        mov     eax,[I6]                ; AReg = 1
        mov     [I2],eax                ; cmp = AReg
.L18:                                   ; end if
        mov     eax,[I0]                ; AReg = m
        cmp     eax,[I1]                ; compare m and n
        je      .L19                    ; if m = n then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L20                    ; unconditionally jump
.L19:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L20:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L21                    ; if T0 is false then jump to end of if
        mov     eax,[I7]                ; AReg = 2
        mov     [I2],eax                ; cmp = AReg
.L21:                                   ; end if
        mov     eax,[I2]                ; load cmp in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I5]                ; AReg = 0
        mov     [I2],eax                ; cmp = AReg
        mov     eax,[I3]                ; AReg = x
        mov     [I0],eax                ; m = AReg
        mov     eax,[I4]                ; AReg = y
        mov     [I1],eax                ; n = AReg
        mov     eax,[I0]                ; AReg = m
        cmp     eax,[I1]                ; compare m and n
        jl      .L22                    ; if m < n then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L23                    ; unconditionally jump
.L22:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L23:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L24                    ; if T0 is false then jump to end of if
        mov     eax,[I6]                ; AReg = 1
        mov     [I2],eax                ; cmp = AReg
.L24:                                   ; end if
.L25:                                   ; while
        mov     eax,[I0]                ; AReg = m
        cmp     eax,[I1]                ; compare m and n
        jl      .L26                    ; if m < n then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L27                    ; unconditionally jump
.L26:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L27:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L28                    ; if T0 is false then jump to end while
        mov     eax,[I0]                ; AReg = m
        add     eax,[I6]                ; AReg = m + 1
        mov     [I0],eax                ; m = AReg
        cmp     eax,[I1]                ; compare m and n
        jl      .L29                    ; if m < n then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L30                    ; unconditionally jump
.L29:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L30:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L31                    ; if T0 is false then jump to end of if
        mov     eax,[I2]                ; AReg = cmp
        add     eax,[I6]                ; AReg = cmp + 1
        mov     [I2],eax                ; cmp = AReg
.L31:                                   ; end if
        jmp     .L25                    ; end while
.L28:                                   
        mov     eax,[I2]                ; load cmp in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I5]                ; AReg = 0
        mov     [I2],eax                ; cmp = AReg
        mov     eax,[I3]                ; AReg = x
        mov     [I0],eax                ; m = AReg
        mov     eax,[I4]                ; AReg = y
        mov     [I1],eax                ; n = AReg
        mov     eax,[I0]                ; AReg = m
        cmp     eax,[I1]                ; compare m and n
        jl      .L32                    ; if m < n then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L33                    ; unconditionally jump
.L32:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L33:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L34                    ; if T0 is false then jump to end of if
        mov     eax,[I6]                ; AReg = 1
        mov     [I2],eax                ; cmp = AReg
.L34:                                   ; end if
.L35:                                   ; repeat
        mov     eax,[I0]                ; AReg = m
        add     eax,[I6]                ; AReg = m + 1
        mov     [I0],eax                ; m = AReg
        cmp     eax,[I1]                ; compare m and n
        jl      .L36                    ; if m < n then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L37                    ; unconditionally jump
.L36:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L37:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L38                    ; if T0 is false then jump to end of if
        mov     eax,[I2]                ; AReg = cmp
        add     eax,[I6]                ; AReg = cmp + 1
        mov     [I2],eax                ; cmp = AReg
.L38:                                   ; end if
        mov     eax,[I0]                ; AReg = m
        cmp     eax,[I1]                ; compare m and n
        jge     .L39                    ; if m >= n then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L40                    ; unconditionally jump
.L39:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L40:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L35                    ; until T0 is true
        mov     eax,[I2]                ; load cmp in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I5]                ; AReg = 0
        mov     [I2],eax                ; cmp = AReg
        mov     eax,[I3]                ; AReg = x
        mov     [I0],eax                ; m = AReg
        mov     eax,[I4]                ; AReg = y
        mov     [I1],eax                ; n = AReg
        mov     eax,[I0]                ; AReg = m
        cmp     eax,[I1]                ; compare m and n
        jl      .L41                    ; if m < n then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L42                    ; unconditionally jump
.L41:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L42:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L43                    ; if T0 is false then jump to end of if
        mov     eax,[I6]                ; AReg = 1
        mov     [I2],eax                ; cmp = AReg
.L43:                                   ; end if
        mov     eax,[I2]                ; load cmp in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I5]                ; AReg = 0
        mov     [I2],eax                ; cmp = AReg
        mov     eax,[I3]                ; AReg = x
        mov     [I0],eax                ; m = AReg
        mov     eax,[I4]                ; AReg = y
        mov     [I1],eax                ; n = AReg
        mov     eax,[I0]                ; AReg = m
        cmp     eax,[I1]                ; compare m and n
        jl      .L44                    ; if m < n then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L45                    ; unconditionally jump
.L44:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L45:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L46                    ; if T0 is false then jump to end of if
        mov     eax,[I6]                ; AReg = 1
        mov     [I2],eax                ; cmp = AReg
.L46:                                   ; end if
        call    ReadInt                 ; read int; value placed in eax
        mov     [I2],eax                ; store eax at cmp
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                    
SECTION .data                           
I5      dd      0                       ; 0
I6      dd      1                       ; 1
I7      dd      2                       ; 2
FALSE   dd      0                       ; false
TRUE    dd      -1                      ; true

SECTION .bss                            
I2      resd    1                       ; cmp
I0      resd    1                       ; m
I1      resd    1                       ; n
I3      resd    1                       ; x
I4      resd    1                       ; y

./output/249.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no249

_start:                                 
        call    ReadInt                 ; read int; value placed in eax
        mov     [I3],eax                ; store eax at v0
        call    ReadInt                 ; read int; value placed in eax
        mov     [I4],eax                ; store eax at v1
        call    ReadInt                 ; read int; value placed in eax
        mov     [I5],eax                ; store eax at v2
        call    ReadInt                 ; read int; value placed in eax
        mov     [I6],eax                ; store eax at v3
        call    ReadInt                 ; read int; value placed in eax
        mov     [I7],eax                ; store eax at v4
        call    ReadInt                 ; read int; value placed in eax
        mov     [I8],eax                ; store eax at v5
        call    ReadInt                 ; read int; value placed in eax
        mov     [I9],eax                ; store eax at v6
        call    ReadInt                 ; read int; value placed in eax
        mov     [I10],eax               ; store eax at v7
        call    ReadInt                 ; read int; value placed in eax
        mov     [I11],eax               ; store eax at v8
        call    ReadInt                 ; read int; value placed in eax
        mov     [I12],eax               ; store eax at v9
        mov     eax,[I3]                ; load v0 in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I4]                ; load v1 in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I5]                ; load v2 in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I6]                ; load v3 in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I7]                ; load v4 in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I8]                ; load v5 in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I9]                ; load v6 in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I10]               ; load v7 in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I11]               ; load v8 in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I12]               ; load v9 in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I13]               ; AReg = 0
        mov     [I1],eax                ; pass = AReg
.L0:                                    ; while
        mov     eax,[I1]                ; AReg = pass
        cmp     eax,[I0]                ; compare pass and n
        jl      .L1                     ; if pass < n then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L2                     ; unconditionally jump
.L1:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L2:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L3                     ; if T0 is false then jump to end while
        mov     eax,[I3]                ; AReg = v0
        cmp     eax,[I4]                ; compare v0 and v1
        jg      .L4                     ; if v0 > v1 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L5                     ; unconditionally jump
.L4:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L5:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L6                     ; if T0 is false then jump to end of if
        mov     eax,[I3]                ; AReg = v0
        mov     [I2],eax                ; temp = AReg
        mov     eax,[I4]                ; AReg = v1
        mov     [I3],eax                ; v0 = AReg
        mov     eax,[I2]                ; AReg = temp
        mov     [I4],eax                ; v1 = AReg
.L6:                                    ; end if
        mov     eax,[I4]                ; AReg = v1
        cmp     eax,[I5]                ; compare v1 and v2
        jg      .L7                     ; if v1 > v2 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L8                     ; unconditionally jump
.L7:                                    
        mov     eax,[TRUE]              ; set eax to TRUE
.L8:                                    
        cmp     eax,0                   ; compare eax to 0
        je      .L9                     ; if T0 is false then jump to end of if
        mov     eax,[I4]                ; AReg = v1
        mov     [I2],eax                ; temp = AReg
        mov     eax,[I5]                ; AReg = v2
        mov     [I4],eax                ; v1 = AReg
        mov     eax,[I2]                ; AReg = temp
        mov     [I5],eax                ; v2 = AReg
.L9:                                    ; end if
        mov     eax,[I5]                ; AReg = v2
        cmp     eax,[I6]                ; compare v2 and v3
        jg      .L10                    ; if v2 > v3 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L11                    ; unconditionally jump
.L10:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L11:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L12                    ; if T0 is false then jump to end of if
        mov     eax,[I5]                ; AReg = v2
        mov     [I2],eax                ; temp = AReg
        mov     eax,[I6]                ; AReg = v3
        mov     [I5],eax                ; v2 = AReg
        mov     eax,[I2]                ; AReg = temp
        mov     [I6],eax                ; v3 = AReg
.L12:                                   ; end if
        mov     eax,[I6]                ; AReg = v3
        cmp     eax,[I7]                ; compare v3 and v4
        jg      .L13                    ; if v3 > v4 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L14                    ; unconditionally jump
.L13:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L14:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L15                    ; if T0 is false then jump to end of if
        mov     eax,[I6]                ; AReg = v3
        mov     [I2],eax                ; temp = AReg
        mov     eax,[I7]                ; AReg = v4
        mov     [I6],eax                ; v3 = AReg
        mov     eax,[I2]                ; AReg = temp
        mov     [I7],eax                ; v4 = AReg
.L15:                                   ; end if
        mov     eax,[I7]                ; AReg = v4
        cmp     eax,[I8]                ; compare v4 and v5
        jg      .L16                    ; if v4 > v5 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L17                    ; unconditionally jump
.L16:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L17:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L18                    ; if T0 is false then jump to end of if
        mov     eax,[I7]                ; AReg = v4
        mov     [I2],eax                ; temp = AReg
        mov     eax,[I8]                ; AReg = v5
        mov     [I7],eax                ; v4 = AReg
        mov     eax,[I2]                ; AReg = temp
        mov     [I8],eax                ; v5 = AReg
.L18:                                   ; end if
        mov     eax,[I8]                ; AReg = v5
        cmp     eax,[I9]                ; compare v5 and v6
        jg      .L19                    ; if v5 > v6 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L20                    ; unconditionally jump
.L19:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L20:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L21                    ; if T0 is false then jump to end of if
        mov     eax,[I8]                ; AReg = v5
        mov     [I2],eax                ; temp = AReg
        mov     eax,[I9]                ; AReg = v6
        mov     [I8],eax                ; v5 = AReg
        mov     eax,[I2]                ; AReg = temp
        mov     [I9],eax                ; v6 = AReg
.L21:                                   ; end if
        mov     eax,[I9]                ; AReg = v6
        cmp     eax,[I10]               ; compare v6 and v7
        jg      .L22                    ; if v6 > v7 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L23                    ; unconditionally jump
.L22:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L23:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L24                    ; if T0 is false then jump to end of if
        mov     eax,[I9]                ; AReg = v6
        mov     [I2],eax                ; temp = AReg
        mov     eax,[I10]               ; AReg = v7
        mov     [I9],eax                ; v6 = AReg
        mov     eax,[I2]                ; AReg = temp
        mov     [I10],eax               ; v7 = AReg
.L24:                                   ; end if
        mov     eax,[I10]               ; AReg = v7
        cmp     eax,[I11]               ; compare v7 and v8
        jg      .L25                    ; if v7 > v8 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L26                    ; unconditionally jump
.L25:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L26:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L27                    ; if T0 is false then jump to end of if
        mov     eax,[I10]               ; AReg = v7
        mov     [I2],eax                ; temp = AReg
        mov     eax,[I11]               ; AReg = v8
        mov     [I10],eax               ; v7 = AReg
        mov     eax,[I2]                ; AReg = temp
        mov     [I11],eax               ; v8 = AReg
.L27:                                   ; end if
        mov     eax,[I11]               ; AReg = v8
        cmp     eax,[I12]               ; compare v8 and v9
        jg      .L28                    ; if v8 > v9 then jump to set eax to TRUE
        mov     eax,[FALSE]             ; else set eax to FALSE
        jmp     .L29                    ; unconditionally jump
.L28:                                   
        mov     eax,[TRUE]              ; set eax to TRUE
.L29:                                   
        cmp     eax,0                   ; compare eax to 0
        je      .L30                    ; if T0 is false then jump to end of if
        mov     eax,[I11]               ; AReg = v8
        mov     [I2],eax                ; temp = AReg
        mov     eax,[I12]               ; AReg = v9
        mov     [I11],eax               ; v8 = AReg
        mov     eax,[I2]                ; AReg = temp
        mov     [I12],eax               ; v9 = AReg
.L30:                                   ; end if
        mov     eax,[I1]                ; AReg = pass
        add     eax,[I14]               ; AReg = pass + 1
        mov     [I1],eax                ; pass = AReg
        jmp     .L0                     ; end while
.L3:                                    
        mov     eax,[I3]                ; load v0 in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I4]                ; load v1 in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I5]                ; load v2 in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I6]                ; load v3 in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I7]                ; load v4 in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I8]                ; load v5 in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I9]                ; load v6 in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I10]               ; load v7 in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I11]               ; load v8 in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I12]               ; load v9 in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                    
SECTION .data                           
I13     dd      0                       ; 0
I14     dd      1                       ; 1
FALSE   dd      0                       ; false
I0      dd      10                      ; n
TRUE    dd      -1                      ; true

SECTION .bss                            
I1      resd    1                       ; pass
I2      resd    1                       ; temp
I3      resd    1                       ; v0
I4      resd    1                       ; v1
I5      resd    1                       ; v2
I6      resd    1                       ; v3
I7      resd    1                       ; v4
I8      resd    1                       ; v5
I9      resd    1                       ; v6
I10     resd    1                       ; v7
I11     resd    1                       ; v8
I12     resd    1                       ; v9

./output/250.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no250

_start:                                 
        Exit    {0}
                    
SECTION .data                           

SECTION .bss                            

./output/251.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no251

_start:                                 

./output/252.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program stage2no252

_start:                                 

./output/253.my.asm
------------------------------
; Kangmin Kim, Jeff Caldwell       Wed Dec  7 00:20:48 2022
%INCLUDE "Along32.inc"
%INCLUDE "Macros_Along.inc"

SECTION .text                           
global  _start                          ; program mytest

_start:                                 
        mov     eax,[I0]                ; AReg = s
        add     eax,[I4]                ; AReg = s + -3
        mov     [I2],eax                ; t = AReg
        mov     eax,[I1]                ; AReg = a
        add     eax,[I5]                ; AReg = a + 2
        mov     [I3],eax                ; b = AReg
        mov     eax,[I2]                ; load t in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        mov     eax,[I3]                ; load b in eax
        call    WriteInt                ; write int in eax to standard out
        call    Crlf                    ; write \r\n to standard out
        Exit    {0}
                    
SECTION .data                           
I4      dd      -3                      ; -3
I5      dd      2                       ; 2
I1      dd      2                       ; a
I0      dd      -3                      ; s

SECTION .bss                            
I3      resd    1                       ; b
I2      resd    1                       ; t

